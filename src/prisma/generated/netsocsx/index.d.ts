
/**
 * Client
**/

import * as runtime from './runtime/index';
declare const prisma: unique symbol
export type PrismaPromise<A> = Promise<A> & {[prisma]: true}
type UnwrapPromise<P extends any> = P extends Promise<infer R> ? R : P
type UnwrapTuple<Tuple extends readonly unknown[]> = {
  [K in keyof Tuple]: K extends `${number}` ? Tuple[K] extends PrismaPromise<infer X> ? X : UnwrapPromise<Tuple[K]> : UnwrapPromise<Tuple[K]>
};


/**
 * Model controladores
 * 
 */
export type controladores = {
  IDControlador: number
  IDEdificio: number | null
  NombreControlador: string | null
  Descripcion: string | null
  IDIcono: number | null
  TipoControlador: number | null
  Prioridad: string | null
  Certificado: string | null
  PuertoSSL: number | null
  PuertoNoSSL: number | null
  PuertoMantenimiento: number | null
  PuertoConexionSC: number | null
  PuertoConexionCC: number | null
  SOAP: string | null
  Socket: string | null
  API: string | null
  Sincroniza: string | null
  DireccionAIPV4: string | null
  DireccionBIPv4: string | null
  DireccionAIPV6: string | null
  DireccionBIPv6: string | null
  DireccionPublica1: string | null
  DireccionPublica2: string | null
  Localizacion: string | null
  Latitud: Prisma.Decimal | null
  Longitud: Prisma.Decimal | null
  Estatus: number | null
  FechaCreado: Date | null
  FechaDesactivado: Date | null
}

/**
 * Model dispositivos
 * 
 */
export type dispositivos = {
  IDDispositivo: number
  IDSubsistema: number | null
  IDTipoFamilia: number | null
  IDFamilia: number | null
  IDFabricante: number | null
  IDTipoDispositivo: number | null
  IDGateway: number | null
  IDControlador: number | null
  IDModelo: number | null
  IDEdificio: number | null
  IDZona: number | null
  IDPuerta: number | null
  NombreDispositivo: string | null
  Descripcion: string | null
  IDIconografia: number | null
  IDMenuPropio: number | null
  Estatus: string | null
  Sentidos: string | null
  Ignorado: string | null
  Enrolamiento: string | null
  Latitud: Prisma.Decimal | null
  Longitud: Prisma.Decimal | null
  DireccionGPS: string | null
  GeometriaGPS: string | null
  IDTipoEvento: number | null
  IDModeloElemento: number | null
  FechaCreacion: Date | null
  FechaDesactivacion: Date | null
  FechaEliminacion: Date | null
  Parametros: string | null
  Certificado: string | null
  PuertoSSL: number | null
  PuertoNoSSL: number | null
  PuertoMantenimiento: number | null
  PuertoConexionSC: number | null
  PuertoConexionCC: number | null
  SOAP: string | null
  Socket: string | null
  API: string | null
  Sincroniza: string | null
  DireccionAIPV4: string | null
  DireccionBIPv4: string | null
  DireccionAIPV6: string | null
  DireccionBIPv6: string | null
  DireccionPublica1: string | null
  DireccionPublica2: string | null
  Serial: string | null
  user: string | null
  password: string | null
  IDManual: number | null
  Directo: number | null
}

/**
 * Model gateway
 * 
 */
export type gateway = {
  IDGateway: number
  IDTipoGateway: number | null
  IDControlador: number | null
  IDEdificio: number | null
  IDIdentificadorExterno: string | null
  IDTipoEvento: number | null
  IDGrupoMetodo: number | null
  NAbonado: string | null
  NombreGateway: string | null
  Descripcion: string | null
  IDIcono: number | null
  ValorEstado: Buffer | null
  Parametros: string | null
  EstadoOnOff: string | null
  Latitud: Prisma.Decimal | null
  Longitud: Prisma.Decimal | null
  SerialGPS: string | null
  GeometriaGPS: string | null
  FechaCreado: Date | null
  FechaDesactivado: Date | null
  Certificado: string | null
  PuertoSSL: number | null
  PuertoNoSSL: number | null
  PuertoMantenimiento: number | null
  PuertoConexionSC: number | null
  PuertoConexionCC: number | null
  SOAP: string | null
  Socket: string | null
  API: string | null
  Sincroniza: string | null
  DireccionAIPV4: string | null
  DireccionBIPv4: string | null
  DireccionAIPV6: string | null
  DireccionBIPv6: string | null
  DireccionPublica1: string | null
  DireccionPublica2: string | null
  user: string | null
  password: string | null
  Serial: string | null
  IDManual: number | null
  IDZona: number | null
}

/**
 * Model gruposdispositivos
 * 
 */
export type gruposdispositivos = {
  IDGrupoDispositivo: number
  NombreGrupoDispositivo: string | null
  Identificador: string | null
  Descripcion: string | null
}

/**
 * Model inventariocatastro
 * 
 */
export type inventariocatastro = {
  IDEntidadInventario: number
  IDTipoEntidadInventario: number | null
  IDCategoriaEntidadInventario: number | null
  IDGateway: number | null
  IDDispositivo: number | null
  IDMetaEdificio: number | null
  IDEdificio: number | null
  NombreEntidadInventario: string | null
  Descripcion: string | null
  Latitud: Prisma.Decimal | null
  Longitud: Prisma.Decimal | null
  SerialGPS: string | null
  GeometriaGPS: string | null
  FechaAlta: Date | null
  FechaBaja: Date | null
}

/**
 * Model libreriasapis
 * 
 */
export type libreriasapis = {
  IDLIBAPISDK: number
  Nombre: string | null
  Tipo: string | null
  Web: string | null
  Subsistema: number | null
  Alcance: string | null
}

/**
 * Model metodogrupo
 * 
 */
export type metodogrupo = {
  IDGrupoMetodo: number
  NombreGrupoMetodo: string | null
  Corporacion: string | null
  Departamento: string | null
  Edificio: string | null
  Itinerario: string | null
  Empleado: string | null
  Modificable: string | null
  Descripcion: string | null
  Tipo: string | null
  IDGrupoMetodoPadre: number | null
  Identificador: string | null
  IdentificadorExterno: string | null
}

/**
 * Model metodos
 * 
 */
export type metodos = {
  IDMetodo: number
  Indice: number
  IDGrupoMetodo: number
  IDLibreria: number | null
  IDMetodoPadre: number | null
  Clase: string
  Tipo: string
  Propagable: string
  BlobsPropagable: string
  NParametros: number
  NParametrosBinarios: number
  Basico: string
  Estado: string
  Descripcion: string | null
  NombreMetodo: string | null
  NombreFuncion: string | null
  MetodoTrigger: string | null
  EnvioAplicacion: string
  EjecucionLibre: string
}

/**
 * Model objetosplanimetria
 * 
 */
export type objetosplanimetria = {
  Id: number
  NombreObjeto: string | null
  URLHost: string | null
  IpHost: string | null
  Puerto: number | null
  Usuario: string | null
  Clave: string | null
}

/**
 * Model reldispositivodispositivo
 * 
 */
export type reldispositivodispositivo = {
  IDRelDisDispositivo: number
  IDDispositivoPadre: number | null
  IDDispositivoHijo: number | null
}

/**
 * Model reldispositivogateway
 * 
 */
export type reldispositivogateway = {
  IDRelDisGateway: number
  IDDispositivo: number | null
  IDGateway: number | null
}

/**
 * Model reldispositivogrupodispositivo
 * 
 */
export type reldispositivogrupodispositivo = {
  IDRelDisGrupoDis: number
  IDGrupo: string | null
  IDDispositivo: string | null
}

/**
 * Model reldispositivoperfildispositivo
 * 
 */
export type reldispositivoperfildispositivo = {
  IDRelDisPerfil: number
  IDDispositivo: number
  IDPerfilDispositivo: number
}

/**
 * Model reldispositivoplantillaanalogica
 * 
 */
export type reldispositivoplantillaanalogica = {
  IDRelDisPlantillaAnaloga: number
  IDPlantillaAnalogica: number
  IDDispositivo: number
  Formula: string | null
  Version: string | null
}

/**
 * Model reldispositivopuerta
 * 
 */
export type reldispositivopuerta = {
  IDRelDisPuerta: number
  IDDispositivo: number
  IDPuerta: number
  IDTipoDispositivo: number
}

/**
 * Model reldispositivosubsistema
 * 
 */
export type reldispositivosubsistema = {
  IDRelDisSubsistema: number
  IDSubsistema: number | null
  IDDispositivo: number | null
}

/**
 * Model reldispositivotipoevento
 * 
 */
export type reldispositivotipoevento = {
  IDRelDisTipoEvento: number
  IDDispositivo: number
  ClaseEvento: number
}

/**
 * Model reldispositivozona
 * 
 */
export type reldispositivozona = {
  IDRelDisZona: number
  IDDispositivo: number | null
  IDZona: number | null
}

/**
 * Model reltipocontroladormetodo
 * 
 */
export type reltipocontroladormetodo = {
  IDTipoControlador: number
  IDMetodo: number | null
  RelTipoControladorMetodo: number | null
}

/**
 * Model reltipodispositivoperfildispositivo
 * 
 */
export type reltipodispositivoperfildispositivo = {
  IDRelTipoDispPerfil: number
  IDTipoDispositivo: number
  IDPerfilDispositivo: number
}

/**
 * Model reltipodispositivoperfilevento
 * 
 */
export type reltipodispositivoperfilevento = {
  IDRelTipoDisPerfilEvento: number
  IDTipoDispositivo: number
  IDPerfilEvento: number
}

/**
 * Model reltipodispositivotipotecnologia
 * 
 */
export type reltipodispositivotipotecnologia = {
  IDRelTipoDispTipoTec: number
  IDTipoDispositivo: number
  IDTipoTecnologia: number
}

/**
 * Model reltipogatewayperfildispositivo
 * 
 */
export type reltipogatewayperfildispositivo = {
  IDRelTipoGatewayPerfil: number
  IDTipoGateway: number | null
  IDPerfilDispositivo: number | null
}

/**
 * Model subsistemas
 * 
 */
export type subsistemas = {
  IDSubSistema: number
  NombreSubSistema: string | null
  DescripcionSubSistema: string | null
  URLSubSistema: string | null
  Puerto: number | null
}

/**
 * Model tablasinformacion
 * 
 */
export type tablasinformacion = {
  IDTabla: number
  NombreTabla: string | null
  Tipo: number | null
  Identidad: string | null
  CodigoNetsocs: number | null
}

/**
 * Model tecnologiasnetsocs
 * 
 */
export type tecnologiasnetsocs = {
  IDTecnologiaGateway: number
  NombreTecnologiaGateway: string | null
}


/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Controladores
 * const controladores = await prisma.controladores.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  GlobalReject extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined = 'rejectOnNotFound' extends keyof T
    ? T['rejectOnNotFound']
    : false
      > {
    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Controladores
   * const controladores = await prisma.controladores.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends (U | 'beforeExit')>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : V extends 'beforeExit' ? () => Promise<void> : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): Promise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): Promise<void>;

  /**
   * Add a middleware
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): Promise<UnwrapTuple<P>>;

  $transaction<R>(fn: (prisma: Prisma.TransactionClient) => Promise<R>, options?: {maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel}): Promise<R>;

      /**
   * `prisma.controladores`: Exposes CRUD operations for the **controladores** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Controladores
    * const controladores = await prisma.controladores.findMany()
    * ```
    */
  get controladores(): Prisma.controladoresDelegate<GlobalReject>;

  /**
   * `prisma.dispositivos`: Exposes CRUD operations for the **dispositivos** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Dispositivos
    * const dispositivos = await prisma.dispositivos.findMany()
    * ```
    */
  get dispositivos(): Prisma.dispositivosDelegate<GlobalReject>;

  /**
   * `prisma.gateway`: Exposes CRUD operations for the **gateway** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Gateways
    * const gateways = await prisma.gateway.findMany()
    * ```
    */
  get gateway(): Prisma.gatewayDelegate<GlobalReject>;

  /**
   * `prisma.gruposdispositivos`: Exposes CRUD operations for the **gruposdispositivos** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Gruposdispositivos
    * const gruposdispositivos = await prisma.gruposdispositivos.findMany()
    * ```
    */
  get gruposdispositivos(): Prisma.gruposdispositivosDelegate<GlobalReject>;

  /**
   * `prisma.inventariocatastro`: Exposes CRUD operations for the **inventariocatastro** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Inventariocatastros
    * const inventariocatastros = await prisma.inventariocatastro.findMany()
    * ```
    */
  get inventariocatastro(): Prisma.inventariocatastroDelegate<GlobalReject>;

  /**
   * `prisma.libreriasapis`: Exposes CRUD operations for the **libreriasapis** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Libreriasapis
    * const libreriasapis = await prisma.libreriasapis.findMany()
    * ```
    */
  get libreriasapis(): Prisma.libreriasapisDelegate<GlobalReject>;

  /**
   * `prisma.metodogrupo`: Exposes CRUD operations for the **metodogrupo** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Metodogrupos
    * const metodogrupos = await prisma.metodogrupo.findMany()
    * ```
    */
  get metodogrupo(): Prisma.metodogrupoDelegate<GlobalReject>;

  /**
   * `prisma.metodos`: Exposes CRUD operations for the **metodos** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Metodos
    * const metodos = await prisma.metodos.findMany()
    * ```
    */
  get metodos(): Prisma.metodosDelegate<GlobalReject>;

  /**
   * `prisma.objetosplanimetria`: Exposes CRUD operations for the **objetosplanimetria** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Objetosplanimetrias
    * const objetosplanimetrias = await prisma.objetosplanimetria.findMany()
    * ```
    */
  get objetosplanimetria(): Prisma.objetosplanimetriaDelegate<GlobalReject>;

  /**
   * `prisma.reldispositivodispositivo`: Exposes CRUD operations for the **reldispositivodispositivo** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Reldispositivodispositivos
    * const reldispositivodispositivos = await prisma.reldispositivodispositivo.findMany()
    * ```
    */
  get reldispositivodispositivo(): Prisma.reldispositivodispositivoDelegate<GlobalReject>;

  /**
   * `prisma.reldispositivogateway`: Exposes CRUD operations for the **reldispositivogateway** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Reldispositivogateways
    * const reldispositivogateways = await prisma.reldispositivogateway.findMany()
    * ```
    */
  get reldispositivogateway(): Prisma.reldispositivogatewayDelegate<GlobalReject>;

  /**
   * `prisma.reldispositivogrupodispositivo`: Exposes CRUD operations for the **reldispositivogrupodispositivo** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Reldispositivogrupodispositivos
    * const reldispositivogrupodispositivos = await prisma.reldispositivogrupodispositivo.findMany()
    * ```
    */
  get reldispositivogrupodispositivo(): Prisma.reldispositivogrupodispositivoDelegate<GlobalReject>;

  /**
   * `prisma.reldispositivoperfildispositivo`: Exposes CRUD operations for the **reldispositivoperfildispositivo** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Reldispositivoperfildispositivos
    * const reldispositivoperfildispositivos = await prisma.reldispositivoperfildispositivo.findMany()
    * ```
    */
  get reldispositivoperfildispositivo(): Prisma.reldispositivoperfildispositivoDelegate<GlobalReject>;

  /**
   * `prisma.reldispositivoplantillaanalogica`: Exposes CRUD operations for the **reldispositivoplantillaanalogica** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Reldispositivoplantillaanalogicas
    * const reldispositivoplantillaanalogicas = await prisma.reldispositivoplantillaanalogica.findMany()
    * ```
    */
  get reldispositivoplantillaanalogica(): Prisma.reldispositivoplantillaanalogicaDelegate<GlobalReject>;

  /**
   * `prisma.reldispositivopuerta`: Exposes CRUD operations for the **reldispositivopuerta** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Reldispositivopuertas
    * const reldispositivopuertas = await prisma.reldispositivopuerta.findMany()
    * ```
    */
  get reldispositivopuerta(): Prisma.reldispositivopuertaDelegate<GlobalReject>;

  /**
   * `prisma.reldispositivosubsistema`: Exposes CRUD operations for the **reldispositivosubsistema** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Reldispositivosubsistemas
    * const reldispositivosubsistemas = await prisma.reldispositivosubsistema.findMany()
    * ```
    */
  get reldispositivosubsistema(): Prisma.reldispositivosubsistemaDelegate<GlobalReject>;

  /**
   * `prisma.reldispositivotipoevento`: Exposes CRUD operations for the **reldispositivotipoevento** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Reldispositivotipoeventos
    * const reldispositivotipoeventos = await prisma.reldispositivotipoevento.findMany()
    * ```
    */
  get reldispositivotipoevento(): Prisma.reldispositivotipoeventoDelegate<GlobalReject>;

  /**
   * `prisma.reldispositivozona`: Exposes CRUD operations for the **reldispositivozona** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Reldispositivozonas
    * const reldispositivozonas = await prisma.reldispositivozona.findMany()
    * ```
    */
  get reldispositivozona(): Prisma.reldispositivozonaDelegate<GlobalReject>;

  /**
   * `prisma.reltipocontroladormetodo`: Exposes CRUD operations for the **reltipocontroladormetodo** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Reltipocontroladormetodos
    * const reltipocontroladormetodos = await prisma.reltipocontroladormetodo.findMany()
    * ```
    */
  get reltipocontroladormetodo(): Prisma.reltipocontroladormetodoDelegate<GlobalReject>;

  /**
   * `prisma.reltipodispositivoperfildispositivo`: Exposes CRUD operations for the **reltipodispositivoperfildispositivo** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Reltipodispositivoperfildispositivos
    * const reltipodispositivoperfildispositivos = await prisma.reltipodispositivoperfildispositivo.findMany()
    * ```
    */
  get reltipodispositivoperfildispositivo(): Prisma.reltipodispositivoperfildispositivoDelegate<GlobalReject>;

  /**
   * `prisma.reltipodispositivoperfilevento`: Exposes CRUD operations for the **reltipodispositivoperfilevento** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Reltipodispositivoperfileventos
    * const reltipodispositivoperfileventos = await prisma.reltipodispositivoperfilevento.findMany()
    * ```
    */
  get reltipodispositivoperfilevento(): Prisma.reltipodispositivoperfileventoDelegate<GlobalReject>;

  /**
   * `prisma.reltipodispositivotipotecnologia`: Exposes CRUD operations for the **reltipodispositivotipotecnologia** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Reltipodispositivotipotecnologias
    * const reltipodispositivotipotecnologias = await prisma.reltipodispositivotipotecnologia.findMany()
    * ```
    */
  get reltipodispositivotipotecnologia(): Prisma.reltipodispositivotipotecnologiaDelegate<GlobalReject>;

  /**
   * `prisma.reltipogatewayperfildispositivo`: Exposes CRUD operations for the **reltipogatewayperfildispositivo** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Reltipogatewayperfildispositivos
    * const reltipogatewayperfildispositivos = await prisma.reltipogatewayperfildispositivo.findMany()
    * ```
    */
  get reltipogatewayperfildispositivo(): Prisma.reltipogatewayperfildispositivoDelegate<GlobalReject>;

  /**
   * `prisma.subsistemas`: Exposes CRUD operations for the **subsistemas** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Subsistemas
    * const subsistemas = await prisma.subsistemas.findMany()
    * ```
    */
  get subsistemas(): Prisma.subsistemasDelegate<GlobalReject>;

  /**
   * `prisma.tablasinformacion`: Exposes CRUD operations for the **tablasinformacion** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tablasinformacions
    * const tablasinformacions = await prisma.tablasinformacion.findMany()
    * ```
    */
  get tablasinformacion(): Prisma.tablasinformacionDelegate<GlobalReject>;

  /**
   * `prisma.tecnologiasnetsocs`: Exposes CRUD operations for the **tecnologiasnetsocs** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tecnologiasnetsocs
    * const tecnologiasnetsocs = await prisma.tecnologiasnetsocs.findMany()
    * ```
    */
  get tecnologiasnetsocs(): Prisma.tecnologiasnetsocsDelegate<GlobalReject>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket


  /**
   * Prisma Client JS version: 4.7.1
   * Query Engine version: ca7fcef713137fa11029d519a9780db130cca91d
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Matches a JSON object.
   * Unlike `JsonObject`, this type allows undefined and read-only properties.
   */
  export type InputJsonObject = {readonly [Key in string]?: InputJsonValue | null}

  /**
   * Matches a JSON array.
   * Unlike `JsonArray`, readonly arrays are assignable to this type.
   */
  export interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike `JsonValue`, this
   * type allows read-only arrays and read-only object properties and disallows
   * `null` at the top level.
   *
   * `null` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
   * `Prisma.DbNull` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }
  type HasSelect = {
    select: any
  }
  type HasInclude = {
    include: any
  }
  type CheckSelect<T, S, U> = T extends SelectAndInclude
    ? 'Please either choose `select` or `include`'
    : T extends HasSelect
    ? U
    : T extends HasInclude
    ? U
    : S

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => Promise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Exact<A, W = unknown> = 
  W extends unknown ? A extends Narrowable ? Cast<A, W> : Cast<
  {[K in keyof A]: K extends keyof W ? Exact<A[K], W[K]> : never},
  {[K in keyof W]: K extends keyof A ? Exact<A[K], W[K]> : W[K]}>
  : never;

  type Narrowable = string | number | boolean | bigint;

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;

  export function validator<V>(): <S>(select: Exact<S, V>) => S;

  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but with an array
   */
  type PickArray<T, K extends Array<keyof T>> = Prisma__Pick<T, TupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>

  class PrismaClientFetcher {
    private readonly prisma;
    private readonly debug;
    private readonly hooks?;
    constructor(prisma: PrismaClient<any, any>, debug?: boolean, hooks?: Hooks | undefined);
    request<T>(document: any, dataPath?: string[], rootField?: string, typeName?: string, isList?: boolean, callsite?: string): Promise<T>;
    sanitizeMessage(message: string): string;
    protected unpack(document: any, data: any, path: string[], rootField?: string, isList?: boolean): any;
  }

  export const ModelName: {
    controladores: 'controladores',
    dispositivos: 'dispositivos',
    gateway: 'gateway',
    gruposdispositivos: 'gruposdispositivos',
    inventariocatastro: 'inventariocatastro',
    libreriasapis: 'libreriasapis',
    metodogrupo: 'metodogrupo',
    metodos: 'metodos',
    objetosplanimetria: 'objetosplanimetria',
    reldispositivodispositivo: 'reldispositivodispositivo',
    reldispositivogateway: 'reldispositivogateway',
    reldispositivogrupodispositivo: 'reldispositivogrupodispositivo',
    reldispositivoperfildispositivo: 'reldispositivoperfildispositivo',
    reldispositivoplantillaanalogica: 'reldispositivoplantillaanalogica',
    reldispositivopuerta: 'reldispositivopuerta',
    reldispositivosubsistema: 'reldispositivosubsistema',
    reldispositivotipoevento: 'reldispositivotipoevento',
    reldispositivozona: 'reldispositivozona',
    reltipocontroladormetodo: 'reltipocontroladormetodo',
    reltipodispositivoperfildispositivo: 'reltipodispositivoperfildispositivo',
    reltipodispositivoperfilevento: 'reltipodispositivoperfilevento',
    reltipodispositivotipotecnologia: 'reltipodispositivotipotecnologia',
    reltipogatewayperfildispositivo: 'reltipogatewayperfildispositivo',
    subsistemas: 'subsistemas',
    tablasinformacion: 'tablasinformacion',
    tecnologiasnetsocs: 'tecnologiasnetsocs'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  export type RejectOnNotFound = boolean | ((error: Error) => Error)
  export type RejectPerModel = { [P in ModelName]?: RejectOnNotFound }
  export type RejectPerOperation =  { [P in "findUnique" | "findFirst"]?: RejectPerModel | RejectOnNotFound } 
  type IsReject<T> = T extends true ? True : T extends (err: Error) => Error ? True : False
  export type HasReject<
    GlobalRejectSettings extends Prisma.PrismaClientOptions['rejectOnNotFound'],
    LocalRejectSettings,
    Action extends PrismaAction,
    Model extends ModelName
  > = LocalRejectSettings extends RejectOnNotFound
    ? IsReject<LocalRejectSettings>
    : GlobalRejectSettings extends RejectPerOperation
    ? Action extends keyof GlobalRejectSettings
      ? GlobalRejectSettings[Action] extends RejectOnNotFound
        ? IsReject<GlobalRejectSettings[Action]>
        : GlobalRejectSettings[Action] extends RejectPerModel
        ? Model extends keyof GlobalRejectSettings[Action]
          ? IsReject<GlobalRejectSettings[Action][Model]>
          : False
        : False
      : False
    : IsReject<GlobalRejectSettings>
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'

  export interface PrismaClientOptions {
    /**
     * Configure findUnique/findFirst to throw an error if the query returns null. 
     * @deprecated since 4.0.0. Use `findUniqueOrThrow`/`findFirstOrThrow` methods instead.
     * @example
     * ```
     * // Reject on both findUnique/findFirst
     * rejectOnNotFound: true
     * // Reject only on findFirst with a custom error
     * rejectOnNotFound: { findFirst: (err) => new Error("Custom Error")}
     * // Reject on user.findUnique with a custom error
     * rejectOnNotFound: { findUnique: {User: (err) => new Error("User not found")}}
     * ```
     */
    rejectOnNotFound?: RejectOnNotFound | RejectPerOperation
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources

    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat

    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: Array<LogLevel | LogDefinition>
  }

  export type Hooks = {
    beforeRequest?: (options: { query: string, path: string[], rootField?: string, typeName?: string, document: any }) => any
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findMany'
    | 'findFirst'
    | 'create'
    | 'createMany'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => Promise<T>,
  ) => Promise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<PrismaClient, '$connect' | '$disconnect' | '$on' | '$transaction' | '$use'>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */



  /**
   * Models
   */

  /**
   * Model controladores
   */


  export type AggregateControladores = {
    _count: ControladoresCountAggregateOutputType | null
    _avg: ControladoresAvgAggregateOutputType | null
    _sum: ControladoresSumAggregateOutputType | null
    _min: ControladoresMinAggregateOutputType | null
    _max: ControladoresMaxAggregateOutputType | null
  }

  export type ControladoresAvgAggregateOutputType = {
    IDControlador: number | null
    IDEdificio: number | null
    IDIcono: number | null
    TipoControlador: number | null
    PuertoSSL: number | null
    PuertoNoSSL: number | null
    PuertoMantenimiento: number | null
    PuertoConexionSC: number | null
    PuertoConexionCC: number | null
    Latitud: Decimal | null
    Longitud: Decimal | null
    Estatus: number | null
  }

  export type ControladoresSumAggregateOutputType = {
    IDControlador: number | null
    IDEdificio: number | null
    IDIcono: number | null
    TipoControlador: number | null
    PuertoSSL: number | null
    PuertoNoSSL: number | null
    PuertoMantenimiento: number | null
    PuertoConexionSC: number | null
    PuertoConexionCC: number | null
    Latitud: Decimal | null
    Longitud: Decimal | null
    Estatus: number | null
  }

  export type ControladoresMinAggregateOutputType = {
    IDControlador: number | null
    IDEdificio: number | null
    NombreControlador: string | null
    Descripcion: string | null
    IDIcono: number | null
    TipoControlador: number | null
    Prioridad: string | null
    Certificado: string | null
    PuertoSSL: number | null
    PuertoNoSSL: number | null
    PuertoMantenimiento: number | null
    PuertoConexionSC: number | null
    PuertoConexionCC: number | null
    SOAP: string | null
    Socket: string | null
    API: string | null
    Sincroniza: string | null
    DireccionAIPV4: string | null
    DireccionBIPv4: string | null
    DireccionAIPV6: string | null
    DireccionBIPv6: string | null
    DireccionPublica1: string | null
    DireccionPublica2: string | null
    Localizacion: string | null
    Latitud: Decimal | null
    Longitud: Decimal | null
    Estatus: number | null
    FechaCreado: Date | null
    FechaDesactivado: Date | null
  }

  export type ControladoresMaxAggregateOutputType = {
    IDControlador: number | null
    IDEdificio: number | null
    NombreControlador: string | null
    Descripcion: string | null
    IDIcono: number | null
    TipoControlador: number | null
    Prioridad: string | null
    Certificado: string | null
    PuertoSSL: number | null
    PuertoNoSSL: number | null
    PuertoMantenimiento: number | null
    PuertoConexionSC: number | null
    PuertoConexionCC: number | null
    SOAP: string | null
    Socket: string | null
    API: string | null
    Sincroniza: string | null
    DireccionAIPV4: string | null
    DireccionBIPv4: string | null
    DireccionAIPV6: string | null
    DireccionBIPv6: string | null
    DireccionPublica1: string | null
    DireccionPublica2: string | null
    Localizacion: string | null
    Latitud: Decimal | null
    Longitud: Decimal | null
    Estatus: number | null
    FechaCreado: Date | null
    FechaDesactivado: Date | null
  }

  export type ControladoresCountAggregateOutputType = {
    IDControlador: number
    IDEdificio: number
    NombreControlador: number
    Descripcion: number
    IDIcono: number
    TipoControlador: number
    Prioridad: number
    Certificado: number
    PuertoSSL: number
    PuertoNoSSL: number
    PuertoMantenimiento: number
    PuertoConexionSC: number
    PuertoConexionCC: number
    SOAP: number
    Socket: number
    API: number
    Sincroniza: number
    DireccionAIPV4: number
    DireccionBIPv4: number
    DireccionAIPV6: number
    DireccionBIPv6: number
    DireccionPublica1: number
    DireccionPublica2: number
    Localizacion: number
    Latitud: number
    Longitud: number
    Estatus: number
    FechaCreado: number
    FechaDesactivado: number
    _all: number
  }


  export type ControladoresAvgAggregateInputType = {
    IDControlador?: true
    IDEdificio?: true
    IDIcono?: true
    TipoControlador?: true
    PuertoSSL?: true
    PuertoNoSSL?: true
    PuertoMantenimiento?: true
    PuertoConexionSC?: true
    PuertoConexionCC?: true
    Latitud?: true
    Longitud?: true
    Estatus?: true
  }

  export type ControladoresSumAggregateInputType = {
    IDControlador?: true
    IDEdificio?: true
    IDIcono?: true
    TipoControlador?: true
    PuertoSSL?: true
    PuertoNoSSL?: true
    PuertoMantenimiento?: true
    PuertoConexionSC?: true
    PuertoConexionCC?: true
    Latitud?: true
    Longitud?: true
    Estatus?: true
  }

  export type ControladoresMinAggregateInputType = {
    IDControlador?: true
    IDEdificio?: true
    NombreControlador?: true
    Descripcion?: true
    IDIcono?: true
    TipoControlador?: true
    Prioridad?: true
    Certificado?: true
    PuertoSSL?: true
    PuertoNoSSL?: true
    PuertoMantenimiento?: true
    PuertoConexionSC?: true
    PuertoConexionCC?: true
    SOAP?: true
    Socket?: true
    API?: true
    Sincroniza?: true
    DireccionAIPV4?: true
    DireccionBIPv4?: true
    DireccionAIPV6?: true
    DireccionBIPv6?: true
    DireccionPublica1?: true
    DireccionPublica2?: true
    Localizacion?: true
    Latitud?: true
    Longitud?: true
    Estatus?: true
    FechaCreado?: true
    FechaDesactivado?: true
  }

  export type ControladoresMaxAggregateInputType = {
    IDControlador?: true
    IDEdificio?: true
    NombreControlador?: true
    Descripcion?: true
    IDIcono?: true
    TipoControlador?: true
    Prioridad?: true
    Certificado?: true
    PuertoSSL?: true
    PuertoNoSSL?: true
    PuertoMantenimiento?: true
    PuertoConexionSC?: true
    PuertoConexionCC?: true
    SOAP?: true
    Socket?: true
    API?: true
    Sincroniza?: true
    DireccionAIPV4?: true
    DireccionBIPv4?: true
    DireccionAIPV6?: true
    DireccionBIPv6?: true
    DireccionPublica1?: true
    DireccionPublica2?: true
    Localizacion?: true
    Latitud?: true
    Longitud?: true
    Estatus?: true
    FechaCreado?: true
    FechaDesactivado?: true
  }

  export type ControladoresCountAggregateInputType = {
    IDControlador?: true
    IDEdificio?: true
    NombreControlador?: true
    Descripcion?: true
    IDIcono?: true
    TipoControlador?: true
    Prioridad?: true
    Certificado?: true
    PuertoSSL?: true
    PuertoNoSSL?: true
    PuertoMantenimiento?: true
    PuertoConexionSC?: true
    PuertoConexionCC?: true
    SOAP?: true
    Socket?: true
    API?: true
    Sincroniza?: true
    DireccionAIPV4?: true
    DireccionBIPv4?: true
    DireccionAIPV6?: true
    DireccionBIPv6?: true
    DireccionPublica1?: true
    DireccionPublica2?: true
    Localizacion?: true
    Latitud?: true
    Longitud?: true
    Estatus?: true
    FechaCreado?: true
    FechaDesactivado?: true
    _all?: true
  }

  export type ControladoresAggregateArgs = {
    /**
     * Filter which controladores to aggregate.
     * 
    **/
    where?: controladoresWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of controladores to fetch.
     * 
    **/
    orderBy?: Enumerable<controladoresOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: controladoresWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` controladores from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` controladores.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned controladores
    **/
    _count?: true | ControladoresCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ControladoresAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ControladoresSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ControladoresMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ControladoresMaxAggregateInputType
  }

  export type GetControladoresAggregateType<T extends ControladoresAggregateArgs> = {
        [P in keyof T & keyof AggregateControladores]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateControladores[P]>
      : GetScalarType<T[P], AggregateControladores[P]>
  }




  export type ControladoresGroupByArgs = {
    where?: controladoresWhereInput
    orderBy?: Enumerable<controladoresOrderByWithAggregationInput>
    by: Array<ControladoresScalarFieldEnum>
    having?: controladoresScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ControladoresCountAggregateInputType | true
    _avg?: ControladoresAvgAggregateInputType
    _sum?: ControladoresSumAggregateInputType
    _min?: ControladoresMinAggregateInputType
    _max?: ControladoresMaxAggregateInputType
  }


  export type ControladoresGroupByOutputType = {
    IDControlador: number
    IDEdificio: number | null
    NombreControlador: string | null
    Descripcion: string | null
    IDIcono: number | null
    TipoControlador: number | null
    Prioridad: string | null
    Certificado: string | null
    PuertoSSL: number | null
    PuertoNoSSL: number | null
    PuertoMantenimiento: number | null
    PuertoConexionSC: number | null
    PuertoConexionCC: number | null
    SOAP: string | null
    Socket: string | null
    API: string | null
    Sincroniza: string | null
    DireccionAIPV4: string | null
    DireccionBIPv4: string | null
    DireccionAIPV6: string | null
    DireccionBIPv6: string | null
    DireccionPublica1: string | null
    DireccionPublica2: string | null
    Localizacion: string | null
    Latitud: Decimal | null
    Longitud: Decimal | null
    Estatus: number | null
    FechaCreado: Date | null
    FechaDesactivado: Date | null
    _count: ControladoresCountAggregateOutputType | null
    _avg: ControladoresAvgAggregateOutputType | null
    _sum: ControladoresSumAggregateOutputType | null
    _min: ControladoresMinAggregateOutputType | null
    _max: ControladoresMaxAggregateOutputType | null
  }

  type GetControladoresGroupByPayload<T extends ControladoresGroupByArgs> = PrismaPromise<
    Array<
      PickArray<ControladoresGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ControladoresGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ControladoresGroupByOutputType[P]>
            : GetScalarType<T[P], ControladoresGroupByOutputType[P]>
        }
      >
    >


  export type controladoresSelect = {
    IDControlador?: boolean
    IDEdificio?: boolean
    NombreControlador?: boolean
    Descripcion?: boolean
    IDIcono?: boolean
    TipoControlador?: boolean
    Prioridad?: boolean
    Certificado?: boolean
    PuertoSSL?: boolean
    PuertoNoSSL?: boolean
    PuertoMantenimiento?: boolean
    PuertoConexionSC?: boolean
    PuertoConexionCC?: boolean
    SOAP?: boolean
    Socket?: boolean
    API?: boolean
    Sincroniza?: boolean
    DireccionAIPV4?: boolean
    DireccionBIPv4?: boolean
    DireccionAIPV6?: boolean
    DireccionBIPv6?: boolean
    DireccionPublica1?: boolean
    DireccionPublica2?: boolean
    Localizacion?: boolean
    Latitud?: boolean
    Longitud?: boolean
    Estatus?: boolean
    FechaCreado?: boolean
    FechaDesactivado?: boolean
  }


  export type controladoresGetPayload<S extends boolean | null | undefined | controladoresArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? controladores :
    S extends undefined ? never :
    S extends { include: any } & (controladoresArgs | controladoresFindManyArgs)
    ? controladores 
    : S extends { select: any } & (controladoresArgs | controladoresFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof controladores ? controladores[P] : never
  } 
      : controladores


  type controladoresCountArgs = Merge<
    Omit<controladoresFindManyArgs, 'select' | 'include'> & {
      select?: ControladoresCountAggregateInputType | true
    }
  >

  export interface controladoresDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Controladores that matches the filter.
     * @param {controladoresFindUniqueArgs} args - Arguments to find a Controladores
     * @example
     * // Get one Controladores
     * const controladores = await prisma.controladores.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends controladoresFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, controladoresFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'controladores'> extends True ? Prisma__controladoresClient<controladoresGetPayload<T>> : Prisma__controladoresClient<controladoresGetPayload<T> | null, null>

    /**
     * Find one Controladores that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {controladoresFindUniqueOrThrowArgs} args - Arguments to find a Controladores
     * @example
     * // Get one Controladores
     * const controladores = await prisma.controladores.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends controladoresFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, controladoresFindUniqueOrThrowArgs>
    ): Prisma__controladoresClient<controladoresGetPayload<T>>

    /**
     * Find the first Controladores that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {controladoresFindFirstArgs} args - Arguments to find a Controladores
     * @example
     * // Get one Controladores
     * const controladores = await prisma.controladores.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends controladoresFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, controladoresFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'controladores'> extends True ? Prisma__controladoresClient<controladoresGetPayload<T>> : Prisma__controladoresClient<controladoresGetPayload<T> | null, null>

    /**
     * Find the first Controladores that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {controladoresFindFirstOrThrowArgs} args - Arguments to find a Controladores
     * @example
     * // Get one Controladores
     * const controladores = await prisma.controladores.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends controladoresFindFirstOrThrowArgs>(
      args?: SelectSubset<T, controladoresFindFirstOrThrowArgs>
    ): Prisma__controladoresClient<controladoresGetPayload<T>>

    /**
     * Find zero or more Controladores that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {controladoresFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Controladores
     * const controladores = await prisma.controladores.findMany()
     * 
     * // Get first 10 Controladores
     * const controladores = await prisma.controladores.findMany({ take: 10 })
     * 
     * // Only select the `IDControlador`
     * const controladoresWithIDControladorOnly = await prisma.controladores.findMany({ select: { IDControlador: true } })
     * 
    **/
    findMany<T extends controladoresFindManyArgs>(
      args?: SelectSubset<T, controladoresFindManyArgs>
    ): PrismaPromise<Array<controladoresGetPayload<T>>>

    /**
     * Create a Controladores.
     * @param {controladoresCreateArgs} args - Arguments to create a Controladores.
     * @example
     * // Create one Controladores
     * const Controladores = await prisma.controladores.create({
     *   data: {
     *     // ... data to create a Controladores
     *   }
     * })
     * 
    **/
    create<T extends controladoresCreateArgs>(
      args: SelectSubset<T, controladoresCreateArgs>
    ): Prisma__controladoresClient<controladoresGetPayload<T>>

    /**
     * Create many Controladores.
     *     @param {controladoresCreateManyArgs} args - Arguments to create many Controladores.
     *     @example
     *     // Create many Controladores
     *     const controladores = await prisma.controladores.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends controladoresCreateManyArgs>(
      args?: SelectSubset<T, controladoresCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Controladores.
     * @param {controladoresDeleteArgs} args - Arguments to delete one Controladores.
     * @example
     * // Delete one Controladores
     * const Controladores = await prisma.controladores.delete({
     *   where: {
     *     // ... filter to delete one Controladores
     *   }
     * })
     * 
    **/
    delete<T extends controladoresDeleteArgs>(
      args: SelectSubset<T, controladoresDeleteArgs>
    ): Prisma__controladoresClient<controladoresGetPayload<T>>

    /**
     * Update one Controladores.
     * @param {controladoresUpdateArgs} args - Arguments to update one Controladores.
     * @example
     * // Update one Controladores
     * const controladores = await prisma.controladores.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends controladoresUpdateArgs>(
      args: SelectSubset<T, controladoresUpdateArgs>
    ): Prisma__controladoresClient<controladoresGetPayload<T>>

    /**
     * Delete zero or more Controladores.
     * @param {controladoresDeleteManyArgs} args - Arguments to filter Controladores to delete.
     * @example
     * // Delete a few Controladores
     * const { count } = await prisma.controladores.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends controladoresDeleteManyArgs>(
      args?: SelectSubset<T, controladoresDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Controladores.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {controladoresUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Controladores
     * const controladores = await prisma.controladores.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends controladoresUpdateManyArgs>(
      args: SelectSubset<T, controladoresUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Controladores.
     * @param {controladoresUpsertArgs} args - Arguments to update or create a Controladores.
     * @example
     * // Update or create a Controladores
     * const controladores = await prisma.controladores.upsert({
     *   create: {
     *     // ... data to create a Controladores
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Controladores we want to update
     *   }
     * })
    **/
    upsert<T extends controladoresUpsertArgs>(
      args: SelectSubset<T, controladoresUpsertArgs>
    ): Prisma__controladoresClient<controladoresGetPayload<T>>

    /**
     * Count the number of Controladores.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {controladoresCountArgs} args - Arguments to filter Controladores to count.
     * @example
     * // Count the number of Controladores
     * const count = await prisma.controladores.count({
     *   where: {
     *     // ... the filter for the Controladores we want to count
     *   }
     * })
    **/
    count<T extends controladoresCountArgs>(
      args?: Subset<T, controladoresCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ControladoresCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Controladores.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ControladoresAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ControladoresAggregateArgs>(args: Subset<T, ControladoresAggregateArgs>): PrismaPromise<GetControladoresAggregateType<T>>

    /**
     * Group by Controladores.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ControladoresGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ControladoresGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ControladoresGroupByArgs['orderBy'] }
        : { orderBy?: ControladoresGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ControladoresGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetControladoresGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for controladores.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__controladoresClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * controladores base type for findUnique actions
   */
  export type controladoresFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the controladores
     * 
    **/
    select?: controladoresSelect | null
    /**
     * Filter, which controladores to fetch.
     * 
    **/
    where: controladoresWhereUniqueInput
  }

  /**
   * controladores: findUnique
   */
  export interface controladoresFindUniqueArgs extends controladoresFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * controladores findUniqueOrThrow
   */
  export type controladoresFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the controladores
     * 
    **/
    select?: controladoresSelect | null
    /**
     * Filter, which controladores to fetch.
     * 
    **/
    where: controladoresWhereUniqueInput
  }


  /**
   * controladores base type for findFirst actions
   */
  export type controladoresFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the controladores
     * 
    **/
    select?: controladoresSelect | null
    /**
     * Filter, which controladores to fetch.
     * 
    **/
    where?: controladoresWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of controladores to fetch.
     * 
    **/
    orderBy?: Enumerable<controladoresOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for controladores.
     * 
    **/
    cursor?: controladoresWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` controladores from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` controladores.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of controladores.
     * 
    **/
    distinct?: Enumerable<ControladoresScalarFieldEnum>
  }

  /**
   * controladores: findFirst
   */
  export interface controladoresFindFirstArgs extends controladoresFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * controladores findFirstOrThrow
   */
  export type controladoresFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the controladores
     * 
    **/
    select?: controladoresSelect | null
    /**
     * Filter, which controladores to fetch.
     * 
    **/
    where?: controladoresWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of controladores to fetch.
     * 
    **/
    orderBy?: Enumerable<controladoresOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for controladores.
     * 
    **/
    cursor?: controladoresWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` controladores from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` controladores.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of controladores.
     * 
    **/
    distinct?: Enumerable<ControladoresScalarFieldEnum>
  }


  /**
   * controladores findMany
   */
  export type controladoresFindManyArgs = {
    /**
     * Select specific fields to fetch from the controladores
     * 
    **/
    select?: controladoresSelect | null
    /**
     * Filter, which controladores to fetch.
     * 
    **/
    where?: controladoresWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of controladores to fetch.
     * 
    **/
    orderBy?: Enumerable<controladoresOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing controladores.
     * 
    **/
    cursor?: controladoresWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` controladores from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` controladores.
     * 
    **/
    skip?: number
    distinct?: Enumerable<ControladoresScalarFieldEnum>
  }


  /**
   * controladores create
   */
  export type controladoresCreateArgs = {
    /**
     * Select specific fields to fetch from the controladores
     * 
    **/
    select?: controladoresSelect | null
    /**
     * The data needed to create a controladores.
     * 
    **/
    data: XOR<controladoresCreateInput, controladoresUncheckedCreateInput>
  }


  /**
   * controladores createMany
   */
  export type controladoresCreateManyArgs = {
    /**
     * The data used to create many controladores.
     * 
    **/
    data: Enumerable<controladoresCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * controladores update
   */
  export type controladoresUpdateArgs = {
    /**
     * Select specific fields to fetch from the controladores
     * 
    **/
    select?: controladoresSelect | null
    /**
     * The data needed to update a controladores.
     * 
    **/
    data: XOR<controladoresUpdateInput, controladoresUncheckedUpdateInput>
    /**
     * Choose, which controladores to update.
     * 
    **/
    where: controladoresWhereUniqueInput
  }


  /**
   * controladores updateMany
   */
  export type controladoresUpdateManyArgs = {
    /**
     * The data used to update controladores.
     * 
    **/
    data: XOR<controladoresUpdateManyMutationInput, controladoresUncheckedUpdateManyInput>
    /**
     * Filter which controladores to update
     * 
    **/
    where?: controladoresWhereInput
  }


  /**
   * controladores upsert
   */
  export type controladoresUpsertArgs = {
    /**
     * Select specific fields to fetch from the controladores
     * 
    **/
    select?: controladoresSelect | null
    /**
     * The filter to search for the controladores to update in case it exists.
     * 
    **/
    where: controladoresWhereUniqueInput
    /**
     * In case the controladores found by the `where` argument doesn't exist, create a new controladores with this data.
     * 
    **/
    create: XOR<controladoresCreateInput, controladoresUncheckedCreateInput>
    /**
     * In case the controladores was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<controladoresUpdateInput, controladoresUncheckedUpdateInput>
  }


  /**
   * controladores delete
   */
  export type controladoresDeleteArgs = {
    /**
     * Select specific fields to fetch from the controladores
     * 
    **/
    select?: controladoresSelect | null
    /**
     * Filter which controladores to delete.
     * 
    **/
    where: controladoresWhereUniqueInput
  }


  /**
   * controladores deleteMany
   */
  export type controladoresDeleteManyArgs = {
    /**
     * Filter which controladores to delete
     * 
    **/
    where?: controladoresWhereInput
  }


  /**
   * controladores without action
   */
  export type controladoresArgs = {
    /**
     * Select specific fields to fetch from the controladores
     * 
    **/
    select?: controladoresSelect | null
  }



  /**
   * Model dispositivos
   */


  export type AggregateDispositivos = {
    _count: DispositivosCountAggregateOutputType | null
    _avg: DispositivosAvgAggregateOutputType | null
    _sum: DispositivosSumAggregateOutputType | null
    _min: DispositivosMinAggregateOutputType | null
    _max: DispositivosMaxAggregateOutputType | null
  }

  export type DispositivosAvgAggregateOutputType = {
    IDDispositivo: number | null
    IDSubsistema: number | null
    IDTipoFamilia: number | null
    IDFamilia: number | null
    IDFabricante: number | null
    IDTipoDispositivo: number | null
    IDGateway: number | null
    IDControlador: number | null
    IDModelo: number | null
    IDEdificio: number | null
    IDZona: number | null
    IDPuerta: number | null
    IDIconografia: number | null
    IDMenuPropio: number | null
    Latitud: Decimal | null
    Longitud: Decimal | null
    IDTipoEvento: number | null
    IDModeloElemento: number | null
    PuertoSSL: number | null
    PuertoNoSSL: number | null
    PuertoMantenimiento: number | null
    PuertoConexionSC: number | null
    PuertoConexionCC: number | null
    IDManual: number | null
    Directo: number | null
  }

  export type DispositivosSumAggregateOutputType = {
    IDDispositivo: number | null
    IDSubsistema: number | null
    IDTipoFamilia: number | null
    IDFamilia: number | null
    IDFabricante: number | null
    IDTipoDispositivo: number | null
    IDGateway: number | null
    IDControlador: number | null
    IDModelo: number | null
    IDEdificio: number | null
    IDZona: number | null
    IDPuerta: number | null
    IDIconografia: number | null
    IDMenuPropio: number | null
    Latitud: Decimal | null
    Longitud: Decimal | null
    IDTipoEvento: number | null
    IDModeloElemento: number | null
    PuertoSSL: number | null
    PuertoNoSSL: number | null
    PuertoMantenimiento: number | null
    PuertoConexionSC: number | null
    PuertoConexionCC: number | null
    IDManual: number | null
    Directo: number | null
  }

  export type DispositivosMinAggregateOutputType = {
    IDDispositivo: number | null
    IDSubsistema: number | null
    IDTipoFamilia: number | null
    IDFamilia: number | null
    IDFabricante: number | null
    IDTipoDispositivo: number | null
    IDGateway: number | null
    IDControlador: number | null
    IDModelo: number | null
    IDEdificio: number | null
    IDZona: number | null
    IDPuerta: number | null
    NombreDispositivo: string | null
    Descripcion: string | null
    IDIconografia: number | null
    IDMenuPropio: number | null
    Estatus: string | null
    Sentidos: string | null
    Ignorado: string | null
    Enrolamiento: string | null
    Latitud: Decimal | null
    Longitud: Decimal | null
    DireccionGPS: string | null
    GeometriaGPS: string | null
    IDTipoEvento: number | null
    IDModeloElemento: number | null
    FechaCreacion: Date | null
    FechaDesactivacion: Date | null
    FechaEliminacion: Date | null
    Parametros: string | null
    Certificado: string | null
    PuertoSSL: number | null
    PuertoNoSSL: number | null
    PuertoMantenimiento: number | null
    PuertoConexionSC: number | null
    PuertoConexionCC: number | null
    SOAP: string | null
    Socket: string | null
    API: string | null
    Sincroniza: string | null
    DireccionAIPV4: string | null
    DireccionBIPv4: string | null
    DireccionAIPV6: string | null
    DireccionBIPv6: string | null
    DireccionPublica1: string | null
    DireccionPublica2: string | null
    Serial: string | null
    user: string | null
    password: string | null
    IDManual: number | null
    Directo: number | null
  }

  export type DispositivosMaxAggregateOutputType = {
    IDDispositivo: number | null
    IDSubsistema: number | null
    IDTipoFamilia: number | null
    IDFamilia: number | null
    IDFabricante: number | null
    IDTipoDispositivo: number | null
    IDGateway: number | null
    IDControlador: number | null
    IDModelo: number | null
    IDEdificio: number | null
    IDZona: number | null
    IDPuerta: number | null
    NombreDispositivo: string | null
    Descripcion: string | null
    IDIconografia: number | null
    IDMenuPropio: number | null
    Estatus: string | null
    Sentidos: string | null
    Ignorado: string | null
    Enrolamiento: string | null
    Latitud: Decimal | null
    Longitud: Decimal | null
    DireccionGPS: string | null
    GeometriaGPS: string | null
    IDTipoEvento: number | null
    IDModeloElemento: number | null
    FechaCreacion: Date | null
    FechaDesactivacion: Date | null
    FechaEliminacion: Date | null
    Parametros: string | null
    Certificado: string | null
    PuertoSSL: number | null
    PuertoNoSSL: number | null
    PuertoMantenimiento: number | null
    PuertoConexionSC: number | null
    PuertoConexionCC: number | null
    SOAP: string | null
    Socket: string | null
    API: string | null
    Sincroniza: string | null
    DireccionAIPV4: string | null
    DireccionBIPv4: string | null
    DireccionAIPV6: string | null
    DireccionBIPv6: string | null
    DireccionPublica1: string | null
    DireccionPublica2: string | null
    Serial: string | null
    user: string | null
    password: string | null
    IDManual: number | null
    Directo: number | null
  }

  export type DispositivosCountAggregateOutputType = {
    IDDispositivo: number
    IDSubsistema: number
    IDTipoFamilia: number
    IDFamilia: number
    IDFabricante: number
    IDTipoDispositivo: number
    IDGateway: number
    IDControlador: number
    IDModelo: number
    IDEdificio: number
    IDZona: number
    IDPuerta: number
    NombreDispositivo: number
    Descripcion: number
    IDIconografia: number
    IDMenuPropio: number
    Estatus: number
    Sentidos: number
    Ignorado: number
    Enrolamiento: number
    Latitud: number
    Longitud: number
    DireccionGPS: number
    GeometriaGPS: number
    IDTipoEvento: number
    IDModeloElemento: number
    FechaCreacion: number
    FechaDesactivacion: number
    FechaEliminacion: number
    Parametros: number
    Certificado: number
    PuertoSSL: number
    PuertoNoSSL: number
    PuertoMantenimiento: number
    PuertoConexionSC: number
    PuertoConexionCC: number
    SOAP: number
    Socket: number
    API: number
    Sincroniza: number
    DireccionAIPV4: number
    DireccionBIPv4: number
    DireccionAIPV6: number
    DireccionBIPv6: number
    DireccionPublica1: number
    DireccionPublica2: number
    Serial: number
    user: number
    password: number
    IDManual: number
    Directo: number
    _all: number
  }


  export type DispositivosAvgAggregateInputType = {
    IDDispositivo?: true
    IDSubsistema?: true
    IDTipoFamilia?: true
    IDFamilia?: true
    IDFabricante?: true
    IDTipoDispositivo?: true
    IDGateway?: true
    IDControlador?: true
    IDModelo?: true
    IDEdificio?: true
    IDZona?: true
    IDPuerta?: true
    IDIconografia?: true
    IDMenuPropio?: true
    Latitud?: true
    Longitud?: true
    IDTipoEvento?: true
    IDModeloElemento?: true
    PuertoSSL?: true
    PuertoNoSSL?: true
    PuertoMantenimiento?: true
    PuertoConexionSC?: true
    PuertoConexionCC?: true
    IDManual?: true
    Directo?: true
  }

  export type DispositivosSumAggregateInputType = {
    IDDispositivo?: true
    IDSubsistema?: true
    IDTipoFamilia?: true
    IDFamilia?: true
    IDFabricante?: true
    IDTipoDispositivo?: true
    IDGateway?: true
    IDControlador?: true
    IDModelo?: true
    IDEdificio?: true
    IDZona?: true
    IDPuerta?: true
    IDIconografia?: true
    IDMenuPropio?: true
    Latitud?: true
    Longitud?: true
    IDTipoEvento?: true
    IDModeloElemento?: true
    PuertoSSL?: true
    PuertoNoSSL?: true
    PuertoMantenimiento?: true
    PuertoConexionSC?: true
    PuertoConexionCC?: true
    IDManual?: true
    Directo?: true
  }

  export type DispositivosMinAggregateInputType = {
    IDDispositivo?: true
    IDSubsistema?: true
    IDTipoFamilia?: true
    IDFamilia?: true
    IDFabricante?: true
    IDTipoDispositivo?: true
    IDGateway?: true
    IDControlador?: true
    IDModelo?: true
    IDEdificio?: true
    IDZona?: true
    IDPuerta?: true
    NombreDispositivo?: true
    Descripcion?: true
    IDIconografia?: true
    IDMenuPropio?: true
    Estatus?: true
    Sentidos?: true
    Ignorado?: true
    Enrolamiento?: true
    Latitud?: true
    Longitud?: true
    DireccionGPS?: true
    GeometriaGPS?: true
    IDTipoEvento?: true
    IDModeloElemento?: true
    FechaCreacion?: true
    FechaDesactivacion?: true
    FechaEliminacion?: true
    Parametros?: true
    Certificado?: true
    PuertoSSL?: true
    PuertoNoSSL?: true
    PuertoMantenimiento?: true
    PuertoConexionSC?: true
    PuertoConexionCC?: true
    SOAP?: true
    Socket?: true
    API?: true
    Sincroniza?: true
    DireccionAIPV4?: true
    DireccionBIPv4?: true
    DireccionAIPV6?: true
    DireccionBIPv6?: true
    DireccionPublica1?: true
    DireccionPublica2?: true
    Serial?: true
    user?: true
    password?: true
    IDManual?: true
    Directo?: true
  }

  export type DispositivosMaxAggregateInputType = {
    IDDispositivo?: true
    IDSubsistema?: true
    IDTipoFamilia?: true
    IDFamilia?: true
    IDFabricante?: true
    IDTipoDispositivo?: true
    IDGateway?: true
    IDControlador?: true
    IDModelo?: true
    IDEdificio?: true
    IDZona?: true
    IDPuerta?: true
    NombreDispositivo?: true
    Descripcion?: true
    IDIconografia?: true
    IDMenuPropio?: true
    Estatus?: true
    Sentidos?: true
    Ignorado?: true
    Enrolamiento?: true
    Latitud?: true
    Longitud?: true
    DireccionGPS?: true
    GeometriaGPS?: true
    IDTipoEvento?: true
    IDModeloElemento?: true
    FechaCreacion?: true
    FechaDesactivacion?: true
    FechaEliminacion?: true
    Parametros?: true
    Certificado?: true
    PuertoSSL?: true
    PuertoNoSSL?: true
    PuertoMantenimiento?: true
    PuertoConexionSC?: true
    PuertoConexionCC?: true
    SOAP?: true
    Socket?: true
    API?: true
    Sincroniza?: true
    DireccionAIPV4?: true
    DireccionBIPv4?: true
    DireccionAIPV6?: true
    DireccionBIPv6?: true
    DireccionPublica1?: true
    DireccionPublica2?: true
    Serial?: true
    user?: true
    password?: true
    IDManual?: true
    Directo?: true
  }

  export type DispositivosCountAggregateInputType = {
    IDDispositivo?: true
    IDSubsistema?: true
    IDTipoFamilia?: true
    IDFamilia?: true
    IDFabricante?: true
    IDTipoDispositivo?: true
    IDGateway?: true
    IDControlador?: true
    IDModelo?: true
    IDEdificio?: true
    IDZona?: true
    IDPuerta?: true
    NombreDispositivo?: true
    Descripcion?: true
    IDIconografia?: true
    IDMenuPropio?: true
    Estatus?: true
    Sentidos?: true
    Ignorado?: true
    Enrolamiento?: true
    Latitud?: true
    Longitud?: true
    DireccionGPS?: true
    GeometriaGPS?: true
    IDTipoEvento?: true
    IDModeloElemento?: true
    FechaCreacion?: true
    FechaDesactivacion?: true
    FechaEliminacion?: true
    Parametros?: true
    Certificado?: true
    PuertoSSL?: true
    PuertoNoSSL?: true
    PuertoMantenimiento?: true
    PuertoConexionSC?: true
    PuertoConexionCC?: true
    SOAP?: true
    Socket?: true
    API?: true
    Sincroniza?: true
    DireccionAIPV4?: true
    DireccionBIPv4?: true
    DireccionAIPV6?: true
    DireccionBIPv6?: true
    DireccionPublica1?: true
    DireccionPublica2?: true
    Serial?: true
    user?: true
    password?: true
    IDManual?: true
    Directo?: true
    _all?: true
  }

  export type DispositivosAggregateArgs = {
    /**
     * Filter which dispositivos to aggregate.
     * 
    **/
    where?: dispositivosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of dispositivos to fetch.
     * 
    **/
    orderBy?: Enumerable<dispositivosOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: dispositivosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` dispositivos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` dispositivos.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned dispositivos
    **/
    _count?: true | DispositivosCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DispositivosAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DispositivosSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DispositivosMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DispositivosMaxAggregateInputType
  }

  export type GetDispositivosAggregateType<T extends DispositivosAggregateArgs> = {
        [P in keyof T & keyof AggregateDispositivos]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDispositivos[P]>
      : GetScalarType<T[P], AggregateDispositivos[P]>
  }




  export type DispositivosGroupByArgs = {
    where?: dispositivosWhereInput
    orderBy?: Enumerable<dispositivosOrderByWithAggregationInput>
    by: Array<DispositivosScalarFieldEnum>
    having?: dispositivosScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DispositivosCountAggregateInputType | true
    _avg?: DispositivosAvgAggregateInputType
    _sum?: DispositivosSumAggregateInputType
    _min?: DispositivosMinAggregateInputType
    _max?: DispositivosMaxAggregateInputType
  }


  export type DispositivosGroupByOutputType = {
    IDDispositivo: number
    IDSubsistema: number | null
    IDTipoFamilia: number | null
    IDFamilia: number | null
    IDFabricante: number | null
    IDTipoDispositivo: number | null
    IDGateway: number | null
    IDControlador: number | null
    IDModelo: number | null
    IDEdificio: number | null
    IDZona: number | null
    IDPuerta: number | null
    NombreDispositivo: string | null
    Descripcion: string | null
    IDIconografia: number | null
    IDMenuPropio: number | null
    Estatus: string | null
    Sentidos: string | null
    Ignorado: string | null
    Enrolamiento: string | null
    Latitud: Decimal | null
    Longitud: Decimal | null
    DireccionGPS: string | null
    GeometriaGPS: string | null
    IDTipoEvento: number | null
    IDModeloElemento: number | null
    FechaCreacion: Date | null
    FechaDesactivacion: Date | null
    FechaEliminacion: Date | null
    Parametros: string | null
    Certificado: string | null
    PuertoSSL: number | null
    PuertoNoSSL: number | null
    PuertoMantenimiento: number | null
    PuertoConexionSC: number | null
    PuertoConexionCC: number | null
    SOAP: string | null
    Socket: string | null
    API: string | null
    Sincroniza: string | null
    DireccionAIPV4: string | null
    DireccionBIPv4: string | null
    DireccionAIPV6: string | null
    DireccionBIPv6: string | null
    DireccionPublica1: string | null
    DireccionPublica2: string | null
    Serial: string | null
    user: string | null
    password: string | null
    IDManual: number | null
    Directo: number | null
    _count: DispositivosCountAggregateOutputType | null
    _avg: DispositivosAvgAggregateOutputType | null
    _sum: DispositivosSumAggregateOutputType | null
    _min: DispositivosMinAggregateOutputType | null
    _max: DispositivosMaxAggregateOutputType | null
  }

  type GetDispositivosGroupByPayload<T extends DispositivosGroupByArgs> = PrismaPromise<
    Array<
      PickArray<DispositivosGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DispositivosGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DispositivosGroupByOutputType[P]>
            : GetScalarType<T[P], DispositivosGroupByOutputType[P]>
        }
      >
    >


  export type dispositivosSelect = {
    IDDispositivo?: boolean
    IDSubsistema?: boolean
    IDTipoFamilia?: boolean
    IDFamilia?: boolean
    IDFabricante?: boolean
    IDTipoDispositivo?: boolean
    IDGateway?: boolean
    IDControlador?: boolean
    IDModelo?: boolean
    IDEdificio?: boolean
    IDZona?: boolean
    IDPuerta?: boolean
    NombreDispositivo?: boolean
    Descripcion?: boolean
    IDIconografia?: boolean
    IDMenuPropio?: boolean
    Estatus?: boolean
    Sentidos?: boolean
    Ignorado?: boolean
    Enrolamiento?: boolean
    Latitud?: boolean
    Longitud?: boolean
    DireccionGPS?: boolean
    GeometriaGPS?: boolean
    IDTipoEvento?: boolean
    IDModeloElemento?: boolean
    FechaCreacion?: boolean
    FechaDesactivacion?: boolean
    FechaEliminacion?: boolean
    Parametros?: boolean
    Certificado?: boolean
    PuertoSSL?: boolean
    PuertoNoSSL?: boolean
    PuertoMantenimiento?: boolean
    PuertoConexionSC?: boolean
    PuertoConexionCC?: boolean
    SOAP?: boolean
    Socket?: boolean
    API?: boolean
    Sincroniza?: boolean
    DireccionAIPV4?: boolean
    DireccionBIPv4?: boolean
    DireccionAIPV6?: boolean
    DireccionBIPv6?: boolean
    DireccionPublica1?: boolean
    DireccionPublica2?: boolean
    Serial?: boolean
    user?: boolean
    password?: boolean
    IDManual?: boolean
    Directo?: boolean
  }


  export type dispositivosGetPayload<S extends boolean | null | undefined | dispositivosArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? dispositivos :
    S extends undefined ? never :
    S extends { include: any } & (dispositivosArgs | dispositivosFindManyArgs)
    ? dispositivos 
    : S extends { select: any } & (dispositivosArgs | dispositivosFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof dispositivos ? dispositivos[P] : never
  } 
      : dispositivos


  type dispositivosCountArgs = Merge<
    Omit<dispositivosFindManyArgs, 'select' | 'include'> & {
      select?: DispositivosCountAggregateInputType | true
    }
  >

  export interface dispositivosDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Dispositivos that matches the filter.
     * @param {dispositivosFindUniqueArgs} args - Arguments to find a Dispositivos
     * @example
     * // Get one Dispositivos
     * const dispositivos = await prisma.dispositivos.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends dispositivosFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, dispositivosFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'dispositivos'> extends True ? Prisma__dispositivosClient<dispositivosGetPayload<T>> : Prisma__dispositivosClient<dispositivosGetPayload<T> | null, null>

    /**
     * Find one Dispositivos that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {dispositivosFindUniqueOrThrowArgs} args - Arguments to find a Dispositivos
     * @example
     * // Get one Dispositivos
     * const dispositivos = await prisma.dispositivos.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends dispositivosFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, dispositivosFindUniqueOrThrowArgs>
    ): Prisma__dispositivosClient<dispositivosGetPayload<T>>

    /**
     * Find the first Dispositivos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {dispositivosFindFirstArgs} args - Arguments to find a Dispositivos
     * @example
     * // Get one Dispositivos
     * const dispositivos = await prisma.dispositivos.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends dispositivosFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, dispositivosFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'dispositivos'> extends True ? Prisma__dispositivosClient<dispositivosGetPayload<T>> : Prisma__dispositivosClient<dispositivosGetPayload<T> | null, null>

    /**
     * Find the first Dispositivos that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {dispositivosFindFirstOrThrowArgs} args - Arguments to find a Dispositivos
     * @example
     * // Get one Dispositivos
     * const dispositivos = await prisma.dispositivos.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends dispositivosFindFirstOrThrowArgs>(
      args?: SelectSubset<T, dispositivosFindFirstOrThrowArgs>
    ): Prisma__dispositivosClient<dispositivosGetPayload<T>>

    /**
     * Find zero or more Dispositivos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {dispositivosFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Dispositivos
     * const dispositivos = await prisma.dispositivos.findMany()
     * 
     * // Get first 10 Dispositivos
     * const dispositivos = await prisma.dispositivos.findMany({ take: 10 })
     * 
     * // Only select the `IDDispositivo`
     * const dispositivosWithIDDispositivoOnly = await prisma.dispositivos.findMany({ select: { IDDispositivo: true } })
     * 
    **/
    findMany<T extends dispositivosFindManyArgs>(
      args?: SelectSubset<T, dispositivosFindManyArgs>
    ): PrismaPromise<Array<dispositivosGetPayload<T>>>

    /**
     * Create a Dispositivos.
     * @param {dispositivosCreateArgs} args - Arguments to create a Dispositivos.
     * @example
     * // Create one Dispositivos
     * const Dispositivos = await prisma.dispositivos.create({
     *   data: {
     *     // ... data to create a Dispositivos
     *   }
     * })
     * 
    **/
    create<T extends dispositivosCreateArgs>(
      args: SelectSubset<T, dispositivosCreateArgs>
    ): Prisma__dispositivosClient<dispositivosGetPayload<T>>

    /**
     * Create many Dispositivos.
     *     @param {dispositivosCreateManyArgs} args - Arguments to create many Dispositivos.
     *     @example
     *     // Create many Dispositivos
     *     const dispositivos = await prisma.dispositivos.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends dispositivosCreateManyArgs>(
      args?: SelectSubset<T, dispositivosCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Dispositivos.
     * @param {dispositivosDeleteArgs} args - Arguments to delete one Dispositivos.
     * @example
     * // Delete one Dispositivos
     * const Dispositivos = await prisma.dispositivos.delete({
     *   where: {
     *     // ... filter to delete one Dispositivos
     *   }
     * })
     * 
    **/
    delete<T extends dispositivosDeleteArgs>(
      args: SelectSubset<T, dispositivosDeleteArgs>
    ): Prisma__dispositivosClient<dispositivosGetPayload<T>>

    /**
     * Update one Dispositivos.
     * @param {dispositivosUpdateArgs} args - Arguments to update one Dispositivos.
     * @example
     * // Update one Dispositivos
     * const dispositivos = await prisma.dispositivos.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends dispositivosUpdateArgs>(
      args: SelectSubset<T, dispositivosUpdateArgs>
    ): Prisma__dispositivosClient<dispositivosGetPayload<T>>

    /**
     * Delete zero or more Dispositivos.
     * @param {dispositivosDeleteManyArgs} args - Arguments to filter Dispositivos to delete.
     * @example
     * // Delete a few Dispositivos
     * const { count } = await prisma.dispositivos.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends dispositivosDeleteManyArgs>(
      args?: SelectSubset<T, dispositivosDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Dispositivos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {dispositivosUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Dispositivos
     * const dispositivos = await prisma.dispositivos.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends dispositivosUpdateManyArgs>(
      args: SelectSubset<T, dispositivosUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Dispositivos.
     * @param {dispositivosUpsertArgs} args - Arguments to update or create a Dispositivos.
     * @example
     * // Update or create a Dispositivos
     * const dispositivos = await prisma.dispositivos.upsert({
     *   create: {
     *     // ... data to create a Dispositivos
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Dispositivos we want to update
     *   }
     * })
    **/
    upsert<T extends dispositivosUpsertArgs>(
      args: SelectSubset<T, dispositivosUpsertArgs>
    ): Prisma__dispositivosClient<dispositivosGetPayload<T>>

    /**
     * Count the number of Dispositivos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {dispositivosCountArgs} args - Arguments to filter Dispositivos to count.
     * @example
     * // Count the number of Dispositivos
     * const count = await prisma.dispositivos.count({
     *   where: {
     *     // ... the filter for the Dispositivos we want to count
     *   }
     * })
    **/
    count<T extends dispositivosCountArgs>(
      args?: Subset<T, dispositivosCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DispositivosCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Dispositivos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DispositivosAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DispositivosAggregateArgs>(args: Subset<T, DispositivosAggregateArgs>): PrismaPromise<GetDispositivosAggregateType<T>>

    /**
     * Group by Dispositivos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DispositivosGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DispositivosGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DispositivosGroupByArgs['orderBy'] }
        : { orderBy?: DispositivosGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DispositivosGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDispositivosGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for dispositivos.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__dispositivosClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * dispositivos base type for findUnique actions
   */
  export type dispositivosFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the dispositivos
     * 
    **/
    select?: dispositivosSelect | null
    /**
     * Filter, which dispositivos to fetch.
     * 
    **/
    where: dispositivosWhereUniqueInput
  }

  /**
   * dispositivos: findUnique
   */
  export interface dispositivosFindUniqueArgs extends dispositivosFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * dispositivos findUniqueOrThrow
   */
  export type dispositivosFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the dispositivos
     * 
    **/
    select?: dispositivosSelect | null
    /**
     * Filter, which dispositivos to fetch.
     * 
    **/
    where: dispositivosWhereUniqueInput
  }


  /**
   * dispositivos base type for findFirst actions
   */
  export type dispositivosFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the dispositivos
     * 
    **/
    select?: dispositivosSelect | null
    /**
     * Filter, which dispositivos to fetch.
     * 
    **/
    where?: dispositivosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of dispositivos to fetch.
     * 
    **/
    orderBy?: Enumerable<dispositivosOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for dispositivos.
     * 
    **/
    cursor?: dispositivosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` dispositivos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` dispositivos.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of dispositivos.
     * 
    **/
    distinct?: Enumerable<DispositivosScalarFieldEnum>
  }

  /**
   * dispositivos: findFirst
   */
  export interface dispositivosFindFirstArgs extends dispositivosFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * dispositivos findFirstOrThrow
   */
  export type dispositivosFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the dispositivos
     * 
    **/
    select?: dispositivosSelect | null
    /**
     * Filter, which dispositivos to fetch.
     * 
    **/
    where?: dispositivosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of dispositivos to fetch.
     * 
    **/
    orderBy?: Enumerable<dispositivosOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for dispositivos.
     * 
    **/
    cursor?: dispositivosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` dispositivos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` dispositivos.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of dispositivos.
     * 
    **/
    distinct?: Enumerable<DispositivosScalarFieldEnum>
  }


  /**
   * dispositivos findMany
   */
  export type dispositivosFindManyArgs = {
    /**
     * Select specific fields to fetch from the dispositivos
     * 
    **/
    select?: dispositivosSelect | null
    /**
     * Filter, which dispositivos to fetch.
     * 
    **/
    where?: dispositivosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of dispositivos to fetch.
     * 
    **/
    orderBy?: Enumerable<dispositivosOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing dispositivos.
     * 
    **/
    cursor?: dispositivosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` dispositivos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` dispositivos.
     * 
    **/
    skip?: number
    distinct?: Enumerable<DispositivosScalarFieldEnum>
  }


  /**
   * dispositivos create
   */
  export type dispositivosCreateArgs = {
    /**
     * Select specific fields to fetch from the dispositivos
     * 
    **/
    select?: dispositivosSelect | null
    /**
     * The data needed to create a dispositivos.
     * 
    **/
    data: XOR<dispositivosCreateInput, dispositivosUncheckedCreateInput>
  }


  /**
   * dispositivos createMany
   */
  export type dispositivosCreateManyArgs = {
    /**
     * The data used to create many dispositivos.
     * 
    **/
    data: Enumerable<dispositivosCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * dispositivos update
   */
  export type dispositivosUpdateArgs = {
    /**
     * Select specific fields to fetch from the dispositivos
     * 
    **/
    select?: dispositivosSelect | null
    /**
     * The data needed to update a dispositivos.
     * 
    **/
    data: XOR<dispositivosUpdateInput, dispositivosUncheckedUpdateInput>
    /**
     * Choose, which dispositivos to update.
     * 
    **/
    where: dispositivosWhereUniqueInput
  }


  /**
   * dispositivos updateMany
   */
  export type dispositivosUpdateManyArgs = {
    /**
     * The data used to update dispositivos.
     * 
    **/
    data: XOR<dispositivosUpdateManyMutationInput, dispositivosUncheckedUpdateManyInput>
    /**
     * Filter which dispositivos to update
     * 
    **/
    where?: dispositivosWhereInput
  }


  /**
   * dispositivos upsert
   */
  export type dispositivosUpsertArgs = {
    /**
     * Select specific fields to fetch from the dispositivos
     * 
    **/
    select?: dispositivosSelect | null
    /**
     * The filter to search for the dispositivos to update in case it exists.
     * 
    **/
    where: dispositivosWhereUniqueInput
    /**
     * In case the dispositivos found by the `where` argument doesn't exist, create a new dispositivos with this data.
     * 
    **/
    create: XOR<dispositivosCreateInput, dispositivosUncheckedCreateInput>
    /**
     * In case the dispositivos was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<dispositivosUpdateInput, dispositivosUncheckedUpdateInput>
  }


  /**
   * dispositivos delete
   */
  export type dispositivosDeleteArgs = {
    /**
     * Select specific fields to fetch from the dispositivos
     * 
    **/
    select?: dispositivosSelect | null
    /**
     * Filter which dispositivos to delete.
     * 
    **/
    where: dispositivosWhereUniqueInput
  }


  /**
   * dispositivos deleteMany
   */
  export type dispositivosDeleteManyArgs = {
    /**
     * Filter which dispositivos to delete
     * 
    **/
    where?: dispositivosWhereInput
  }


  /**
   * dispositivos without action
   */
  export type dispositivosArgs = {
    /**
     * Select specific fields to fetch from the dispositivos
     * 
    **/
    select?: dispositivosSelect | null
  }



  /**
   * Model gateway
   */


  export type AggregateGateway = {
    _count: GatewayCountAggregateOutputType | null
    _avg: GatewayAvgAggregateOutputType | null
    _sum: GatewaySumAggregateOutputType | null
    _min: GatewayMinAggregateOutputType | null
    _max: GatewayMaxAggregateOutputType | null
  }

  export type GatewayAvgAggregateOutputType = {
    IDGateway: number | null
    IDTipoGateway: number | null
    IDControlador: number | null
    IDEdificio: number | null
    IDTipoEvento: number | null
    IDGrupoMetodo: number | null
    IDIcono: number | null
    Latitud: Decimal | null
    Longitud: Decimal | null
    PuertoSSL: number | null
    PuertoNoSSL: number | null
    PuertoMantenimiento: number | null
    PuertoConexionSC: number | null
    PuertoConexionCC: number | null
    IDManual: number | null
    IDZona: number | null
  }

  export type GatewaySumAggregateOutputType = {
    IDGateway: number | null
    IDTipoGateway: number | null
    IDControlador: number | null
    IDEdificio: number | null
    IDTipoEvento: number | null
    IDGrupoMetodo: number | null
    IDIcono: number | null
    Latitud: Decimal | null
    Longitud: Decimal | null
    PuertoSSL: number | null
    PuertoNoSSL: number | null
    PuertoMantenimiento: number | null
    PuertoConexionSC: number | null
    PuertoConexionCC: number | null
    IDManual: number | null
    IDZona: number | null
  }

  export type GatewayMinAggregateOutputType = {
    IDGateway: number | null
    IDTipoGateway: number | null
    IDControlador: number | null
    IDEdificio: number | null
    IDIdentificadorExterno: string | null
    IDTipoEvento: number | null
    IDGrupoMetodo: number | null
    NAbonado: string | null
    NombreGateway: string | null
    Descripcion: string | null
    IDIcono: number | null
    ValorEstado: Buffer | null
    Parametros: string | null
    EstadoOnOff: string | null
    Latitud: Decimal | null
    Longitud: Decimal | null
    SerialGPS: string | null
    GeometriaGPS: string | null
    FechaCreado: Date | null
    FechaDesactivado: Date | null
    Certificado: string | null
    PuertoSSL: number | null
    PuertoNoSSL: number | null
    PuertoMantenimiento: number | null
    PuertoConexionSC: number | null
    PuertoConexionCC: number | null
    SOAP: string | null
    Socket: string | null
    API: string | null
    Sincroniza: string | null
    DireccionAIPV4: string | null
    DireccionBIPv4: string | null
    DireccionAIPV6: string | null
    DireccionBIPv6: string | null
    DireccionPublica1: string | null
    DireccionPublica2: string | null
    user: string | null
    password: string | null
    Serial: string | null
    IDManual: number | null
    IDZona: number | null
  }

  export type GatewayMaxAggregateOutputType = {
    IDGateway: number | null
    IDTipoGateway: number | null
    IDControlador: number | null
    IDEdificio: number | null
    IDIdentificadorExterno: string | null
    IDTipoEvento: number | null
    IDGrupoMetodo: number | null
    NAbonado: string | null
    NombreGateway: string | null
    Descripcion: string | null
    IDIcono: number | null
    ValorEstado: Buffer | null
    Parametros: string | null
    EstadoOnOff: string | null
    Latitud: Decimal | null
    Longitud: Decimal | null
    SerialGPS: string | null
    GeometriaGPS: string | null
    FechaCreado: Date | null
    FechaDesactivado: Date | null
    Certificado: string | null
    PuertoSSL: number | null
    PuertoNoSSL: number | null
    PuertoMantenimiento: number | null
    PuertoConexionSC: number | null
    PuertoConexionCC: number | null
    SOAP: string | null
    Socket: string | null
    API: string | null
    Sincroniza: string | null
    DireccionAIPV4: string | null
    DireccionBIPv4: string | null
    DireccionAIPV6: string | null
    DireccionBIPv6: string | null
    DireccionPublica1: string | null
    DireccionPublica2: string | null
    user: string | null
    password: string | null
    Serial: string | null
    IDManual: number | null
    IDZona: number | null
  }

  export type GatewayCountAggregateOutputType = {
    IDGateway: number
    IDTipoGateway: number
    IDControlador: number
    IDEdificio: number
    IDIdentificadorExterno: number
    IDTipoEvento: number
    IDGrupoMetodo: number
    NAbonado: number
    NombreGateway: number
    Descripcion: number
    IDIcono: number
    ValorEstado: number
    Parametros: number
    EstadoOnOff: number
    Latitud: number
    Longitud: number
    SerialGPS: number
    GeometriaGPS: number
    FechaCreado: number
    FechaDesactivado: number
    Certificado: number
    PuertoSSL: number
    PuertoNoSSL: number
    PuertoMantenimiento: number
    PuertoConexionSC: number
    PuertoConexionCC: number
    SOAP: number
    Socket: number
    API: number
    Sincroniza: number
    DireccionAIPV4: number
    DireccionBIPv4: number
    DireccionAIPV6: number
    DireccionBIPv6: number
    DireccionPublica1: number
    DireccionPublica2: number
    user: number
    password: number
    Serial: number
    IDManual: number
    IDZona: number
    _all: number
  }


  export type GatewayAvgAggregateInputType = {
    IDGateway?: true
    IDTipoGateway?: true
    IDControlador?: true
    IDEdificio?: true
    IDTipoEvento?: true
    IDGrupoMetodo?: true
    IDIcono?: true
    Latitud?: true
    Longitud?: true
    PuertoSSL?: true
    PuertoNoSSL?: true
    PuertoMantenimiento?: true
    PuertoConexionSC?: true
    PuertoConexionCC?: true
    IDManual?: true
    IDZona?: true
  }

  export type GatewaySumAggregateInputType = {
    IDGateway?: true
    IDTipoGateway?: true
    IDControlador?: true
    IDEdificio?: true
    IDTipoEvento?: true
    IDGrupoMetodo?: true
    IDIcono?: true
    Latitud?: true
    Longitud?: true
    PuertoSSL?: true
    PuertoNoSSL?: true
    PuertoMantenimiento?: true
    PuertoConexionSC?: true
    PuertoConexionCC?: true
    IDManual?: true
    IDZona?: true
  }

  export type GatewayMinAggregateInputType = {
    IDGateway?: true
    IDTipoGateway?: true
    IDControlador?: true
    IDEdificio?: true
    IDIdentificadorExterno?: true
    IDTipoEvento?: true
    IDGrupoMetodo?: true
    NAbonado?: true
    NombreGateway?: true
    Descripcion?: true
    IDIcono?: true
    ValorEstado?: true
    Parametros?: true
    EstadoOnOff?: true
    Latitud?: true
    Longitud?: true
    SerialGPS?: true
    GeometriaGPS?: true
    FechaCreado?: true
    FechaDesactivado?: true
    Certificado?: true
    PuertoSSL?: true
    PuertoNoSSL?: true
    PuertoMantenimiento?: true
    PuertoConexionSC?: true
    PuertoConexionCC?: true
    SOAP?: true
    Socket?: true
    API?: true
    Sincroniza?: true
    DireccionAIPV4?: true
    DireccionBIPv4?: true
    DireccionAIPV6?: true
    DireccionBIPv6?: true
    DireccionPublica1?: true
    DireccionPublica2?: true
    user?: true
    password?: true
    Serial?: true
    IDManual?: true
    IDZona?: true
  }

  export type GatewayMaxAggregateInputType = {
    IDGateway?: true
    IDTipoGateway?: true
    IDControlador?: true
    IDEdificio?: true
    IDIdentificadorExterno?: true
    IDTipoEvento?: true
    IDGrupoMetodo?: true
    NAbonado?: true
    NombreGateway?: true
    Descripcion?: true
    IDIcono?: true
    ValorEstado?: true
    Parametros?: true
    EstadoOnOff?: true
    Latitud?: true
    Longitud?: true
    SerialGPS?: true
    GeometriaGPS?: true
    FechaCreado?: true
    FechaDesactivado?: true
    Certificado?: true
    PuertoSSL?: true
    PuertoNoSSL?: true
    PuertoMantenimiento?: true
    PuertoConexionSC?: true
    PuertoConexionCC?: true
    SOAP?: true
    Socket?: true
    API?: true
    Sincroniza?: true
    DireccionAIPV4?: true
    DireccionBIPv4?: true
    DireccionAIPV6?: true
    DireccionBIPv6?: true
    DireccionPublica1?: true
    DireccionPublica2?: true
    user?: true
    password?: true
    Serial?: true
    IDManual?: true
    IDZona?: true
  }

  export type GatewayCountAggregateInputType = {
    IDGateway?: true
    IDTipoGateway?: true
    IDControlador?: true
    IDEdificio?: true
    IDIdentificadorExterno?: true
    IDTipoEvento?: true
    IDGrupoMetodo?: true
    NAbonado?: true
    NombreGateway?: true
    Descripcion?: true
    IDIcono?: true
    ValorEstado?: true
    Parametros?: true
    EstadoOnOff?: true
    Latitud?: true
    Longitud?: true
    SerialGPS?: true
    GeometriaGPS?: true
    FechaCreado?: true
    FechaDesactivado?: true
    Certificado?: true
    PuertoSSL?: true
    PuertoNoSSL?: true
    PuertoMantenimiento?: true
    PuertoConexionSC?: true
    PuertoConexionCC?: true
    SOAP?: true
    Socket?: true
    API?: true
    Sincroniza?: true
    DireccionAIPV4?: true
    DireccionBIPv4?: true
    DireccionAIPV6?: true
    DireccionBIPv6?: true
    DireccionPublica1?: true
    DireccionPublica2?: true
    user?: true
    password?: true
    Serial?: true
    IDManual?: true
    IDZona?: true
    _all?: true
  }

  export type GatewayAggregateArgs = {
    /**
     * Filter which gateway to aggregate.
     * 
    **/
    where?: gatewayWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of gateways to fetch.
     * 
    **/
    orderBy?: Enumerable<gatewayOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: gatewayWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` gateways from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` gateways.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned gateways
    **/
    _count?: true | GatewayCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GatewayAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GatewaySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GatewayMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GatewayMaxAggregateInputType
  }

  export type GetGatewayAggregateType<T extends GatewayAggregateArgs> = {
        [P in keyof T & keyof AggregateGateway]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGateway[P]>
      : GetScalarType<T[P], AggregateGateway[P]>
  }




  export type GatewayGroupByArgs = {
    where?: gatewayWhereInput
    orderBy?: Enumerable<gatewayOrderByWithAggregationInput>
    by: Array<GatewayScalarFieldEnum>
    having?: gatewayScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GatewayCountAggregateInputType | true
    _avg?: GatewayAvgAggregateInputType
    _sum?: GatewaySumAggregateInputType
    _min?: GatewayMinAggregateInputType
    _max?: GatewayMaxAggregateInputType
  }


  export type GatewayGroupByOutputType = {
    IDGateway: number
    IDTipoGateway: number | null
    IDControlador: number | null
    IDEdificio: number | null
    IDIdentificadorExterno: string | null
    IDTipoEvento: number | null
    IDGrupoMetodo: number | null
    NAbonado: string | null
    NombreGateway: string | null
    Descripcion: string | null
    IDIcono: number | null
    ValorEstado: Buffer | null
    Parametros: string | null
    EstadoOnOff: string | null
    Latitud: Decimal | null
    Longitud: Decimal | null
    SerialGPS: string | null
    GeometriaGPS: string | null
    FechaCreado: Date | null
    FechaDesactivado: Date | null
    Certificado: string | null
    PuertoSSL: number | null
    PuertoNoSSL: number | null
    PuertoMantenimiento: number | null
    PuertoConexionSC: number | null
    PuertoConexionCC: number | null
    SOAP: string | null
    Socket: string | null
    API: string | null
    Sincroniza: string | null
    DireccionAIPV4: string | null
    DireccionBIPv4: string | null
    DireccionAIPV6: string | null
    DireccionBIPv6: string | null
    DireccionPublica1: string | null
    DireccionPublica2: string | null
    user: string | null
    password: string | null
    Serial: string | null
    IDManual: number | null
    IDZona: number | null
    _count: GatewayCountAggregateOutputType | null
    _avg: GatewayAvgAggregateOutputType | null
    _sum: GatewaySumAggregateOutputType | null
    _min: GatewayMinAggregateOutputType | null
    _max: GatewayMaxAggregateOutputType | null
  }

  type GetGatewayGroupByPayload<T extends GatewayGroupByArgs> = PrismaPromise<
    Array<
      PickArray<GatewayGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GatewayGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GatewayGroupByOutputType[P]>
            : GetScalarType<T[P], GatewayGroupByOutputType[P]>
        }
      >
    >


  export type gatewaySelect = {
    IDGateway?: boolean
    IDTipoGateway?: boolean
    IDControlador?: boolean
    IDEdificio?: boolean
    IDIdentificadorExterno?: boolean
    IDTipoEvento?: boolean
    IDGrupoMetodo?: boolean
    NAbonado?: boolean
    NombreGateway?: boolean
    Descripcion?: boolean
    IDIcono?: boolean
    ValorEstado?: boolean
    Parametros?: boolean
    EstadoOnOff?: boolean
    Latitud?: boolean
    Longitud?: boolean
    SerialGPS?: boolean
    GeometriaGPS?: boolean
    FechaCreado?: boolean
    FechaDesactivado?: boolean
    Certificado?: boolean
    PuertoSSL?: boolean
    PuertoNoSSL?: boolean
    PuertoMantenimiento?: boolean
    PuertoConexionSC?: boolean
    PuertoConexionCC?: boolean
    SOAP?: boolean
    Socket?: boolean
    API?: boolean
    Sincroniza?: boolean
    DireccionAIPV4?: boolean
    DireccionBIPv4?: boolean
    DireccionAIPV6?: boolean
    DireccionBIPv6?: boolean
    DireccionPublica1?: boolean
    DireccionPublica2?: boolean
    user?: boolean
    password?: boolean
    Serial?: boolean
    IDManual?: boolean
    IDZona?: boolean
  }


  export type gatewayGetPayload<S extends boolean | null | undefined | gatewayArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? gateway :
    S extends undefined ? never :
    S extends { include: any } & (gatewayArgs | gatewayFindManyArgs)
    ? gateway 
    : S extends { select: any } & (gatewayArgs | gatewayFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof gateway ? gateway[P] : never
  } 
      : gateway


  type gatewayCountArgs = Merge<
    Omit<gatewayFindManyArgs, 'select' | 'include'> & {
      select?: GatewayCountAggregateInputType | true
    }
  >

  export interface gatewayDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Gateway that matches the filter.
     * @param {gatewayFindUniqueArgs} args - Arguments to find a Gateway
     * @example
     * // Get one Gateway
     * const gateway = await prisma.gateway.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends gatewayFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, gatewayFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'gateway'> extends True ? Prisma__gatewayClient<gatewayGetPayload<T>> : Prisma__gatewayClient<gatewayGetPayload<T> | null, null>

    /**
     * Find one Gateway that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {gatewayFindUniqueOrThrowArgs} args - Arguments to find a Gateway
     * @example
     * // Get one Gateway
     * const gateway = await prisma.gateway.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends gatewayFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, gatewayFindUniqueOrThrowArgs>
    ): Prisma__gatewayClient<gatewayGetPayload<T>>

    /**
     * Find the first Gateway that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {gatewayFindFirstArgs} args - Arguments to find a Gateway
     * @example
     * // Get one Gateway
     * const gateway = await prisma.gateway.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends gatewayFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, gatewayFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'gateway'> extends True ? Prisma__gatewayClient<gatewayGetPayload<T>> : Prisma__gatewayClient<gatewayGetPayload<T> | null, null>

    /**
     * Find the first Gateway that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {gatewayFindFirstOrThrowArgs} args - Arguments to find a Gateway
     * @example
     * // Get one Gateway
     * const gateway = await prisma.gateway.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends gatewayFindFirstOrThrowArgs>(
      args?: SelectSubset<T, gatewayFindFirstOrThrowArgs>
    ): Prisma__gatewayClient<gatewayGetPayload<T>>

    /**
     * Find zero or more Gateways that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {gatewayFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Gateways
     * const gateways = await prisma.gateway.findMany()
     * 
     * // Get first 10 Gateways
     * const gateways = await prisma.gateway.findMany({ take: 10 })
     * 
     * // Only select the `IDGateway`
     * const gatewayWithIDGatewayOnly = await prisma.gateway.findMany({ select: { IDGateway: true } })
     * 
    **/
    findMany<T extends gatewayFindManyArgs>(
      args?: SelectSubset<T, gatewayFindManyArgs>
    ): PrismaPromise<Array<gatewayGetPayload<T>>>

    /**
     * Create a Gateway.
     * @param {gatewayCreateArgs} args - Arguments to create a Gateway.
     * @example
     * // Create one Gateway
     * const Gateway = await prisma.gateway.create({
     *   data: {
     *     // ... data to create a Gateway
     *   }
     * })
     * 
    **/
    create<T extends gatewayCreateArgs>(
      args: SelectSubset<T, gatewayCreateArgs>
    ): Prisma__gatewayClient<gatewayGetPayload<T>>

    /**
     * Create many Gateways.
     *     @param {gatewayCreateManyArgs} args - Arguments to create many Gateways.
     *     @example
     *     // Create many Gateways
     *     const gateway = await prisma.gateway.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends gatewayCreateManyArgs>(
      args?: SelectSubset<T, gatewayCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Gateway.
     * @param {gatewayDeleteArgs} args - Arguments to delete one Gateway.
     * @example
     * // Delete one Gateway
     * const Gateway = await prisma.gateway.delete({
     *   where: {
     *     // ... filter to delete one Gateway
     *   }
     * })
     * 
    **/
    delete<T extends gatewayDeleteArgs>(
      args: SelectSubset<T, gatewayDeleteArgs>
    ): Prisma__gatewayClient<gatewayGetPayload<T>>

    /**
     * Update one Gateway.
     * @param {gatewayUpdateArgs} args - Arguments to update one Gateway.
     * @example
     * // Update one Gateway
     * const gateway = await prisma.gateway.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends gatewayUpdateArgs>(
      args: SelectSubset<T, gatewayUpdateArgs>
    ): Prisma__gatewayClient<gatewayGetPayload<T>>

    /**
     * Delete zero or more Gateways.
     * @param {gatewayDeleteManyArgs} args - Arguments to filter Gateways to delete.
     * @example
     * // Delete a few Gateways
     * const { count } = await prisma.gateway.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends gatewayDeleteManyArgs>(
      args?: SelectSubset<T, gatewayDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Gateways.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {gatewayUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Gateways
     * const gateway = await prisma.gateway.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends gatewayUpdateManyArgs>(
      args: SelectSubset<T, gatewayUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Gateway.
     * @param {gatewayUpsertArgs} args - Arguments to update or create a Gateway.
     * @example
     * // Update or create a Gateway
     * const gateway = await prisma.gateway.upsert({
     *   create: {
     *     // ... data to create a Gateway
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Gateway we want to update
     *   }
     * })
    **/
    upsert<T extends gatewayUpsertArgs>(
      args: SelectSubset<T, gatewayUpsertArgs>
    ): Prisma__gatewayClient<gatewayGetPayload<T>>

    /**
     * Count the number of Gateways.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {gatewayCountArgs} args - Arguments to filter Gateways to count.
     * @example
     * // Count the number of Gateways
     * const count = await prisma.gateway.count({
     *   where: {
     *     // ... the filter for the Gateways we want to count
     *   }
     * })
    **/
    count<T extends gatewayCountArgs>(
      args?: Subset<T, gatewayCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GatewayCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Gateway.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GatewayAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GatewayAggregateArgs>(args: Subset<T, GatewayAggregateArgs>): PrismaPromise<GetGatewayAggregateType<T>>

    /**
     * Group by Gateway.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GatewayGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GatewayGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GatewayGroupByArgs['orderBy'] }
        : { orderBy?: GatewayGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GatewayGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGatewayGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for gateway.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__gatewayClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * gateway base type for findUnique actions
   */
  export type gatewayFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the gateway
     * 
    **/
    select?: gatewaySelect | null
    /**
     * Filter, which gateway to fetch.
     * 
    **/
    where: gatewayWhereUniqueInput
  }

  /**
   * gateway: findUnique
   */
  export interface gatewayFindUniqueArgs extends gatewayFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * gateway findUniqueOrThrow
   */
  export type gatewayFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the gateway
     * 
    **/
    select?: gatewaySelect | null
    /**
     * Filter, which gateway to fetch.
     * 
    **/
    where: gatewayWhereUniqueInput
  }


  /**
   * gateway base type for findFirst actions
   */
  export type gatewayFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the gateway
     * 
    **/
    select?: gatewaySelect | null
    /**
     * Filter, which gateway to fetch.
     * 
    **/
    where?: gatewayWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of gateways to fetch.
     * 
    **/
    orderBy?: Enumerable<gatewayOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for gateways.
     * 
    **/
    cursor?: gatewayWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` gateways from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` gateways.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of gateways.
     * 
    **/
    distinct?: Enumerable<GatewayScalarFieldEnum>
  }

  /**
   * gateway: findFirst
   */
  export interface gatewayFindFirstArgs extends gatewayFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * gateway findFirstOrThrow
   */
  export type gatewayFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the gateway
     * 
    **/
    select?: gatewaySelect | null
    /**
     * Filter, which gateway to fetch.
     * 
    **/
    where?: gatewayWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of gateways to fetch.
     * 
    **/
    orderBy?: Enumerable<gatewayOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for gateways.
     * 
    **/
    cursor?: gatewayWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` gateways from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` gateways.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of gateways.
     * 
    **/
    distinct?: Enumerable<GatewayScalarFieldEnum>
  }


  /**
   * gateway findMany
   */
  export type gatewayFindManyArgs = {
    /**
     * Select specific fields to fetch from the gateway
     * 
    **/
    select?: gatewaySelect | null
    /**
     * Filter, which gateways to fetch.
     * 
    **/
    where?: gatewayWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of gateways to fetch.
     * 
    **/
    orderBy?: Enumerable<gatewayOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing gateways.
     * 
    **/
    cursor?: gatewayWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` gateways from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` gateways.
     * 
    **/
    skip?: number
    distinct?: Enumerable<GatewayScalarFieldEnum>
  }


  /**
   * gateway create
   */
  export type gatewayCreateArgs = {
    /**
     * Select specific fields to fetch from the gateway
     * 
    **/
    select?: gatewaySelect | null
    /**
     * The data needed to create a gateway.
     * 
    **/
    data: XOR<gatewayCreateInput, gatewayUncheckedCreateInput>
  }


  /**
   * gateway createMany
   */
  export type gatewayCreateManyArgs = {
    /**
     * The data used to create many gateways.
     * 
    **/
    data: Enumerable<gatewayCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * gateway update
   */
  export type gatewayUpdateArgs = {
    /**
     * Select specific fields to fetch from the gateway
     * 
    **/
    select?: gatewaySelect | null
    /**
     * The data needed to update a gateway.
     * 
    **/
    data: XOR<gatewayUpdateInput, gatewayUncheckedUpdateInput>
    /**
     * Choose, which gateway to update.
     * 
    **/
    where: gatewayWhereUniqueInput
  }


  /**
   * gateway updateMany
   */
  export type gatewayUpdateManyArgs = {
    /**
     * The data used to update gateways.
     * 
    **/
    data: XOR<gatewayUpdateManyMutationInput, gatewayUncheckedUpdateManyInput>
    /**
     * Filter which gateways to update
     * 
    **/
    where?: gatewayWhereInput
  }


  /**
   * gateway upsert
   */
  export type gatewayUpsertArgs = {
    /**
     * Select specific fields to fetch from the gateway
     * 
    **/
    select?: gatewaySelect | null
    /**
     * The filter to search for the gateway to update in case it exists.
     * 
    **/
    where: gatewayWhereUniqueInput
    /**
     * In case the gateway found by the `where` argument doesn't exist, create a new gateway with this data.
     * 
    **/
    create: XOR<gatewayCreateInput, gatewayUncheckedCreateInput>
    /**
     * In case the gateway was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<gatewayUpdateInput, gatewayUncheckedUpdateInput>
  }


  /**
   * gateway delete
   */
  export type gatewayDeleteArgs = {
    /**
     * Select specific fields to fetch from the gateway
     * 
    **/
    select?: gatewaySelect | null
    /**
     * Filter which gateway to delete.
     * 
    **/
    where: gatewayWhereUniqueInput
  }


  /**
   * gateway deleteMany
   */
  export type gatewayDeleteManyArgs = {
    /**
     * Filter which gateways to delete
     * 
    **/
    where?: gatewayWhereInput
  }


  /**
   * gateway without action
   */
  export type gatewayArgs = {
    /**
     * Select specific fields to fetch from the gateway
     * 
    **/
    select?: gatewaySelect | null
  }



  /**
   * Model gruposdispositivos
   */


  export type AggregateGruposdispositivos = {
    _count: GruposdispositivosCountAggregateOutputType | null
    _avg: GruposdispositivosAvgAggregateOutputType | null
    _sum: GruposdispositivosSumAggregateOutputType | null
    _min: GruposdispositivosMinAggregateOutputType | null
    _max: GruposdispositivosMaxAggregateOutputType | null
  }

  export type GruposdispositivosAvgAggregateOutputType = {
    IDGrupoDispositivo: number | null
  }

  export type GruposdispositivosSumAggregateOutputType = {
    IDGrupoDispositivo: number | null
  }

  export type GruposdispositivosMinAggregateOutputType = {
    IDGrupoDispositivo: number | null
    NombreGrupoDispositivo: string | null
    Identificador: string | null
    Descripcion: string | null
  }

  export type GruposdispositivosMaxAggregateOutputType = {
    IDGrupoDispositivo: number | null
    NombreGrupoDispositivo: string | null
    Identificador: string | null
    Descripcion: string | null
  }

  export type GruposdispositivosCountAggregateOutputType = {
    IDGrupoDispositivo: number
    NombreGrupoDispositivo: number
    Identificador: number
    Descripcion: number
    _all: number
  }


  export type GruposdispositivosAvgAggregateInputType = {
    IDGrupoDispositivo?: true
  }

  export type GruposdispositivosSumAggregateInputType = {
    IDGrupoDispositivo?: true
  }

  export type GruposdispositivosMinAggregateInputType = {
    IDGrupoDispositivo?: true
    NombreGrupoDispositivo?: true
    Identificador?: true
    Descripcion?: true
  }

  export type GruposdispositivosMaxAggregateInputType = {
    IDGrupoDispositivo?: true
    NombreGrupoDispositivo?: true
    Identificador?: true
    Descripcion?: true
  }

  export type GruposdispositivosCountAggregateInputType = {
    IDGrupoDispositivo?: true
    NombreGrupoDispositivo?: true
    Identificador?: true
    Descripcion?: true
    _all?: true
  }

  export type GruposdispositivosAggregateArgs = {
    /**
     * Filter which gruposdispositivos to aggregate.
     * 
    **/
    where?: gruposdispositivosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of gruposdispositivos to fetch.
     * 
    **/
    orderBy?: Enumerable<gruposdispositivosOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: gruposdispositivosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` gruposdispositivos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` gruposdispositivos.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned gruposdispositivos
    **/
    _count?: true | GruposdispositivosCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GruposdispositivosAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GruposdispositivosSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GruposdispositivosMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GruposdispositivosMaxAggregateInputType
  }

  export type GetGruposdispositivosAggregateType<T extends GruposdispositivosAggregateArgs> = {
        [P in keyof T & keyof AggregateGruposdispositivos]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGruposdispositivos[P]>
      : GetScalarType<T[P], AggregateGruposdispositivos[P]>
  }




  export type GruposdispositivosGroupByArgs = {
    where?: gruposdispositivosWhereInput
    orderBy?: Enumerable<gruposdispositivosOrderByWithAggregationInput>
    by: Array<GruposdispositivosScalarFieldEnum>
    having?: gruposdispositivosScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GruposdispositivosCountAggregateInputType | true
    _avg?: GruposdispositivosAvgAggregateInputType
    _sum?: GruposdispositivosSumAggregateInputType
    _min?: GruposdispositivosMinAggregateInputType
    _max?: GruposdispositivosMaxAggregateInputType
  }


  export type GruposdispositivosGroupByOutputType = {
    IDGrupoDispositivo: number
    NombreGrupoDispositivo: string | null
    Identificador: string | null
    Descripcion: string | null
    _count: GruposdispositivosCountAggregateOutputType | null
    _avg: GruposdispositivosAvgAggregateOutputType | null
    _sum: GruposdispositivosSumAggregateOutputType | null
    _min: GruposdispositivosMinAggregateOutputType | null
    _max: GruposdispositivosMaxAggregateOutputType | null
  }

  type GetGruposdispositivosGroupByPayload<T extends GruposdispositivosGroupByArgs> = PrismaPromise<
    Array<
      PickArray<GruposdispositivosGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GruposdispositivosGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GruposdispositivosGroupByOutputType[P]>
            : GetScalarType<T[P], GruposdispositivosGroupByOutputType[P]>
        }
      >
    >


  export type gruposdispositivosSelect = {
    IDGrupoDispositivo?: boolean
    NombreGrupoDispositivo?: boolean
    Identificador?: boolean
    Descripcion?: boolean
  }


  export type gruposdispositivosGetPayload<S extends boolean | null | undefined | gruposdispositivosArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? gruposdispositivos :
    S extends undefined ? never :
    S extends { include: any } & (gruposdispositivosArgs | gruposdispositivosFindManyArgs)
    ? gruposdispositivos 
    : S extends { select: any } & (gruposdispositivosArgs | gruposdispositivosFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof gruposdispositivos ? gruposdispositivos[P] : never
  } 
      : gruposdispositivos


  type gruposdispositivosCountArgs = Merge<
    Omit<gruposdispositivosFindManyArgs, 'select' | 'include'> & {
      select?: GruposdispositivosCountAggregateInputType | true
    }
  >

  export interface gruposdispositivosDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Gruposdispositivos that matches the filter.
     * @param {gruposdispositivosFindUniqueArgs} args - Arguments to find a Gruposdispositivos
     * @example
     * // Get one Gruposdispositivos
     * const gruposdispositivos = await prisma.gruposdispositivos.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends gruposdispositivosFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, gruposdispositivosFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'gruposdispositivos'> extends True ? Prisma__gruposdispositivosClient<gruposdispositivosGetPayload<T>> : Prisma__gruposdispositivosClient<gruposdispositivosGetPayload<T> | null, null>

    /**
     * Find one Gruposdispositivos that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {gruposdispositivosFindUniqueOrThrowArgs} args - Arguments to find a Gruposdispositivos
     * @example
     * // Get one Gruposdispositivos
     * const gruposdispositivos = await prisma.gruposdispositivos.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends gruposdispositivosFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, gruposdispositivosFindUniqueOrThrowArgs>
    ): Prisma__gruposdispositivosClient<gruposdispositivosGetPayload<T>>

    /**
     * Find the first Gruposdispositivos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {gruposdispositivosFindFirstArgs} args - Arguments to find a Gruposdispositivos
     * @example
     * // Get one Gruposdispositivos
     * const gruposdispositivos = await prisma.gruposdispositivos.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends gruposdispositivosFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, gruposdispositivosFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'gruposdispositivos'> extends True ? Prisma__gruposdispositivosClient<gruposdispositivosGetPayload<T>> : Prisma__gruposdispositivosClient<gruposdispositivosGetPayload<T> | null, null>

    /**
     * Find the first Gruposdispositivos that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {gruposdispositivosFindFirstOrThrowArgs} args - Arguments to find a Gruposdispositivos
     * @example
     * // Get one Gruposdispositivos
     * const gruposdispositivos = await prisma.gruposdispositivos.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends gruposdispositivosFindFirstOrThrowArgs>(
      args?: SelectSubset<T, gruposdispositivosFindFirstOrThrowArgs>
    ): Prisma__gruposdispositivosClient<gruposdispositivosGetPayload<T>>

    /**
     * Find zero or more Gruposdispositivos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {gruposdispositivosFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Gruposdispositivos
     * const gruposdispositivos = await prisma.gruposdispositivos.findMany()
     * 
     * // Get first 10 Gruposdispositivos
     * const gruposdispositivos = await prisma.gruposdispositivos.findMany({ take: 10 })
     * 
     * // Only select the `IDGrupoDispositivo`
     * const gruposdispositivosWithIDGrupoDispositivoOnly = await prisma.gruposdispositivos.findMany({ select: { IDGrupoDispositivo: true } })
     * 
    **/
    findMany<T extends gruposdispositivosFindManyArgs>(
      args?: SelectSubset<T, gruposdispositivosFindManyArgs>
    ): PrismaPromise<Array<gruposdispositivosGetPayload<T>>>

    /**
     * Create a Gruposdispositivos.
     * @param {gruposdispositivosCreateArgs} args - Arguments to create a Gruposdispositivos.
     * @example
     * // Create one Gruposdispositivos
     * const Gruposdispositivos = await prisma.gruposdispositivos.create({
     *   data: {
     *     // ... data to create a Gruposdispositivos
     *   }
     * })
     * 
    **/
    create<T extends gruposdispositivosCreateArgs>(
      args: SelectSubset<T, gruposdispositivosCreateArgs>
    ): Prisma__gruposdispositivosClient<gruposdispositivosGetPayload<T>>

    /**
     * Create many Gruposdispositivos.
     *     @param {gruposdispositivosCreateManyArgs} args - Arguments to create many Gruposdispositivos.
     *     @example
     *     // Create many Gruposdispositivos
     *     const gruposdispositivos = await prisma.gruposdispositivos.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends gruposdispositivosCreateManyArgs>(
      args?: SelectSubset<T, gruposdispositivosCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Gruposdispositivos.
     * @param {gruposdispositivosDeleteArgs} args - Arguments to delete one Gruposdispositivos.
     * @example
     * // Delete one Gruposdispositivos
     * const Gruposdispositivos = await prisma.gruposdispositivos.delete({
     *   where: {
     *     // ... filter to delete one Gruposdispositivos
     *   }
     * })
     * 
    **/
    delete<T extends gruposdispositivosDeleteArgs>(
      args: SelectSubset<T, gruposdispositivosDeleteArgs>
    ): Prisma__gruposdispositivosClient<gruposdispositivosGetPayload<T>>

    /**
     * Update one Gruposdispositivos.
     * @param {gruposdispositivosUpdateArgs} args - Arguments to update one Gruposdispositivos.
     * @example
     * // Update one Gruposdispositivos
     * const gruposdispositivos = await prisma.gruposdispositivos.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends gruposdispositivosUpdateArgs>(
      args: SelectSubset<T, gruposdispositivosUpdateArgs>
    ): Prisma__gruposdispositivosClient<gruposdispositivosGetPayload<T>>

    /**
     * Delete zero or more Gruposdispositivos.
     * @param {gruposdispositivosDeleteManyArgs} args - Arguments to filter Gruposdispositivos to delete.
     * @example
     * // Delete a few Gruposdispositivos
     * const { count } = await prisma.gruposdispositivos.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends gruposdispositivosDeleteManyArgs>(
      args?: SelectSubset<T, gruposdispositivosDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Gruposdispositivos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {gruposdispositivosUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Gruposdispositivos
     * const gruposdispositivos = await prisma.gruposdispositivos.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends gruposdispositivosUpdateManyArgs>(
      args: SelectSubset<T, gruposdispositivosUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Gruposdispositivos.
     * @param {gruposdispositivosUpsertArgs} args - Arguments to update or create a Gruposdispositivos.
     * @example
     * // Update or create a Gruposdispositivos
     * const gruposdispositivos = await prisma.gruposdispositivos.upsert({
     *   create: {
     *     // ... data to create a Gruposdispositivos
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Gruposdispositivos we want to update
     *   }
     * })
    **/
    upsert<T extends gruposdispositivosUpsertArgs>(
      args: SelectSubset<T, gruposdispositivosUpsertArgs>
    ): Prisma__gruposdispositivosClient<gruposdispositivosGetPayload<T>>

    /**
     * Count the number of Gruposdispositivos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {gruposdispositivosCountArgs} args - Arguments to filter Gruposdispositivos to count.
     * @example
     * // Count the number of Gruposdispositivos
     * const count = await prisma.gruposdispositivos.count({
     *   where: {
     *     // ... the filter for the Gruposdispositivos we want to count
     *   }
     * })
    **/
    count<T extends gruposdispositivosCountArgs>(
      args?: Subset<T, gruposdispositivosCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GruposdispositivosCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Gruposdispositivos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GruposdispositivosAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GruposdispositivosAggregateArgs>(args: Subset<T, GruposdispositivosAggregateArgs>): PrismaPromise<GetGruposdispositivosAggregateType<T>>

    /**
     * Group by Gruposdispositivos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GruposdispositivosGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GruposdispositivosGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GruposdispositivosGroupByArgs['orderBy'] }
        : { orderBy?: GruposdispositivosGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GruposdispositivosGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGruposdispositivosGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for gruposdispositivos.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__gruposdispositivosClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * gruposdispositivos base type for findUnique actions
   */
  export type gruposdispositivosFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the gruposdispositivos
     * 
    **/
    select?: gruposdispositivosSelect | null
    /**
     * Filter, which gruposdispositivos to fetch.
     * 
    **/
    where: gruposdispositivosWhereUniqueInput
  }

  /**
   * gruposdispositivos: findUnique
   */
  export interface gruposdispositivosFindUniqueArgs extends gruposdispositivosFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * gruposdispositivos findUniqueOrThrow
   */
  export type gruposdispositivosFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the gruposdispositivos
     * 
    **/
    select?: gruposdispositivosSelect | null
    /**
     * Filter, which gruposdispositivos to fetch.
     * 
    **/
    where: gruposdispositivosWhereUniqueInput
  }


  /**
   * gruposdispositivos base type for findFirst actions
   */
  export type gruposdispositivosFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the gruposdispositivos
     * 
    **/
    select?: gruposdispositivosSelect | null
    /**
     * Filter, which gruposdispositivos to fetch.
     * 
    **/
    where?: gruposdispositivosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of gruposdispositivos to fetch.
     * 
    **/
    orderBy?: Enumerable<gruposdispositivosOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for gruposdispositivos.
     * 
    **/
    cursor?: gruposdispositivosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` gruposdispositivos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` gruposdispositivos.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of gruposdispositivos.
     * 
    **/
    distinct?: Enumerable<GruposdispositivosScalarFieldEnum>
  }

  /**
   * gruposdispositivos: findFirst
   */
  export interface gruposdispositivosFindFirstArgs extends gruposdispositivosFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * gruposdispositivos findFirstOrThrow
   */
  export type gruposdispositivosFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the gruposdispositivos
     * 
    **/
    select?: gruposdispositivosSelect | null
    /**
     * Filter, which gruposdispositivos to fetch.
     * 
    **/
    where?: gruposdispositivosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of gruposdispositivos to fetch.
     * 
    **/
    orderBy?: Enumerable<gruposdispositivosOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for gruposdispositivos.
     * 
    **/
    cursor?: gruposdispositivosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` gruposdispositivos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` gruposdispositivos.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of gruposdispositivos.
     * 
    **/
    distinct?: Enumerable<GruposdispositivosScalarFieldEnum>
  }


  /**
   * gruposdispositivos findMany
   */
  export type gruposdispositivosFindManyArgs = {
    /**
     * Select specific fields to fetch from the gruposdispositivos
     * 
    **/
    select?: gruposdispositivosSelect | null
    /**
     * Filter, which gruposdispositivos to fetch.
     * 
    **/
    where?: gruposdispositivosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of gruposdispositivos to fetch.
     * 
    **/
    orderBy?: Enumerable<gruposdispositivosOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing gruposdispositivos.
     * 
    **/
    cursor?: gruposdispositivosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` gruposdispositivos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` gruposdispositivos.
     * 
    **/
    skip?: number
    distinct?: Enumerable<GruposdispositivosScalarFieldEnum>
  }


  /**
   * gruposdispositivos create
   */
  export type gruposdispositivosCreateArgs = {
    /**
     * Select specific fields to fetch from the gruposdispositivos
     * 
    **/
    select?: gruposdispositivosSelect | null
    /**
     * The data needed to create a gruposdispositivos.
     * 
    **/
    data: XOR<gruposdispositivosCreateInput, gruposdispositivosUncheckedCreateInput>
  }


  /**
   * gruposdispositivos createMany
   */
  export type gruposdispositivosCreateManyArgs = {
    /**
     * The data used to create many gruposdispositivos.
     * 
    **/
    data: Enumerable<gruposdispositivosCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * gruposdispositivos update
   */
  export type gruposdispositivosUpdateArgs = {
    /**
     * Select specific fields to fetch from the gruposdispositivos
     * 
    **/
    select?: gruposdispositivosSelect | null
    /**
     * The data needed to update a gruposdispositivos.
     * 
    **/
    data: XOR<gruposdispositivosUpdateInput, gruposdispositivosUncheckedUpdateInput>
    /**
     * Choose, which gruposdispositivos to update.
     * 
    **/
    where: gruposdispositivosWhereUniqueInput
  }


  /**
   * gruposdispositivos updateMany
   */
  export type gruposdispositivosUpdateManyArgs = {
    /**
     * The data used to update gruposdispositivos.
     * 
    **/
    data: XOR<gruposdispositivosUpdateManyMutationInput, gruposdispositivosUncheckedUpdateManyInput>
    /**
     * Filter which gruposdispositivos to update
     * 
    **/
    where?: gruposdispositivosWhereInput
  }


  /**
   * gruposdispositivos upsert
   */
  export type gruposdispositivosUpsertArgs = {
    /**
     * Select specific fields to fetch from the gruposdispositivos
     * 
    **/
    select?: gruposdispositivosSelect | null
    /**
     * The filter to search for the gruposdispositivos to update in case it exists.
     * 
    **/
    where: gruposdispositivosWhereUniqueInput
    /**
     * In case the gruposdispositivos found by the `where` argument doesn't exist, create a new gruposdispositivos with this data.
     * 
    **/
    create: XOR<gruposdispositivosCreateInput, gruposdispositivosUncheckedCreateInput>
    /**
     * In case the gruposdispositivos was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<gruposdispositivosUpdateInput, gruposdispositivosUncheckedUpdateInput>
  }


  /**
   * gruposdispositivos delete
   */
  export type gruposdispositivosDeleteArgs = {
    /**
     * Select specific fields to fetch from the gruposdispositivos
     * 
    **/
    select?: gruposdispositivosSelect | null
    /**
     * Filter which gruposdispositivos to delete.
     * 
    **/
    where: gruposdispositivosWhereUniqueInput
  }


  /**
   * gruposdispositivos deleteMany
   */
  export type gruposdispositivosDeleteManyArgs = {
    /**
     * Filter which gruposdispositivos to delete
     * 
    **/
    where?: gruposdispositivosWhereInput
  }


  /**
   * gruposdispositivos without action
   */
  export type gruposdispositivosArgs = {
    /**
     * Select specific fields to fetch from the gruposdispositivos
     * 
    **/
    select?: gruposdispositivosSelect | null
  }



  /**
   * Model inventariocatastro
   */


  export type AggregateInventariocatastro = {
    _count: InventariocatastroCountAggregateOutputType | null
    _avg: InventariocatastroAvgAggregateOutputType | null
    _sum: InventariocatastroSumAggregateOutputType | null
    _min: InventariocatastroMinAggregateOutputType | null
    _max: InventariocatastroMaxAggregateOutputType | null
  }

  export type InventariocatastroAvgAggregateOutputType = {
    IDEntidadInventario: number | null
    IDTipoEntidadInventario: number | null
    IDCategoriaEntidadInventario: number | null
    IDGateway: number | null
    IDDispositivo: number | null
    IDMetaEdificio: number | null
    IDEdificio: number | null
    Latitud: Decimal | null
    Longitud: Decimal | null
  }

  export type InventariocatastroSumAggregateOutputType = {
    IDEntidadInventario: number | null
    IDTipoEntidadInventario: number | null
    IDCategoriaEntidadInventario: number | null
    IDGateway: number | null
    IDDispositivo: number | null
    IDMetaEdificio: number | null
    IDEdificio: number | null
    Latitud: Decimal | null
    Longitud: Decimal | null
  }

  export type InventariocatastroMinAggregateOutputType = {
    IDEntidadInventario: number | null
    IDTipoEntidadInventario: number | null
    IDCategoriaEntidadInventario: number | null
    IDGateway: number | null
    IDDispositivo: number | null
    IDMetaEdificio: number | null
    IDEdificio: number | null
    NombreEntidadInventario: string | null
    Descripcion: string | null
    Latitud: Decimal | null
    Longitud: Decimal | null
    SerialGPS: string | null
    GeometriaGPS: string | null
    FechaAlta: Date | null
    FechaBaja: Date | null
  }

  export type InventariocatastroMaxAggregateOutputType = {
    IDEntidadInventario: number | null
    IDTipoEntidadInventario: number | null
    IDCategoriaEntidadInventario: number | null
    IDGateway: number | null
    IDDispositivo: number | null
    IDMetaEdificio: number | null
    IDEdificio: number | null
    NombreEntidadInventario: string | null
    Descripcion: string | null
    Latitud: Decimal | null
    Longitud: Decimal | null
    SerialGPS: string | null
    GeometriaGPS: string | null
    FechaAlta: Date | null
    FechaBaja: Date | null
  }

  export type InventariocatastroCountAggregateOutputType = {
    IDEntidadInventario: number
    IDTipoEntidadInventario: number
    IDCategoriaEntidadInventario: number
    IDGateway: number
    IDDispositivo: number
    IDMetaEdificio: number
    IDEdificio: number
    NombreEntidadInventario: number
    Descripcion: number
    Latitud: number
    Longitud: number
    SerialGPS: number
    GeometriaGPS: number
    FechaAlta: number
    FechaBaja: number
    _all: number
  }


  export type InventariocatastroAvgAggregateInputType = {
    IDEntidadInventario?: true
    IDTipoEntidadInventario?: true
    IDCategoriaEntidadInventario?: true
    IDGateway?: true
    IDDispositivo?: true
    IDMetaEdificio?: true
    IDEdificio?: true
    Latitud?: true
    Longitud?: true
  }

  export type InventariocatastroSumAggregateInputType = {
    IDEntidadInventario?: true
    IDTipoEntidadInventario?: true
    IDCategoriaEntidadInventario?: true
    IDGateway?: true
    IDDispositivo?: true
    IDMetaEdificio?: true
    IDEdificio?: true
    Latitud?: true
    Longitud?: true
  }

  export type InventariocatastroMinAggregateInputType = {
    IDEntidadInventario?: true
    IDTipoEntidadInventario?: true
    IDCategoriaEntidadInventario?: true
    IDGateway?: true
    IDDispositivo?: true
    IDMetaEdificio?: true
    IDEdificio?: true
    NombreEntidadInventario?: true
    Descripcion?: true
    Latitud?: true
    Longitud?: true
    SerialGPS?: true
    GeometriaGPS?: true
    FechaAlta?: true
    FechaBaja?: true
  }

  export type InventariocatastroMaxAggregateInputType = {
    IDEntidadInventario?: true
    IDTipoEntidadInventario?: true
    IDCategoriaEntidadInventario?: true
    IDGateway?: true
    IDDispositivo?: true
    IDMetaEdificio?: true
    IDEdificio?: true
    NombreEntidadInventario?: true
    Descripcion?: true
    Latitud?: true
    Longitud?: true
    SerialGPS?: true
    GeometriaGPS?: true
    FechaAlta?: true
    FechaBaja?: true
  }

  export type InventariocatastroCountAggregateInputType = {
    IDEntidadInventario?: true
    IDTipoEntidadInventario?: true
    IDCategoriaEntidadInventario?: true
    IDGateway?: true
    IDDispositivo?: true
    IDMetaEdificio?: true
    IDEdificio?: true
    NombreEntidadInventario?: true
    Descripcion?: true
    Latitud?: true
    Longitud?: true
    SerialGPS?: true
    GeometriaGPS?: true
    FechaAlta?: true
    FechaBaja?: true
    _all?: true
  }

  export type InventariocatastroAggregateArgs = {
    /**
     * Filter which inventariocatastro to aggregate.
     * 
    **/
    where?: inventariocatastroWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inventariocatastros to fetch.
     * 
    **/
    orderBy?: Enumerable<inventariocatastroOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: inventariocatastroWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inventariocatastros from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inventariocatastros.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned inventariocatastros
    **/
    _count?: true | InventariocatastroCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InventariocatastroAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InventariocatastroSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InventariocatastroMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InventariocatastroMaxAggregateInputType
  }

  export type GetInventariocatastroAggregateType<T extends InventariocatastroAggregateArgs> = {
        [P in keyof T & keyof AggregateInventariocatastro]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInventariocatastro[P]>
      : GetScalarType<T[P], AggregateInventariocatastro[P]>
  }




  export type InventariocatastroGroupByArgs = {
    where?: inventariocatastroWhereInput
    orderBy?: Enumerable<inventariocatastroOrderByWithAggregationInput>
    by: Array<InventariocatastroScalarFieldEnum>
    having?: inventariocatastroScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InventariocatastroCountAggregateInputType | true
    _avg?: InventariocatastroAvgAggregateInputType
    _sum?: InventariocatastroSumAggregateInputType
    _min?: InventariocatastroMinAggregateInputType
    _max?: InventariocatastroMaxAggregateInputType
  }


  export type InventariocatastroGroupByOutputType = {
    IDEntidadInventario: number
    IDTipoEntidadInventario: number | null
    IDCategoriaEntidadInventario: number | null
    IDGateway: number | null
    IDDispositivo: number | null
    IDMetaEdificio: number | null
    IDEdificio: number | null
    NombreEntidadInventario: string | null
    Descripcion: string | null
    Latitud: Decimal | null
    Longitud: Decimal | null
    SerialGPS: string | null
    GeometriaGPS: string | null
    FechaAlta: Date | null
    FechaBaja: Date | null
    _count: InventariocatastroCountAggregateOutputType | null
    _avg: InventariocatastroAvgAggregateOutputType | null
    _sum: InventariocatastroSumAggregateOutputType | null
    _min: InventariocatastroMinAggregateOutputType | null
    _max: InventariocatastroMaxAggregateOutputType | null
  }

  type GetInventariocatastroGroupByPayload<T extends InventariocatastroGroupByArgs> = PrismaPromise<
    Array<
      PickArray<InventariocatastroGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InventariocatastroGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InventariocatastroGroupByOutputType[P]>
            : GetScalarType<T[P], InventariocatastroGroupByOutputType[P]>
        }
      >
    >


  export type inventariocatastroSelect = {
    IDEntidadInventario?: boolean
    IDTipoEntidadInventario?: boolean
    IDCategoriaEntidadInventario?: boolean
    IDGateway?: boolean
    IDDispositivo?: boolean
    IDMetaEdificio?: boolean
    IDEdificio?: boolean
    NombreEntidadInventario?: boolean
    Descripcion?: boolean
    Latitud?: boolean
    Longitud?: boolean
    SerialGPS?: boolean
    GeometriaGPS?: boolean
    FechaAlta?: boolean
    FechaBaja?: boolean
  }


  export type inventariocatastroGetPayload<S extends boolean | null | undefined | inventariocatastroArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? inventariocatastro :
    S extends undefined ? never :
    S extends { include: any } & (inventariocatastroArgs | inventariocatastroFindManyArgs)
    ? inventariocatastro 
    : S extends { select: any } & (inventariocatastroArgs | inventariocatastroFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof inventariocatastro ? inventariocatastro[P] : never
  } 
      : inventariocatastro


  type inventariocatastroCountArgs = Merge<
    Omit<inventariocatastroFindManyArgs, 'select' | 'include'> & {
      select?: InventariocatastroCountAggregateInputType | true
    }
  >

  export interface inventariocatastroDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Inventariocatastro that matches the filter.
     * @param {inventariocatastroFindUniqueArgs} args - Arguments to find a Inventariocatastro
     * @example
     * // Get one Inventariocatastro
     * const inventariocatastro = await prisma.inventariocatastro.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends inventariocatastroFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, inventariocatastroFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'inventariocatastro'> extends True ? Prisma__inventariocatastroClient<inventariocatastroGetPayload<T>> : Prisma__inventariocatastroClient<inventariocatastroGetPayload<T> | null, null>

    /**
     * Find one Inventariocatastro that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {inventariocatastroFindUniqueOrThrowArgs} args - Arguments to find a Inventariocatastro
     * @example
     * // Get one Inventariocatastro
     * const inventariocatastro = await prisma.inventariocatastro.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends inventariocatastroFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, inventariocatastroFindUniqueOrThrowArgs>
    ): Prisma__inventariocatastroClient<inventariocatastroGetPayload<T>>

    /**
     * Find the first Inventariocatastro that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inventariocatastroFindFirstArgs} args - Arguments to find a Inventariocatastro
     * @example
     * // Get one Inventariocatastro
     * const inventariocatastro = await prisma.inventariocatastro.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends inventariocatastroFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, inventariocatastroFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'inventariocatastro'> extends True ? Prisma__inventariocatastroClient<inventariocatastroGetPayload<T>> : Prisma__inventariocatastroClient<inventariocatastroGetPayload<T> | null, null>

    /**
     * Find the first Inventariocatastro that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inventariocatastroFindFirstOrThrowArgs} args - Arguments to find a Inventariocatastro
     * @example
     * // Get one Inventariocatastro
     * const inventariocatastro = await prisma.inventariocatastro.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends inventariocatastroFindFirstOrThrowArgs>(
      args?: SelectSubset<T, inventariocatastroFindFirstOrThrowArgs>
    ): Prisma__inventariocatastroClient<inventariocatastroGetPayload<T>>

    /**
     * Find zero or more Inventariocatastros that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inventariocatastroFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Inventariocatastros
     * const inventariocatastros = await prisma.inventariocatastro.findMany()
     * 
     * // Get first 10 Inventariocatastros
     * const inventariocatastros = await prisma.inventariocatastro.findMany({ take: 10 })
     * 
     * // Only select the `IDEntidadInventario`
     * const inventariocatastroWithIDEntidadInventarioOnly = await prisma.inventariocatastro.findMany({ select: { IDEntidadInventario: true } })
     * 
    **/
    findMany<T extends inventariocatastroFindManyArgs>(
      args?: SelectSubset<T, inventariocatastroFindManyArgs>
    ): PrismaPromise<Array<inventariocatastroGetPayload<T>>>

    /**
     * Create a Inventariocatastro.
     * @param {inventariocatastroCreateArgs} args - Arguments to create a Inventariocatastro.
     * @example
     * // Create one Inventariocatastro
     * const Inventariocatastro = await prisma.inventariocatastro.create({
     *   data: {
     *     // ... data to create a Inventariocatastro
     *   }
     * })
     * 
    **/
    create<T extends inventariocatastroCreateArgs>(
      args: SelectSubset<T, inventariocatastroCreateArgs>
    ): Prisma__inventariocatastroClient<inventariocatastroGetPayload<T>>

    /**
     * Create many Inventariocatastros.
     *     @param {inventariocatastroCreateManyArgs} args - Arguments to create many Inventariocatastros.
     *     @example
     *     // Create many Inventariocatastros
     *     const inventariocatastro = await prisma.inventariocatastro.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends inventariocatastroCreateManyArgs>(
      args?: SelectSubset<T, inventariocatastroCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Inventariocatastro.
     * @param {inventariocatastroDeleteArgs} args - Arguments to delete one Inventariocatastro.
     * @example
     * // Delete one Inventariocatastro
     * const Inventariocatastro = await prisma.inventariocatastro.delete({
     *   where: {
     *     // ... filter to delete one Inventariocatastro
     *   }
     * })
     * 
    **/
    delete<T extends inventariocatastroDeleteArgs>(
      args: SelectSubset<T, inventariocatastroDeleteArgs>
    ): Prisma__inventariocatastroClient<inventariocatastroGetPayload<T>>

    /**
     * Update one Inventariocatastro.
     * @param {inventariocatastroUpdateArgs} args - Arguments to update one Inventariocatastro.
     * @example
     * // Update one Inventariocatastro
     * const inventariocatastro = await prisma.inventariocatastro.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends inventariocatastroUpdateArgs>(
      args: SelectSubset<T, inventariocatastroUpdateArgs>
    ): Prisma__inventariocatastroClient<inventariocatastroGetPayload<T>>

    /**
     * Delete zero or more Inventariocatastros.
     * @param {inventariocatastroDeleteManyArgs} args - Arguments to filter Inventariocatastros to delete.
     * @example
     * // Delete a few Inventariocatastros
     * const { count } = await prisma.inventariocatastro.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends inventariocatastroDeleteManyArgs>(
      args?: SelectSubset<T, inventariocatastroDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Inventariocatastros.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inventariocatastroUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Inventariocatastros
     * const inventariocatastro = await prisma.inventariocatastro.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends inventariocatastroUpdateManyArgs>(
      args: SelectSubset<T, inventariocatastroUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Inventariocatastro.
     * @param {inventariocatastroUpsertArgs} args - Arguments to update or create a Inventariocatastro.
     * @example
     * // Update or create a Inventariocatastro
     * const inventariocatastro = await prisma.inventariocatastro.upsert({
     *   create: {
     *     // ... data to create a Inventariocatastro
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Inventariocatastro we want to update
     *   }
     * })
    **/
    upsert<T extends inventariocatastroUpsertArgs>(
      args: SelectSubset<T, inventariocatastroUpsertArgs>
    ): Prisma__inventariocatastroClient<inventariocatastroGetPayload<T>>

    /**
     * Count the number of Inventariocatastros.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inventariocatastroCountArgs} args - Arguments to filter Inventariocatastros to count.
     * @example
     * // Count the number of Inventariocatastros
     * const count = await prisma.inventariocatastro.count({
     *   where: {
     *     // ... the filter for the Inventariocatastros we want to count
     *   }
     * })
    **/
    count<T extends inventariocatastroCountArgs>(
      args?: Subset<T, inventariocatastroCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InventariocatastroCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Inventariocatastro.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventariocatastroAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InventariocatastroAggregateArgs>(args: Subset<T, InventariocatastroAggregateArgs>): PrismaPromise<GetInventariocatastroAggregateType<T>>

    /**
     * Group by Inventariocatastro.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventariocatastroGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InventariocatastroGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InventariocatastroGroupByArgs['orderBy'] }
        : { orderBy?: InventariocatastroGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InventariocatastroGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInventariocatastroGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for inventariocatastro.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__inventariocatastroClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * inventariocatastro base type for findUnique actions
   */
  export type inventariocatastroFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the inventariocatastro
     * 
    **/
    select?: inventariocatastroSelect | null
    /**
     * Filter, which inventariocatastro to fetch.
     * 
    **/
    where: inventariocatastroWhereUniqueInput
  }

  /**
   * inventariocatastro: findUnique
   */
  export interface inventariocatastroFindUniqueArgs extends inventariocatastroFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * inventariocatastro findUniqueOrThrow
   */
  export type inventariocatastroFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the inventariocatastro
     * 
    **/
    select?: inventariocatastroSelect | null
    /**
     * Filter, which inventariocatastro to fetch.
     * 
    **/
    where: inventariocatastroWhereUniqueInput
  }


  /**
   * inventariocatastro base type for findFirst actions
   */
  export type inventariocatastroFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the inventariocatastro
     * 
    **/
    select?: inventariocatastroSelect | null
    /**
     * Filter, which inventariocatastro to fetch.
     * 
    **/
    where?: inventariocatastroWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inventariocatastros to fetch.
     * 
    **/
    orderBy?: Enumerable<inventariocatastroOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for inventariocatastros.
     * 
    **/
    cursor?: inventariocatastroWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inventariocatastros from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inventariocatastros.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of inventariocatastros.
     * 
    **/
    distinct?: Enumerable<InventariocatastroScalarFieldEnum>
  }

  /**
   * inventariocatastro: findFirst
   */
  export interface inventariocatastroFindFirstArgs extends inventariocatastroFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * inventariocatastro findFirstOrThrow
   */
  export type inventariocatastroFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the inventariocatastro
     * 
    **/
    select?: inventariocatastroSelect | null
    /**
     * Filter, which inventariocatastro to fetch.
     * 
    **/
    where?: inventariocatastroWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inventariocatastros to fetch.
     * 
    **/
    orderBy?: Enumerable<inventariocatastroOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for inventariocatastros.
     * 
    **/
    cursor?: inventariocatastroWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inventariocatastros from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inventariocatastros.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of inventariocatastros.
     * 
    **/
    distinct?: Enumerable<InventariocatastroScalarFieldEnum>
  }


  /**
   * inventariocatastro findMany
   */
  export type inventariocatastroFindManyArgs = {
    /**
     * Select specific fields to fetch from the inventariocatastro
     * 
    **/
    select?: inventariocatastroSelect | null
    /**
     * Filter, which inventariocatastros to fetch.
     * 
    **/
    where?: inventariocatastroWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inventariocatastros to fetch.
     * 
    **/
    orderBy?: Enumerable<inventariocatastroOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing inventariocatastros.
     * 
    **/
    cursor?: inventariocatastroWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inventariocatastros from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inventariocatastros.
     * 
    **/
    skip?: number
    distinct?: Enumerable<InventariocatastroScalarFieldEnum>
  }


  /**
   * inventariocatastro create
   */
  export type inventariocatastroCreateArgs = {
    /**
     * Select specific fields to fetch from the inventariocatastro
     * 
    **/
    select?: inventariocatastroSelect | null
    /**
     * The data needed to create a inventariocatastro.
     * 
    **/
    data: XOR<inventariocatastroCreateInput, inventariocatastroUncheckedCreateInput>
  }


  /**
   * inventariocatastro createMany
   */
  export type inventariocatastroCreateManyArgs = {
    /**
     * The data used to create many inventariocatastros.
     * 
    **/
    data: Enumerable<inventariocatastroCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * inventariocatastro update
   */
  export type inventariocatastroUpdateArgs = {
    /**
     * Select specific fields to fetch from the inventariocatastro
     * 
    **/
    select?: inventariocatastroSelect | null
    /**
     * The data needed to update a inventariocatastro.
     * 
    **/
    data: XOR<inventariocatastroUpdateInput, inventariocatastroUncheckedUpdateInput>
    /**
     * Choose, which inventariocatastro to update.
     * 
    **/
    where: inventariocatastroWhereUniqueInput
  }


  /**
   * inventariocatastro updateMany
   */
  export type inventariocatastroUpdateManyArgs = {
    /**
     * The data used to update inventariocatastros.
     * 
    **/
    data: XOR<inventariocatastroUpdateManyMutationInput, inventariocatastroUncheckedUpdateManyInput>
    /**
     * Filter which inventariocatastros to update
     * 
    **/
    where?: inventariocatastroWhereInput
  }


  /**
   * inventariocatastro upsert
   */
  export type inventariocatastroUpsertArgs = {
    /**
     * Select specific fields to fetch from the inventariocatastro
     * 
    **/
    select?: inventariocatastroSelect | null
    /**
     * The filter to search for the inventariocatastro to update in case it exists.
     * 
    **/
    where: inventariocatastroWhereUniqueInput
    /**
     * In case the inventariocatastro found by the `where` argument doesn't exist, create a new inventariocatastro with this data.
     * 
    **/
    create: XOR<inventariocatastroCreateInput, inventariocatastroUncheckedCreateInput>
    /**
     * In case the inventariocatastro was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<inventariocatastroUpdateInput, inventariocatastroUncheckedUpdateInput>
  }


  /**
   * inventariocatastro delete
   */
  export type inventariocatastroDeleteArgs = {
    /**
     * Select specific fields to fetch from the inventariocatastro
     * 
    **/
    select?: inventariocatastroSelect | null
    /**
     * Filter which inventariocatastro to delete.
     * 
    **/
    where: inventariocatastroWhereUniqueInput
  }


  /**
   * inventariocatastro deleteMany
   */
  export type inventariocatastroDeleteManyArgs = {
    /**
     * Filter which inventariocatastros to delete
     * 
    **/
    where?: inventariocatastroWhereInput
  }


  /**
   * inventariocatastro without action
   */
  export type inventariocatastroArgs = {
    /**
     * Select specific fields to fetch from the inventariocatastro
     * 
    **/
    select?: inventariocatastroSelect | null
  }



  /**
   * Model libreriasapis
   */


  export type AggregateLibreriasapis = {
    _count: LibreriasapisCountAggregateOutputType | null
    _avg: LibreriasapisAvgAggregateOutputType | null
    _sum: LibreriasapisSumAggregateOutputType | null
    _min: LibreriasapisMinAggregateOutputType | null
    _max: LibreriasapisMaxAggregateOutputType | null
  }

  export type LibreriasapisAvgAggregateOutputType = {
    IDLIBAPISDK: number | null
    Subsistema: number | null
  }

  export type LibreriasapisSumAggregateOutputType = {
    IDLIBAPISDK: number | null
    Subsistema: number | null
  }

  export type LibreriasapisMinAggregateOutputType = {
    IDLIBAPISDK: number | null
    Nombre: string | null
    Tipo: string | null
    Web: string | null
    Subsistema: number | null
    Alcance: string | null
  }

  export type LibreriasapisMaxAggregateOutputType = {
    IDLIBAPISDK: number | null
    Nombre: string | null
    Tipo: string | null
    Web: string | null
    Subsistema: number | null
    Alcance: string | null
  }

  export type LibreriasapisCountAggregateOutputType = {
    IDLIBAPISDK: number
    Nombre: number
    Tipo: number
    Web: number
    Subsistema: number
    Alcance: number
    _all: number
  }


  export type LibreriasapisAvgAggregateInputType = {
    IDLIBAPISDK?: true
    Subsistema?: true
  }

  export type LibreriasapisSumAggregateInputType = {
    IDLIBAPISDK?: true
    Subsistema?: true
  }

  export type LibreriasapisMinAggregateInputType = {
    IDLIBAPISDK?: true
    Nombre?: true
    Tipo?: true
    Web?: true
    Subsistema?: true
    Alcance?: true
  }

  export type LibreriasapisMaxAggregateInputType = {
    IDLIBAPISDK?: true
    Nombre?: true
    Tipo?: true
    Web?: true
    Subsistema?: true
    Alcance?: true
  }

  export type LibreriasapisCountAggregateInputType = {
    IDLIBAPISDK?: true
    Nombre?: true
    Tipo?: true
    Web?: true
    Subsistema?: true
    Alcance?: true
    _all?: true
  }

  export type LibreriasapisAggregateArgs = {
    /**
     * Filter which libreriasapis to aggregate.
     * 
    **/
    where?: libreriasapisWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of libreriasapis to fetch.
     * 
    **/
    orderBy?: Enumerable<libreriasapisOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: libreriasapisWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` libreriasapis from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` libreriasapis.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned libreriasapis
    **/
    _count?: true | LibreriasapisCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LibreriasapisAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LibreriasapisSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LibreriasapisMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LibreriasapisMaxAggregateInputType
  }

  export type GetLibreriasapisAggregateType<T extends LibreriasapisAggregateArgs> = {
        [P in keyof T & keyof AggregateLibreriasapis]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLibreriasapis[P]>
      : GetScalarType<T[P], AggregateLibreriasapis[P]>
  }




  export type LibreriasapisGroupByArgs = {
    where?: libreriasapisWhereInput
    orderBy?: Enumerable<libreriasapisOrderByWithAggregationInput>
    by: Array<LibreriasapisScalarFieldEnum>
    having?: libreriasapisScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LibreriasapisCountAggregateInputType | true
    _avg?: LibreriasapisAvgAggregateInputType
    _sum?: LibreriasapisSumAggregateInputType
    _min?: LibreriasapisMinAggregateInputType
    _max?: LibreriasapisMaxAggregateInputType
  }


  export type LibreriasapisGroupByOutputType = {
    IDLIBAPISDK: number
    Nombre: string | null
    Tipo: string | null
    Web: string | null
    Subsistema: number | null
    Alcance: string | null
    _count: LibreriasapisCountAggregateOutputType | null
    _avg: LibreriasapisAvgAggregateOutputType | null
    _sum: LibreriasapisSumAggregateOutputType | null
    _min: LibreriasapisMinAggregateOutputType | null
    _max: LibreriasapisMaxAggregateOutputType | null
  }

  type GetLibreriasapisGroupByPayload<T extends LibreriasapisGroupByArgs> = PrismaPromise<
    Array<
      PickArray<LibreriasapisGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LibreriasapisGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LibreriasapisGroupByOutputType[P]>
            : GetScalarType<T[P], LibreriasapisGroupByOutputType[P]>
        }
      >
    >


  export type libreriasapisSelect = {
    IDLIBAPISDK?: boolean
    Nombre?: boolean
    Tipo?: boolean
    Web?: boolean
    Subsistema?: boolean
    Alcance?: boolean
  }


  export type libreriasapisGetPayload<S extends boolean | null | undefined | libreriasapisArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? libreriasapis :
    S extends undefined ? never :
    S extends { include: any } & (libreriasapisArgs | libreriasapisFindManyArgs)
    ? libreriasapis 
    : S extends { select: any } & (libreriasapisArgs | libreriasapisFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof libreriasapis ? libreriasapis[P] : never
  } 
      : libreriasapis


  type libreriasapisCountArgs = Merge<
    Omit<libreriasapisFindManyArgs, 'select' | 'include'> & {
      select?: LibreriasapisCountAggregateInputType | true
    }
  >

  export interface libreriasapisDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Libreriasapis that matches the filter.
     * @param {libreriasapisFindUniqueArgs} args - Arguments to find a Libreriasapis
     * @example
     * // Get one Libreriasapis
     * const libreriasapis = await prisma.libreriasapis.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends libreriasapisFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, libreriasapisFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'libreriasapis'> extends True ? Prisma__libreriasapisClient<libreriasapisGetPayload<T>> : Prisma__libreriasapisClient<libreriasapisGetPayload<T> | null, null>

    /**
     * Find one Libreriasapis that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {libreriasapisFindUniqueOrThrowArgs} args - Arguments to find a Libreriasapis
     * @example
     * // Get one Libreriasapis
     * const libreriasapis = await prisma.libreriasapis.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends libreriasapisFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, libreriasapisFindUniqueOrThrowArgs>
    ): Prisma__libreriasapisClient<libreriasapisGetPayload<T>>

    /**
     * Find the first Libreriasapis that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {libreriasapisFindFirstArgs} args - Arguments to find a Libreriasapis
     * @example
     * // Get one Libreriasapis
     * const libreriasapis = await prisma.libreriasapis.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends libreriasapisFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, libreriasapisFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'libreriasapis'> extends True ? Prisma__libreriasapisClient<libreriasapisGetPayload<T>> : Prisma__libreriasapisClient<libreriasapisGetPayload<T> | null, null>

    /**
     * Find the first Libreriasapis that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {libreriasapisFindFirstOrThrowArgs} args - Arguments to find a Libreriasapis
     * @example
     * // Get one Libreriasapis
     * const libreriasapis = await prisma.libreriasapis.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends libreriasapisFindFirstOrThrowArgs>(
      args?: SelectSubset<T, libreriasapisFindFirstOrThrowArgs>
    ): Prisma__libreriasapisClient<libreriasapisGetPayload<T>>

    /**
     * Find zero or more Libreriasapis that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {libreriasapisFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Libreriasapis
     * const libreriasapis = await prisma.libreriasapis.findMany()
     * 
     * // Get first 10 Libreriasapis
     * const libreriasapis = await prisma.libreriasapis.findMany({ take: 10 })
     * 
     * // Only select the `IDLIBAPISDK`
     * const libreriasapisWithIDLIBAPISDKOnly = await prisma.libreriasapis.findMany({ select: { IDLIBAPISDK: true } })
     * 
    **/
    findMany<T extends libreriasapisFindManyArgs>(
      args?: SelectSubset<T, libreriasapisFindManyArgs>
    ): PrismaPromise<Array<libreriasapisGetPayload<T>>>

    /**
     * Create a Libreriasapis.
     * @param {libreriasapisCreateArgs} args - Arguments to create a Libreriasapis.
     * @example
     * // Create one Libreriasapis
     * const Libreriasapis = await prisma.libreriasapis.create({
     *   data: {
     *     // ... data to create a Libreriasapis
     *   }
     * })
     * 
    **/
    create<T extends libreriasapisCreateArgs>(
      args: SelectSubset<T, libreriasapisCreateArgs>
    ): Prisma__libreriasapisClient<libreriasapisGetPayload<T>>

    /**
     * Create many Libreriasapis.
     *     @param {libreriasapisCreateManyArgs} args - Arguments to create many Libreriasapis.
     *     @example
     *     // Create many Libreriasapis
     *     const libreriasapis = await prisma.libreriasapis.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends libreriasapisCreateManyArgs>(
      args?: SelectSubset<T, libreriasapisCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Libreriasapis.
     * @param {libreriasapisDeleteArgs} args - Arguments to delete one Libreriasapis.
     * @example
     * // Delete one Libreriasapis
     * const Libreriasapis = await prisma.libreriasapis.delete({
     *   where: {
     *     // ... filter to delete one Libreriasapis
     *   }
     * })
     * 
    **/
    delete<T extends libreriasapisDeleteArgs>(
      args: SelectSubset<T, libreriasapisDeleteArgs>
    ): Prisma__libreriasapisClient<libreriasapisGetPayload<T>>

    /**
     * Update one Libreriasapis.
     * @param {libreriasapisUpdateArgs} args - Arguments to update one Libreriasapis.
     * @example
     * // Update one Libreriasapis
     * const libreriasapis = await prisma.libreriasapis.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends libreriasapisUpdateArgs>(
      args: SelectSubset<T, libreriasapisUpdateArgs>
    ): Prisma__libreriasapisClient<libreriasapisGetPayload<T>>

    /**
     * Delete zero or more Libreriasapis.
     * @param {libreriasapisDeleteManyArgs} args - Arguments to filter Libreriasapis to delete.
     * @example
     * // Delete a few Libreriasapis
     * const { count } = await prisma.libreriasapis.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends libreriasapisDeleteManyArgs>(
      args?: SelectSubset<T, libreriasapisDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Libreriasapis.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {libreriasapisUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Libreriasapis
     * const libreriasapis = await prisma.libreriasapis.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends libreriasapisUpdateManyArgs>(
      args: SelectSubset<T, libreriasapisUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Libreriasapis.
     * @param {libreriasapisUpsertArgs} args - Arguments to update or create a Libreriasapis.
     * @example
     * // Update or create a Libreriasapis
     * const libreriasapis = await prisma.libreriasapis.upsert({
     *   create: {
     *     // ... data to create a Libreriasapis
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Libreriasapis we want to update
     *   }
     * })
    **/
    upsert<T extends libreriasapisUpsertArgs>(
      args: SelectSubset<T, libreriasapisUpsertArgs>
    ): Prisma__libreriasapisClient<libreriasapisGetPayload<T>>

    /**
     * Count the number of Libreriasapis.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {libreriasapisCountArgs} args - Arguments to filter Libreriasapis to count.
     * @example
     * // Count the number of Libreriasapis
     * const count = await prisma.libreriasapis.count({
     *   where: {
     *     // ... the filter for the Libreriasapis we want to count
     *   }
     * })
    **/
    count<T extends libreriasapisCountArgs>(
      args?: Subset<T, libreriasapisCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LibreriasapisCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Libreriasapis.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LibreriasapisAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LibreriasapisAggregateArgs>(args: Subset<T, LibreriasapisAggregateArgs>): PrismaPromise<GetLibreriasapisAggregateType<T>>

    /**
     * Group by Libreriasapis.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LibreriasapisGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LibreriasapisGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LibreriasapisGroupByArgs['orderBy'] }
        : { orderBy?: LibreriasapisGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LibreriasapisGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLibreriasapisGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for libreriasapis.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__libreriasapisClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * libreriasapis base type for findUnique actions
   */
  export type libreriasapisFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the libreriasapis
     * 
    **/
    select?: libreriasapisSelect | null
    /**
     * Filter, which libreriasapis to fetch.
     * 
    **/
    where: libreriasapisWhereUniqueInput
  }

  /**
   * libreriasapis: findUnique
   */
  export interface libreriasapisFindUniqueArgs extends libreriasapisFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * libreriasapis findUniqueOrThrow
   */
  export type libreriasapisFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the libreriasapis
     * 
    **/
    select?: libreriasapisSelect | null
    /**
     * Filter, which libreriasapis to fetch.
     * 
    **/
    where: libreriasapisWhereUniqueInput
  }


  /**
   * libreriasapis base type for findFirst actions
   */
  export type libreriasapisFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the libreriasapis
     * 
    **/
    select?: libreriasapisSelect | null
    /**
     * Filter, which libreriasapis to fetch.
     * 
    **/
    where?: libreriasapisWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of libreriasapis to fetch.
     * 
    **/
    orderBy?: Enumerable<libreriasapisOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for libreriasapis.
     * 
    **/
    cursor?: libreriasapisWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` libreriasapis from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` libreriasapis.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of libreriasapis.
     * 
    **/
    distinct?: Enumerable<LibreriasapisScalarFieldEnum>
  }

  /**
   * libreriasapis: findFirst
   */
  export interface libreriasapisFindFirstArgs extends libreriasapisFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * libreriasapis findFirstOrThrow
   */
  export type libreriasapisFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the libreriasapis
     * 
    **/
    select?: libreriasapisSelect | null
    /**
     * Filter, which libreriasapis to fetch.
     * 
    **/
    where?: libreriasapisWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of libreriasapis to fetch.
     * 
    **/
    orderBy?: Enumerable<libreriasapisOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for libreriasapis.
     * 
    **/
    cursor?: libreriasapisWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` libreriasapis from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` libreriasapis.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of libreriasapis.
     * 
    **/
    distinct?: Enumerable<LibreriasapisScalarFieldEnum>
  }


  /**
   * libreriasapis findMany
   */
  export type libreriasapisFindManyArgs = {
    /**
     * Select specific fields to fetch from the libreriasapis
     * 
    **/
    select?: libreriasapisSelect | null
    /**
     * Filter, which libreriasapis to fetch.
     * 
    **/
    where?: libreriasapisWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of libreriasapis to fetch.
     * 
    **/
    orderBy?: Enumerable<libreriasapisOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing libreriasapis.
     * 
    **/
    cursor?: libreriasapisWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` libreriasapis from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` libreriasapis.
     * 
    **/
    skip?: number
    distinct?: Enumerable<LibreriasapisScalarFieldEnum>
  }


  /**
   * libreriasapis create
   */
  export type libreriasapisCreateArgs = {
    /**
     * Select specific fields to fetch from the libreriasapis
     * 
    **/
    select?: libreriasapisSelect | null
    /**
     * The data needed to create a libreriasapis.
     * 
    **/
    data: XOR<libreriasapisCreateInput, libreriasapisUncheckedCreateInput>
  }


  /**
   * libreriasapis createMany
   */
  export type libreriasapisCreateManyArgs = {
    /**
     * The data used to create many libreriasapis.
     * 
    **/
    data: Enumerable<libreriasapisCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * libreriasapis update
   */
  export type libreriasapisUpdateArgs = {
    /**
     * Select specific fields to fetch from the libreriasapis
     * 
    **/
    select?: libreriasapisSelect | null
    /**
     * The data needed to update a libreriasapis.
     * 
    **/
    data: XOR<libreriasapisUpdateInput, libreriasapisUncheckedUpdateInput>
    /**
     * Choose, which libreriasapis to update.
     * 
    **/
    where: libreriasapisWhereUniqueInput
  }


  /**
   * libreriasapis updateMany
   */
  export type libreriasapisUpdateManyArgs = {
    /**
     * The data used to update libreriasapis.
     * 
    **/
    data: XOR<libreriasapisUpdateManyMutationInput, libreriasapisUncheckedUpdateManyInput>
    /**
     * Filter which libreriasapis to update
     * 
    **/
    where?: libreriasapisWhereInput
  }


  /**
   * libreriasapis upsert
   */
  export type libreriasapisUpsertArgs = {
    /**
     * Select specific fields to fetch from the libreriasapis
     * 
    **/
    select?: libreriasapisSelect | null
    /**
     * The filter to search for the libreriasapis to update in case it exists.
     * 
    **/
    where: libreriasapisWhereUniqueInput
    /**
     * In case the libreriasapis found by the `where` argument doesn't exist, create a new libreriasapis with this data.
     * 
    **/
    create: XOR<libreriasapisCreateInput, libreriasapisUncheckedCreateInput>
    /**
     * In case the libreriasapis was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<libreriasapisUpdateInput, libreriasapisUncheckedUpdateInput>
  }


  /**
   * libreriasapis delete
   */
  export type libreriasapisDeleteArgs = {
    /**
     * Select specific fields to fetch from the libreriasapis
     * 
    **/
    select?: libreriasapisSelect | null
    /**
     * Filter which libreriasapis to delete.
     * 
    **/
    where: libreriasapisWhereUniqueInput
  }


  /**
   * libreriasapis deleteMany
   */
  export type libreriasapisDeleteManyArgs = {
    /**
     * Filter which libreriasapis to delete
     * 
    **/
    where?: libreriasapisWhereInput
  }


  /**
   * libreriasapis without action
   */
  export type libreriasapisArgs = {
    /**
     * Select specific fields to fetch from the libreriasapis
     * 
    **/
    select?: libreriasapisSelect | null
  }



  /**
   * Model metodogrupo
   */


  export type AggregateMetodogrupo = {
    _count: MetodogrupoCountAggregateOutputType | null
    _avg: MetodogrupoAvgAggregateOutputType | null
    _sum: MetodogrupoSumAggregateOutputType | null
    _min: MetodogrupoMinAggregateOutputType | null
    _max: MetodogrupoMaxAggregateOutputType | null
  }

  export type MetodogrupoAvgAggregateOutputType = {
    IDGrupoMetodo: number | null
    IDGrupoMetodoPadre: number | null
  }

  export type MetodogrupoSumAggregateOutputType = {
    IDGrupoMetodo: number | null
    IDGrupoMetodoPadre: number | null
  }

  export type MetodogrupoMinAggregateOutputType = {
    IDGrupoMetodo: number | null
    NombreGrupoMetodo: string | null
    Corporacion: string | null
    Departamento: string | null
    Edificio: string | null
    Itinerario: string | null
    Empleado: string | null
    Modificable: string | null
    Descripcion: string | null
    Tipo: string | null
    IDGrupoMetodoPadre: number | null
    Identificador: string | null
    IdentificadorExterno: string | null
  }

  export type MetodogrupoMaxAggregateOutputType = {
    IDGrupoMetodo: number | null
    NombreGrupoMetodo: string | null
    Corporacion: string | null
    Departamento: string | null
    Edificio: string | null
    Itinerario: string | null
    Empleado: string | null
    Modificable: string | null
    Descripcion: string | null
    Tipo: string | null
    IDGrupoMetodoPadre: number | null
    Identificador: string | null
    IdentificadorExterno: string | null
  }

  export type MetodogrupoCountAggregateOutputType = {
    IDGrupoMetodo: number
    NombreGrupoMetodo: number
    Corporacion: number
    Departamento: number
    Edificio: number
    Itinerario: number
    Empleado: number
    Modificable: number
    Descripcion: number
    Tipo: number
    IDGrupoMetodoPadre: number
    Identificador: number
    IdentificadorExterno: number
    _all: number
  }


  export type MetodogrupoAvgAggregateInputType = {
    IDGrupoMetodo?: true
    IDGrupoMetodoPadre?: true
  }

  export type MetodogrupoSumAggregateInputType = {
    IDGrupoMetodo?: true
    IDGrupoMetodoPadre?: true
  }

  export type MetodogrupoMinAggregateInputType = {
    IDGrupoMetodo?: true
    NombreGrupoMetodo?: true
    Corporacion?: true
    Departamento?: true
    Edificio?: true
    Itinerario?: true
    Empleado?: true
    Modificable?: true
    Descripcion?: true
    Tipo?: true
    IDGrupoMetodoPadre?: true
    Identificador?: true
    IdentificadorExterno?: true
  }

  export type MetodogrupoMaxAggregateInputType = {
    IDGrupoMetodo?: true
    NombreGrupoMetodo?: true
    Corporacion?: true
    Departamento?: true
    Edificio?: true
    Itinerario?: true
    Empleado?: true
    Modificable?: true
    Descripcion?: true
    Tipo?: true
    IDGrupoMetodoPadre?: true
    Identificador?: true
    IdentificadorExterno?: true
  }

  export type MetodogrupoCountAggregateInputType = {
    IDGrupoMetodo?: true
    NombreGrupoMetodo?: true
    Corporacion?: true
    Departamento?: true
    Edificio?: true
    Itinerario?: true
    Empleado?: true
    Modificable?: true
    Descripcion?: true
    Tipo?: true
    IDGrupoMetodoPadre?: true
    Identificador?: true
    IdentificadorExterno?: true
    _all?: true
  }

  export type MetodogrupoAggregateArgs = {
    /**
     * Filter which metodogrupo to aggregate.
     * 
    **/
    where?: metodogrupoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of metodogrupos to fetch.
     * 
    **/
    orderBy?: Enumerable<metodogrupoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: metodogrupoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` metodogrupos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` metodogrupos.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned metodogrupos
    **/
    _count?: true | MetodogrupoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MetodogrupoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MetodogrupoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MetodogrupoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MetodogrupoMaxAggregateInputType
  }

  export type GetMetodogrupoAggregateType<T extends MetodogrupoAggregateArgs> = {
        [P in keyof T & keyof AggregateMetodogrupo]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMetodogrupo[P]>
      : GetScalarType<T[P], AggregateMetodogrupo[P]>
  }




  export type MetodogrupoGroupByArgs = {
    where?: metodogrupoWhereInput
    orderBy?: Enumerable<metodogrupoOrderByWithAggregationInput>
    by: Array<MetodogrupoScalarFieldEnum>
    having?: metodogrupoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MetodogrupoCountAggregateInputType | true
    _avg?: MetodogrupoAvgAggregateInputType
    _sum?: MetodogrupoSumAggregateInputType
    _min?: MetodogrupoMinAggregateInputType
    _max?: MetodogrupoMaxAggregateInputType
  }


  export type MetodogrupoGroupByOutputType = {
    IDGrupoMetodo: number
    NombreGrupoMetodo: string | null
    Corporacion: string | null
    Departamento: string | null
    Edificio: string | null
    Itinerario: string | null
    Empleado: string | null
    Modificable: string | null
    Descripcion: string | null
    Tipo: string | null
    IDGrupoMetodoPadre: number | null
    Identificador: string | null
    IdentificadorExterno: string | null
    _count: MetodogrupoCountAggregateOutputType | null
    _avg: MetodogrupoAvgAggregateOutputType | null
    _sum: MetodogrupoSumAggregateOutputType | null
    _min: MetodogrupoMinAggregateOutputType | null
    _max: MetodogrupoMaxAggregateOutputType | null
  }

  type GetMetodogrupoGroupByPayload<T extends MetodogrupoGroupByArgs> = PrismaPromise<
    Array<
      PickArray<MetodogrupoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MetodogrupoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MetodogrupoGroupByOutputType[P]>
            : GetScalarType<T[P], MetodogrupoGroupByOutputType[P]>
        }
      >
    >


  export type metodogrupoSelect = {
    IDGrupoMetodo?: boolean
    NombreGrupoMetodo?: boolean
    Corporacion?: boolean
    Departamento?: boolean
    Edificio?: boolean
    Itinerario?: boolean
    Empleado?: boolean
    Modificable?: boolean
    Descripcion?: boolean
    Tipo?: boolean
    IDGrupoMetodoPadre?: boolean
    Identificador?: boolean
    IdentificadorExterno?: boolean
  }


  export type metodogrupoGetPayload<S extends boolean | null | undefined | metodogrupoArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? metodogrupo :
    S extends undefined ? never :
    S extends { include: any } & (metodogrupoArgs | metodogrupoFindManyArgs)
    ? metodogrupo 
    : S extends { select: any } & (metodogrupoArgs | metodogrupoFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof metodogrupo ? metodogrupo[P] : never
  } 
      : metodogrupo


  type metodogrupoCountArgs = Merge<
    Omit<metodogrupoFindManyArgs, 'select' | 'include'> & {
      select?: MetodogrupoCountAggregateInputType | true
    }
  >

  export interface metodogrupoDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Metodogrupo that matches the filter.
     * @param {metodogrupoFindUniqueArgs} args - Arguments to find a Metodogrupo
     * @example
     * // Get one Metodogrupo
     * const metodogrupo = await prisma.metodogrupo.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends metodogrupoFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, metodogrupoFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'metodogrupo'> extends True ? Prisma__metodogrupoClient<metodogrupoGetPayload<T>> : Prisma__metodogrupoClient<metodogrupoGetPayload<T> | null, null>

    /**
     * Find one Metodogrupo that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {metodogrupoFindUniqueOrThrowArgs} args - Arguments to find a Metodogrupo
     * @example
     * // Get one Metodogrupo
     * const metodogrupo = await prisma.metodogrupo.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends metodogrupoFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, metodogrupoFindUniqueOrThrowArgs>
    ): Prisma__metodogrupoClient<metodogrupoGetPayload<T>>

    /**
     * Find the first Metodogrupo that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {metodogrupoFindFirstArgs} args - Arguments to find a Metodogrupo
     * @example
     * // Get one Metodogrupo
     * const metodogrupo = await prisma.metodogrupo.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends metodogrupoFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, metodogrupoFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'metodogrupo'> extends True ? Prisma__metodogrupoClient<metodogrupoGetPayload<T>> : Prisma__metodogrupoClient<metodogrupoGetPayload<T> | null, null>

    /**
     * Find the first Metodogrupo that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {metodogrupoFindFirstOrThrowArgs} args - Arguments to find a Metodogrupo
     * @example
     * // Get one Metodogrupo
     * const metodogrupo = await prisma.metodogrupo.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends metodogrupoFindFirstOrThrowArgs>(
      args?: SelectSubset<T, metodogrupoFindFirstOrThrowArgs>
    ): Prisma__metodogrupoClient<metodogrupoGetPayload<T>>

    /**
     * Find zero or more Metodogrupos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {metodogrupoFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Metodogrupos
     * const metodogrupos = await prisma.metodogrupo.findMany()
     * 
     * // Get first 10 Metodogrupos
     * const metodogrupos = await prisma.metodogrupo.findMany({ take: 10 })
     * 
     * // Only select the `IDGrupoMetodo`
     * const metodogrupoWithIDGrupoMetodoOnly = await prisma.metodogrupo.findMany({ select: { IDGrupoMetodo: true } })
     * 
    **/
    findMany<T extends metodogrupoFindManyArgs>(
      args?: SelectSubset<T, metodogrupoFindManyArgs>
    ): PrismaPromise<Array<metodogrupoGetPayload<T>>>

    /**
     * Create a Metodogrupo.
     * @param {metodogrupoCreateArgs} args - Arguments to create a Metodogrupo.
     * @example
     * // Create one Metodogrupo
     * const Metodogrupo = await prisma.metodogrupo.create({
     *   data: {
     *     // ... data to create a Metodogrupo
     *   }
     * })
     * 
    **/
    create<T extends metodogrupoCreateArgs>(
      args: SelectSubset<T, metodogrupoCreateArgs>
    ): Prisma__metodogrupoClient<metodogrupoGetPayload<T>>

    /**
     * Create many Metodogrupos.
     *     @param {metodogrupoCreateManyArgs} args - Arguments to create many Metodogrupos.
     *     @example
     *     // Create many Metodogrupos
     *     const metodogrupo = await prisma.metodogrupo.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends metodogrupoCreateManyArgs>(
      args?: SelectSubset<T, metodogrupoCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Metodogrupo.
     * @param {metodogrupoDeleteArgs} args - Arguments to delete one Metodogrupo.
     * @example
     * // Delete one Metodogrupo
     * const Metodogrupo = await prisma.metodogrupo.delete({
     *   where: {
     *     // ... filter to delete one Metodogrupo
     *   }
     * })
     * 
    **/
    delete<T extends metodogrupoDeleteArgs>(
      args: SelectSubset<T, metodogrupoDeleteArgs>
    ): Prisma__metodogrupoClient<metodogrupoGetPayload<T>>

    /**
     * Update one Metodogrupo.
     * @param {metodogrupoUpdateArgs} args - Arguments to update one Metodogrupo.
     * @example
     * // Update one Metodogrupo
     * const metodogrupo = await prisma.metodogrupo.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends metodogrupoUpdateArgs>(
      args: SelectSubset<T, metodogrupoUpdateArgs>
    ): Prisma__metodogrupoClient<metodogrupoGetPayload<T>>

    /**
     * Delete zero or more Metodogrupos.
     * @param {metodogrupoDeleteManyArgs} args - Arguments to filter Metodogrupos to delete.
     * @example
     * // Delete a few Metodogrupos
     * const { count } = await prisma.metodogrupo.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends metodogrupoDeleteManyArgs>(
      args?: SelectSubset<T, metodogrupoDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Metodogrupos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {metodogrupoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Metodogrupos
     * const metodogrupo = await prisma.metodogrupo.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends metodogrupoUpdateManyArgs>(
      args: SelectSubset<T, metodogrupoUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Metodogrupo.
     * @param {metodogrupoUpsertArgs} args - Arguments to update or create a Metodogrupo.
     * @example
     * // Update or create a Metodogrupo
     * const metodogrupo = await prisma.metodogrupo.upsert({
     *   create: {
     *     // ... data to create a Metodogrupo
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Metodogrupo we want to update
     *   }
     * })
    **/
    upsert<T extends metodogrupoUpsertArgs>(
      args: SelectSubset<T, metodogrupoUpsertArgs>
    ): Prisma__metodogrupoClient<metodogrupoGetPayload<T>>

    /**
     * Count the number of Metodogrupos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {metodogrupoCountArgs} args - Arguments to filter Metodogrupos to count.
     * @example
     * // Count the number of Metodogrupos
     * const count = await prisma.metodogrupo.count({
     *   where: {
     *     // ... the filter for the Metodogrupos we want to count
     *   }
     * })
    **/
    count<T extends metodogrupoCountArgs>(
      args?: Subset<T, metodogrupoCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MetodogrupoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Metodogrupo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MetodogrupoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MetodogrupoAggregateArgs>(args: Subset<T, MetodogrupoAggregateArgs>): PrismaPromise<GetMetodogrupoAggregateType<T>>

    /**
     * Group by Metodogrupo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MetodogrupoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MetodogrupoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MetodogrupoGroupByArgs['orderBy'] }
        : { orderBy?: MetodogrupoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MetodogrupoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMetodogrupoGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for metodogrupo.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__metodogrupoClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * metodogrupo base type for findUnique actions
   */
  export type metodogrupoFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the metodogrupo
     * 
    **/
    select?: metodogrupoSelect | null
    /**
     * Filter, which metodogrupo to fetch.
     * 
    **/
    where: metodogrupoWhereUniqueInput
  }

  /**
   * metodogrupo: findUnique
   */
  export interface metodogrupoFindUniqueArgs extends metodogrupoFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * metodogrupo findUniqueOrThrow
   */
  export type metodogrupoFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the metodogrupo
     * 
    **/
    select?: metodogrupoSelect | null
    /**
     * Filter, which metodogrupo to fetch.
     * 
    **/
    where: metodogrupoWhereUniqueInput
  }


  /**
   * metodogrupo base type for findFirst actions
   */
  export type metodogrupoFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the metodogrupo
     * 
    **/
    select?: metodogrupoSelect | null
    /**
     * Filter, which metodogrupo to fetch.
     * 
    **/
    where?: metodogrupoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of metodogrupos to fetch.
     * 
    **/
    orderBy?: Enumerable<metodogrupoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for metodogrupos.
     * 
    **/
    cursor?: metodogrupoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` metodogrupos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` metodogrupos.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of metodogrupos.
     * 
    **/
    distinct?: Enumerable<MetodogrupoScalarFieldEnum>
  }

  /**
   * metodogrupo: findFirst
   */
  export interface metodogrupoFindFirstArgs extends metodogrupoFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * metodogrupo findFirstOrThrow
   */
  export type metodogrupoFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the metodogrupo
     * 
    **/
    select?: metodogrupoSelect | null
    /**
     * Filter, which metodogrupo to fetch.
     * 
    **/
    where?: metodogrupoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of metodogrupos to fetch.
     * 
    **/
    orderBy?: Enumerable<metodogrupoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for metodogrupos.
     * 
    **/
    cursor?: metodogrupoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` metodogrupos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` metodogrupos.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of metodogrupos.
     * 
    **/
    distinct?: Enumerable<MetodogrupoScalarFieldEnum>
  }


  /**
   * metodogrupo findMany
   */
  export type metodogrupoFindManyArgs = {
    /**
     * Select specific fields to fetch from the metodogrupo
     * 
    **/
    select?: metodogrupoSelect | null
    /**
     * Filter, which metodogrupos to fetch.
     * 
    **/
    where?: metodogrupoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of metodogrupos to fetch.
     * 
    **/
    orderBy?: Enumerable<metodogrupoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing metodogrupos.
     * 
    **/
    cursor?: metodogrupoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` metodogrupos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` metodogrupos.
     * 
    **/
    skip?: number
    distinct?: Enumerable<MetodogrupoScalarFieldEnum>
  }


  /**
   * metodogrupo create
   */
  export type metodogrupoCreateArgs = {
    /**
     * Select specific fields to fetch from the metodogrupo
     * 
    **/
    select?: metodogrupoSelect | null
    /**
     * The data needed to create a metodogrupo.
     * 
    **/
    data: XOR<metodogrupoCreateInput, metodogrupoUncheckedCreateInput>
  }


  /**
   * metodogrupo createMany
   */
  export type metodogrupoCreateManyArgs = {
    /**
     * The data used to create many metodogrupos.
     * 
    **/
    data: Enumerable<metodogrupoCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * metodogrupo update
   */
  export type metodogrupoUpdateArgs = {
    /**
     * Select specific fields to fetch from the metodogrupo
     * 
    **/
    select?: metodogrupoSelect | null
    /**
     * The data needed to update a metodogrupo.
     * 
    **/
    data: XOR<metodogrupoUpdateInput, metodogrupoUncheckedUpdateInput>
    /**
     * Choose, which metodogrupo to update.
     * 
    **/
    where: metodogrupoWhereUniqueInput
  }


  /**
   * metodogrupo updateMany
   */
  export type metodogrupoUpdateManyArgs = {
    /**
     * The data used to update metodogrupos.
     * 
    **/
    data: XOR<metodogrupoUpdateManyMutationInput, metodogrupoUncheckedUpdateManyInput>
    /**
     * Filter which metodogrupos to update
     * 
    **/
    where?: metodogrupoWhereInput
  }


  /**
   * metodogrupo upsert
   */
  export type metodogrupoUpsertArgs = {
    /**
     * Select specific fields to fetch from the metodogrupo
     * 
    **/
    select?: metodogrupoSelect | null
    /**
     * The filter to search for the metodogrupo to update in case it exists.
     * 
    **/
    where: metodogrupoWhereUniqueInput
    /**
     * In case the metodogrupo found by the `where` argument doesn't exist, create a new metodogrupo with this data.
     * 
    **/
    create: XOR<metodogrupoCreateInput, metodogrupoUncheckedCreateInput>
    /**
     * In case the metodogrupo was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<metodogrupoUpdateInput, metodogrupoUncheckedUpdateInput>
  }


  /**
   * metodogrupo delete
   */
  export type metodogrupoDeleteArgs = {
    /**
     * Select specific fields to fetch from the metodogrupo
     * 
    **/
    select?: metodogrupoSelect | null
    /**
     * Filter which metodogrupo to delete.
     * 
    **/
    where: metodogrupoWhereUniqueInput
  }


  /**
   * metodogrupo deleteMany
   */
  export type metodogrupoDeleteManyArgs = {
    /**
     * Filter which metodogrupos to delete
     * 
    **/
    where?: metodogrupoWhereInput
  }


  /**
   * metodogrupo without action
   */
  export type metodogrupoArgs = {
    /**
     * Select specific fields to fetch from the metodogrupo
     * 
    **/
    select?: metodogrupoSelect | null
  }



  /**
   * Model metodos
   */


  export type AggregateMetodos = {
    _count: MetodosCountAggregateOutputType | null
    _avg: MetodosAvgAggregateOutputType | null
    _sum: MetodosSumAggregateOutputType | null
    _min: MetodosMinAggregateOutputType | null
    _max: MetodosMaxAggregateOutputType | null
  }

  export type MetodosAvgAggregateOutputType = {
    IDMetodo: number | null
    Indice: number | null
    IDGrupoMetodo: number | null
    IDLibreria: number | null
    IDMetodoPadre: number | null
    NParametros: number | null
    NParametrosBinarios: number | null
  }

  export type MetodosSumAggregateOutputType = {
    IDMetodo: number | null
    Indice: number | null
    IDGrupoMetodo: number | null
    IDLibreria: number | null
    IDMetodoPadre: number | null
    NParametros: number | null
    NParametrosBinarios: number | null
  }

  export type MetodosMinAggregateOutputType = {
    IDMetodo: number | null
    Indice: number | null
    IDGrupoMetodo: number | null
    IDLibreria: number | null
    IDMetodoPadre: number | null
    Clase: string | null
    Tipo: string | null
    Propagable: string | null
    BlobsPropagable: string | null
    NParametros: number | null
    NParametrosBinarios: number | null
    Basico: string | null
    Estado: string | null
    Descripcion: string | null
    NombreMetodo: string | null
    NombreFuncion: string | null
    MetodoTrigger: string | null
    EnvioAplicacion: string | null
    EjecucionLibre: string | null
  }

  export type MetodosMaxAggregateOutputType = {
    IDMetodo: number | null
    Indice: number | null
    IDGrupoMetodo: number | null
    IDLibreria: number | null
    IDMetodoPadre: number | null
    Clase: string | null
    Tipo: string | null
    Propagable: string | null
    BlobsPropagable: string | null
    NParametros: number | null
    NParametrosBinarios: number | null
    Basico: string | null
    Estado: string | null
    Descripcion: string | null
    NombreMetodo: string | null
    NombreFuncion: string | null
    MetodoTrigger: string | null
    EnvioAplicacion: string | null
    EjecucionLibre: string | null
  }

  export type MetodosCountAggregateOutputType = {
    IDMetodo: number
    Indice: number
    IDGrupoMetodo: number
    IDLibreria: number
    IDMetodoPadre: number
    Clase: number
    Tipo: number
    Propagable: number
    BlobsPropagable: number
    NParametros: number
    NParametrosBinarios: number
    Basico: number
    Estado: number
    Descripcion: number
    NombreMetodo: number
    NombreFuncion: number
    MetodoTrigger: number
    EnvioAplicacion: number
    EjecucionLibre: number
    _all: number
  }


  export type MetodosAvgAggregateInputType = {
    IDMetodo?: true
    Indice?: true
    IDGrupoMetodo?: true
    IDLibreria?: true
    IDMetodoPadre?: true
    NParametros?: true
    NParametrosBinarios?: true
  }

  export type MetodosSumAggregateInputType = {
    IDMetodo?: true
    Indice?: true
    IDGrupoMetodo?: true
    IDLibreria?: true
    IDMetodoPadre?: true
    NParametros?: true
    NParametrosBinarios?: true
  }

  export type MetodosMinAggregateInputType = {
    IDMetodo?: true
    Indice?: true
    IDGrupoMetodo?: true
    IDLibreria?: true
    IDMetodoPadre?: true
    Clase?: true
    Tipo?: true
    Propagable?: true
    BlobsPropagable?: true
    NParametros?: true
    NParametrosBinarios?: true
    Basico?: true
    Estado?: true
    Descripcion?: true
    NombreMetodo?: true
    NombreFuncion?: true
    MetodoTrigger?: true
    EnvioAplicacion?: true
    EjecucionLibre?: true
  }

  export type MetodosMaxAggregateInputType = {
    IDMetodo?: true
    Indice?: true
    IDGrupoMetodo?: true
    IDLibreria?: true
    IDMetodoPadre?: true
    Clase?: true
    Tipo?: true
    Propagable?: true
    BlobsPropagable?: true
    NParametros?: true
    NParametrosBinarios?: true
    Basico?: true
    Estado?: true
    Descripcion?: true
    NombreMetodo?: true
    NombreFuncion?: true
    MetodoTrigger?: true
    EnvioAplicacion?: true
    EjecucionLibre?: true
  }

  export type MetodosCountAggregateInputType = {
    IDMetodo?: true
    Indice?: true
    IDGrupoMetodo?: true
    IDLibreria?: true
    IDMetodoPadre?: true
    Clase?: true
    Tipo?: true
    Propagable?: true
    BlobsPropagable?: true
    NParametros?: true
    NParametrosBinarios?: true
    Basico?: true
    Estado?: true
    Descripcion?: true
    NombreMetodo?: true
    NombreFuncion?: true
    MetodoTrigger?: true
    EnvioAplicacion?: true
    EjecucionLibre?: true
    _all?: true
  }

  export type MetodosAggregateArgs = {
    /**
     * Filter which metodos to aggregate.
     * 
    **/
    where?: metodosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of metodos to fetch.
     * 
    **/
    orderBy?: Enumerable<metodosOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: metodosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` metodos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` metodos.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned metodos
    **/
    _count?: true | MetodosCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MetodosAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MetodosSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MetodosMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MetodosMaxAggregateInputType
  }

  export type GetMetodosAggregateType<T extends MetodosAggregateArgs> = {
        [P in keyof T & keyof AggregateMetodos]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMetodos[P]>
      : GetScalarType<T[P], AggregateMetodos[P]>
  }




  export type MetodosGroupByArgs = {
    where?: metodosWhereInput
    orderBy?: Enumerable<metodosOrderByWithAggregationInput>
    by: Array<MetodosScalarFieldEnum>
    having?: metodosScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MetodosCountAggregateInputType | true
    _avg?: MetodosAvgAggregateInputType
    _sum?: MetodosSumAggregateInputType
    _min?: MetodosMinAggregateInputType
    _max?: MetodosMaxAggregateInputType
  }


  export type MetodosGroupByOutputType = {
    IDMetodo: number
    Indice: number
    IDGrupoMetodo: number
    IDLibreria: number | null
    IDMetodoPadre: number | null
    Clase: string
    Tipo: string
    Propagable: string
    BlobsPropagable: string
    NParametros: number
    NParametrosBinarios: number
    Basico: string
    Estado: string
    Descripcion: string | null
    NombreMetodo: string | null
    NombreFuncion: string | null
    MetodoTrigger: string | null
    EnvioAplicacion: string
    EjecucionLibre: string
    _count: MetodosCountAggregateOutputType | null
    _avg: MetodosAvgAggregateOutputType | null
    _sum: MetodosSumAggregateOutputType | null
    _min: MetodosMinAggregateOutputType | null
    _max: MetodosMaxAggregateOutputType | null
  }

  type GetMetodosGroupByPayload<T extends MetodosGroupByArgs> = PrismaPromise<
    Array<
      PickArray<MetodosGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MetodosGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MetodosGroupByOutputType[P]>
            : GetScalarType<T[P], MetodosGroupByOutputType[P]>
        }
      >
    >


  export type metodosSelect = {
    IDMetodo?: boolean
    Indice?: boolean
    IDGrupoMetodo?: boolean
    IDLibreria?: boolean
    IDMetodoPadre?: boolean
    Clase?: boolean
    Tipo?: boolean
    Propagable?: boolean
    BlobsPropagable?: boolean
    NParametros?: boolean
    NParametrosBinarios?: boolean
    Basico?: boolean
    Estado?: boolean
    Descripcion?: boolean
    NombreMetodo?: boolean
    NombreFuncion?: boolean
    MetodoTrigger?: boolean
    EnvioAplicacion?: boolean
    EjecucionLibre?: boolean
  }


  export type metodosGetPayload<S extends boolean | null | undefined | metodosArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? metodos :
    S extends undefined ? never :
    S extends { include: any } & (metodosArgs | metodosFindManyArgs)
    ? metodos 
    : S extends { select: any } & (metodosArgs | metodosFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof metodos ? metodos[P] : never
  } 
      : metodos


  type metodosCountArgs = Merge<
    Omit<metodosFindManyArgs, 'select' | 'include'> & {
      select?: MetodosCountAggregateInputType | true
    }
  >

  export interface metodosDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Metodos that matches the filter.
     * @param {metodosFindUniqueArgs} args - Arguments to find a Metodos
     * @example
     * // Get one Metodos
     * const metodos = await prisma.metodos.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends metodosFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, metodosFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'metodos'> extends True ? Prisma__metodosClient<metodosGetPayload<T>> : Prisma__metodosClient<metodosGetPayload<T> | null, null>

    /**
     * Find one Metodos that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {metodosFindUniqueOrThrowArgs} args - Arguments to find a Metodos
     * @example
     * // Get one Metodos
     * const metodos = await prisma.metodos.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends metodosFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, metodosFindUniqueOrThrowArgs>
    ): Prisma__metodosClient<metodosGetPayload<T>>

    /**
     * Find the first Metodos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {metodosFindFirstArgs} args - Arguments to find a Metodos
     * @example
     * // Get one Metodos
     * const metodos = await prisma.metodos.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends metodosFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, metodosFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'metodos'> extends True ? Prisma__metodosClient<metodosGetPayload<T>> : Prisma__metodosClient<metodosGetPayload<T> | null, null>

    /**
     * Find the first Metodos that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {metodosFindFirstOrThrowArgs} args - Arguments to find a Metodos
     * @example
     * // Get one Metodos
     * const metodos = await prisma.metodos.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends metodosFindFirstOrThrowArgs>(
      args?: SelectSubset<T, metodosFindFirstOrThrowArgs>
    ): Prisma__metodosClient<metodosGetPayload<T>>

    /**
     * Find zero or more Metodos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {metodosFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Metodos
     * const metodos = await prisma.metodos.findMany()
     * 
     * // Get first 10 Metodos
     * const metodos = await prisma.metodos.findMany({ take: 10 })
     * 
     * // Only select the `IDMetodo`
     * const metodosWithIDMetodoOnly = await prisma.metodos.findMany({ select: { IDMetodo: true } })
     * 
    **/
    findMany<T extends metodosFindManyArgs>(
      args?: SelectSubset<T, metodosFindManyArgs>
    ): PrismaPromise<Array<metodosGetPayload<T>>>

    /**
     * Create a Metodos.
     * @param {metodosCreateArgs} args - Arguments to create a Metodos.
     * @example
     * // Create one Metodos
     * const Metodos = await prisma.metodos.create({
     *   data: {
     *     // ... data to create a Metodos
     *   }
     * })
     * 
    **/
    create<T extends metodosCreateArgs>(
      args: SelectSubset<T, metodosCreateArgs>
    ): Prisma__metodosClient<metodosGetPayload<T>>

    /**
     * Create many Metodos.
     *     @param {metodosCreateManyArgs} args - Arguments to create many Metodos.
     *     @example
     *     // Create many Metodos
     *     const metodos = await prisma.metodos.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends metodosCreateManyArgs>(
      args?: SelectSubset<T, metodosCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Metodos.
     * @param {metodosDeleteArgs} args - Arguments to delete one Metodos.
     * @example
     * // Delete one Metodos
     * const Metodos = await prisma.metodos.delete({
     *   where: {
     *     // ... filter to delete one Metodos
     *   }
     * })
     * 
    **/
    delete<T extends metodosDeleteArgs>(
      args: SelectSubset<T, metodosDeleteArgs>
    ): Prisma__metodosClient<metodosGetPayload<T>>

    /**
     * Update one Metodos.
     * @param {metodosUpdateArgs} args - Arguments to update one Metodos.
     * @example
     * // Update one Metodos
     * const metodos = await prisma.metodos.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends metodosUpdateArgs>(
      args: SelectSubset<T, metodosUpdateArgs>
    ): Prisma__metodosClient<metodosGetPayload<T>>

    /**
     * Delete zero or more Metodos.
     * @param {metodosDeleteManyArgs} args - Arguments to filter Metodos to delete.
     * @example
     * // Delete a few Metodos
     * const { count } = await prisma.metodos.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends metodosDeleteManyArgs>(
      args?: SelectSubset<T, metodosDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Metodos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {metodosUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Metodos
     * const metodos = await prisma.metodos.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends metodosUpdateManyArgs>(
      args: SelectSubset<T, metodosUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Metodos.
     * @param {metodosUpsertArgs} args - Arguments to update or create a Metodos.
     * @example
     * // Update or create a Metodos
     * const metodos = await prisma.metodos.upsert({
     *   create: {
     *     // ... data to create a Metodos
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Metodos we want to update
     *   }
     * })
    **/
    upsert<T extends metodosUpsertArgs>(
      args: SelectSubset<T, metodosUpsertArgs>
    ): Prisma__metodosClient<metodosGetPayload<T>>

    /**
     * Count the number of Metodos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {metodosCountArgs} args - Arguments to filter Metodos to count.
     * @example
     * // Count the number of Metodos
     * const count = await prisma.metodos.count({
     *   where: {
     *     // ... the filter for the Metodos we want to count
     *   }
     * })
    **/
    count<T extends metodosCountArgs>(
      args?: Subset<T, metodosCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MetodosCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Metodos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MetodosAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MetodosAggregateArgs>(args: Subset<T, MetodosAggregateArgs>): PrismaPromise<GetMetodosAggregateType<T>>

    /**
     * Group by Metodos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MetodosGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MetodosGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MetodosGroupByArgs['orderBy'] }
        : { orderBy?: MetodosGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MetodosGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMetodosGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for metodos.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__metodosClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * metodos base type for findUnique actions
   */
  export type metodosFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the metodos
     * 
    **/
    select?: metodosSelect | null
    /**
     * Filter, which metodos to fetch.
     * 
    **/
    where: metodosWhereUniqueInput
  }

  /**
   * metodos: findUnique
   */
  export interface metodosFindUniqueArgs extends metodosFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * metodos findUniqueOrThrow
   */
  export type metodosFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the metodos
     * 
    **/
    select?: metodosSelect | null
    /**
     * Filter, which metodos to fetch.
     * 
    **/
    where: metodosWhereUniqueInput
  }


  /**
   * metodos base type for findFirst actions
   */
  export type metodosFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the metodos
     * 
    **/
    select?: metodosSelect | null
    /**
     * Filter, which metodos to fetch.
     * 
    **/
    where?: metodosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of metodos to fetch.
     * 
    **/
    orderBy?: Enumerable<metodosOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for metodos.
     * 
    **/
    cursor?: metodosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` metodos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` metodos.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of metodos.
     * 
    **/
    distinct?: Enumerable<MetodosScalarFieldEnum>
  }

  /**
   * metodos: findFirst
   */
  export interface metodosFindFirstArgs extends metodosFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * metodos findFirstOrThrow
   */
  export type metodosFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the metodos
     * 
    **/
    select?: metodosSelect | null
    /**
     * Filter, which metodos to fetch.
     * 
    **/
    where?: metodosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of metodos to fetch.
     * 
    **/
    orderBy?: Enumerable<metodosOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for metodos.
     * 
    **/
    cursor?: metodosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` metodos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` metodos.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of metodos.
     * 
    **/
    distinct?: Enumerable<MetodosScalarFieldEnum>
  }


  /**
   * metodos findMany
   */
  export type metodosFindManyArgs = {
    /**
     * Select specific fields to fetch from the metodos
     * 
    **/
    select?: metodosSelect | null
    /**
     * Filter, which metodos to fetch.
     * 
    **/
    where?: metodosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of metodos to fetch.
     * 
    **/
    orderBy?: Enumerable<metodosOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing metodos.
     * 
    **/
    cursor?: metodosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` metodos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` metodos.
     * 
    **/
    skip?: number
    distinct?: Enumerable<MetodosScalarFieldEnum>
  }


  /**
   * metodos create
   */
  export type metodosCreateArgs = {
    /**
     * Select specific fields to fetch from the metodos
     * 
    **/
    select?: metodosSelect | null
    /**
     * The data needed to create a metodos.
     * 
    **/
    data: XOR<metodosCreateInput, metodosUncheckedCreateInput>
  }


  /**
   * metodos createMany
   */
  export type metodosCreateManyArgs = {
    /**
     * The data used to create many metodos.
     * 
    **/
    data: Enumerable<metodosCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * metodos update
   */
  export type metodosUpdateArgs = {
    /**
     * Select specific fields to fetch from the metodos
     * 
    **/
    select?: metodosSelect | null
    /**
     * The data needed to update a metodos.
     * 
    **/
    data: XOR<metodosUpdateInput, metodosUncheckedUpdateInput>
    /**
     * Choose, which metodos to update.
     * 
    **/
    where: metodosWhereUniqueInput
  }


  /**
   * metodos updateMany
   */
  export type metodosUpdateManyArgs = {
    /**
     * The data used to update metodos.
     * 
    **/
    data: XOR<metodosUpdateManyMutationInput, metodosUncheckedUpdateManyInput>
    /**
     * Filter which metodos to update
     * 
    **/
    where?: metodosWhereInput
  }


  /**
   * metodos upsert
   */
  export type metodosUpsertArgs = {
    /**
     * Select specific fields to fetch from the metodos
     * 
    **/
    select?: metodosSelect | null
    /**
     * The filter to search for the metodos to update in case it exists.
     * 
    **/
    where: metodosWhereUniqueInput
    /**
     * In case the metodos found by the `where` argument doesn't exist, create a new metodos with this data.
     * 
    **/
    create: XOR<metodosCreateInput, metodosUncheckedCreateInput>
    /**
     * In case the metodos was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<metodosUpdateInput, metodosUncheckedUpdateInput>
  }


  /**
   * metodos delete
   */
  export type metodosDeleteArgs = {
    /**
     * Select specific fields to fetch from the metodos
     * 
    **/
    select?: metodosSelect | null
    /**
     * Filter which metodos to delete.
     * 
    **/
    where: metodosWhereUniqueInput
  }


  /**
   * metodos deleteMany
   */
  export type metodosDeleteManyArgs = {
    /**
     * Filter which metodos to delete
     * 
    **/
    where?: metodosWhereInput
  }


  /**
   * metodos without action
   */
  export type metodosArgs = {
    /**
     * Select specific fields to fetch from the metodos
     * 
    **/
    select?: metodosSelect | null
  }



  /**
   * Model objetosplanimetria
   */


  export type AggregateObjetosplanimetria = {
    _count: ObjetosplanimetriaCountAggregateOutputType | null
    _avg: ObjetosplanimetriaAvgAggregateOutputType | null
    _sum: ObjetosplanimetriaSumAggregateOutputType | null
    _min: ObjetosplanimetriaMinAggregateOutputType | null
    _max: ObjetosplanimetriaMaxAggregateOutputType | null
  }

  export type ObjetosplanimetriaAvgAggregateOutputType = {
    Id: number | null
    Puerto: number | null
  }

  export type ObjetosplanimetriaSumAggregateOutputType = {
    Id: number | null
    Puerto: number | null
  }

  export type ObjetosplanimetriaMinAggregateOutputType = {
    Id: number | null
    NombreObjeto: string | null
    URLHost: string | null
    IpHost: string | null
    Puerto: number | null
    Usuario: string | null
    Clave: string | null
  }

  export type ObjetosplanimetriaMaxAggregateOutputType = {
    Id: number | null
    NombreObjeto: string | null
    URLHost: string | null
    IpHost: string | null
    Puerto: number | null
    Usuario: string | null
    Clave: string | null
  }

  export type ObjetosplanimetriaCountAggregateOutputType = {
    Id: number
    NombreObjeto: number
    URLHost: number
    IpHost: number
    Puerto: number
    Usuario: number
    Clave: number
    _all: number
  }


  export type ObjetosplanimetriaAvgAggregateInputType = {
    Id?: true
    Puerto?: true
  }

  export type ObjetosplanimetriaSumAggregateInputType = {
    Id?: true
    Puerto?: true
  }

  export type ObjetosplanimetriaMinAggregateInputType = {
    Id?: true
    NombreObjeto?: true
    URLHost?: true
    IpHost?: true
    Puerto?: true
    Usuario?: true
    Clave?: true
  }

  export type ObjetosplanimetriaMaxAggregateInputType = {
    Id?: true
    NombreObjeto?: true
    URLHost?: true
    IpHost?: true
    Puerto?: true
    Usuario?: true
    Clave?: true
  }

  export type ObjetosplanimetriaCountAggregateInputType = {
    Id?: true
    NombreObjeto?: true
    URLHost?: true
    IpHost?: true
    Puerto?: true
    Usuario?: true
    Clave?: true
    _all?: true
  }

  export type ObjetosplanimetriaAggregateArgs = {
    /**
     * Filter which objetosplanimetria to aggregate.
     * 
    **/
    where?: objetosplanimetriaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of objetosplanimetrias to fetch.
     * 
    **/
    orderBy?: Enumerable<objetosplanimetriaOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: objetosplanimetriaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` objetosplanimetrias from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` objetosplanimetrias.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned objetosplanimetrias
    **/
    _count?: true | ObjetosplanimetriaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ObjetosplanimetriaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ObjetosplanimetriaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ObjetosplanimetriaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ObjetosplanimetriaMaxAggregateInputType
  }

  export type GetObjetosplanimetriaAggregateType<T extends ObjetosplanimetriaAggregateArgs> = {
        [P in keyof T & keyof AggregateObjetosplanimetria]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateObjetosplanimetria[P]>
      : GetScalarType<T[P], AggregateObjetosplanimetria[P]>
  }




  export type ObjetosplanimetriaGroupByArgs = {
    where?: objetosplanimetriaWhereInput
    orderBy?: Enumerable<objetosplanimetriaOrderByWithAggregationInput>
    by: Array<ObjetosplanimetriaScalarFieldEnum>
    having?: objetosplanimetriaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ObjetosplanimetriaCountAggregateInputType | true
    _avg?: ObjetosplanimetriaAvgAggregateInputType
    _sum?: ObjetosplanimetriaSumAggregateInputType
    _min?: ObjetosplanimetriaMinAggregateInputType
    _max?: ObjetosplanimetriaMaxAggregateInputType
  }


  export type ObjetosplanimetriaGroupByOutputType = {
    Id: number
    NombreObjeto: string | null
    URLHost: string | null
    IpHost: string | null
    Puerto: number | null
    Usuario: string | null
    Clave: string | null
    _count: ObjetosplanimetriaCountAggregateOutputType | null
    _avg: ObjetosplanimetriaAvgAggregateOutputType | null
    _sum: ObjetosplanimetriaSumAggregateOutputType | null
    _min: ObjetosplanimetriaMinAggregateOutputType | null
    _max: ObjetosplanimetriaMaxAggregateOutputType | null
  }

  type GetObjetosplanimetriaGroupByPayload<T extends ObjetosplanimetriaGroupByArgs> = PrismaPromise<
    Array<
      PickArray<ObjetosplanimetriaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ObjetosplanimetriaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ObjetosplanimetriaGroupByOutputType[P]>
            : GetScalarType<T[P], ObjetosplanimetriaGroupByOutputType[P]>
        }
      >
    >


  export type objetosplanimetriaSelect = {
    Id?: boolean
    NombreObjeto?: boolean
    URLHost?: boolean
    IpHost?: boolean
    Puerto?: boolean
    Usuario?: boolean
    Clave?: boolean
  }


  export type objetosplanimetriaGetPayload<S extends boolean | null | undefined | objetosplanimetriaArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? objetosplanimetria :
    S extends undefined ? never :
    S extends { include: any } & (objetosplanimetriaArgs | objetosplanimetriaFindManyArgs)
    ? objetosplanimetria 
    : S extends { select: any } & (objetosplanimetriaArgs | objetosplanimetriaFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof objetosplanimetria ? objetosplanimetria[P] : never
  } 
      : objetosplanimetria


  type objetosplanimetriaCountArgs = Merge<
    Omit<objetosplanimetriaFindManyArgs, 'select' | 'include'> & {
      select?: ObjetosplanimetriaCountAggregateInputType | true
    }
  >

  export interface objetosplanimetriaDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Objetosplanimetria that matches the filter.
     * @param {objetosplanimetriaFindUniqueArgs} args - Arguments to find a Objetosplanimetria
     * @example
     * // Get one Objetosplanimetria
     * const objetosplanimetria = await prisma.objetosplanimetria.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends objetosplanimetriaFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, objetosplanimetriaFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'objetosplanimetria'> extends True ? Prisma__objetosplanimetriaClient<objetosplanimetriaGetPayload<T>> : Prisma__objetosplanimetriaClient<objetosplanimetriaGetPayload<T> | null, null>

    /**
     * Find one Objetosplanimetria that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {objetosplanimetriaFindUniqueOrThrowArgs} args - Arguments to find a Objetosplanimetria
     * @example
     * // Get one Objetosplanimetria
     * const objetosplanimetria = await prisma.objetosplanimetria.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends objetosplanimetriaFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, objetosplanimetriaFindUniqueOrThrowArgs>
    ): Prisma__objetosplanimetriaClient<objetosplanimetriaGetPayload<T>>

    /**
     * Find the first Objetosplanimetria that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {objetosplanimetriaFindFirstArgs} args - Arguments to find a Objetosplanimetria
     * @example
     * // Get one Objetosplanimetria
     * const objetosplanimetria = await prisma.objetosplanimetria.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends objetosplanimetriaFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, objetosplanimetriaFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'objetosplanimetria'> extends True ? Prisma__objetosplanimetriaClient<objetosplanimetriaGetPayload<T>> : Prisma__objetosplanimetriaClient<objetosplanimetriaGetPayload<T> | null, null>

    /**
     * Find the first Objetosplanimetria that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {objetosplanimetriaFindFirstOrThrowArgs} args - Arguments to find a Objetosplanimetria
     * @example
     * // Get one Objetosplanimetria
     * const objetosplanimetria = await prisma.objetosplanimetria.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends objetosplanimetriaFindFirstOrThrowArgs>(
      args?: SelectSubset<T, objetosplanimetriaFindFirstOrThrowArgs>
    ): Prisma__objetosplanimetriaClient<objetosplanimetriaGetPayload<T>>

    /**
     * Find zero or more Objetosplanimetrias that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {objetosplanimetriaFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Objetosplanimetrias
     * const objetosplanimetrias = await prisma.objetosplanimetria.findMany()
     * 
     * // Get first 10 Objetosplanimetrias
     * const objetosplanimetrias = await prisma.objetosplanimetria.findMany({ take: 10 })
     * 
     * // Only select the `Id`
     * const objetosplanimetriaWithIdOnly = await prisma.objetosplanimetria.findMany({ select: { Id: true } })
     * 
    **/
    findMany<T extends objetosplanimetriaFindManyArgs>(
      args?: SelectSubset<T, objetosplanimetriaFindManyArgs>
    ): PrismaPromise<Array<objetosplanimetriaGetPayload<T>>>

    /**
     * Create a Objetosplanimetria.
     * @param {objetosplanimetriaCreateArgs} args - Arguments to create a Objetosplanimetria.
     * @example
     * // Create one Objetosplanimetria
     * const Objetosplanimetria = await prisma.objetosplanimetria.create({
     *   data: {
     *     // ... data to create a Objetosplanimetria
     *   }
     * })
     * 
    **/
    create<T extends objetosplanimetriaCreateArgs>(
      args: SelectSubset<T, objetosplanimetriaCreateArgs>
    ): Prisma__objetosplanimetriaClient<objetosplanimetriaGetPayload<T>>

    /**
     * Create many Objetosplanimetrias.
     *     @param {objetosplanimetriaCreateManyArgs} args - Arguments to create many Objetosplanimetrias.
     *     @example
     *     // Create many Objetosplanimetrias
     *     const objetosplanimetria = await prisma.objetosplanimetria.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends objetosplanimetriaCreateManyArgs>(
      args?: SelectSubset<T, objetosplanimetriaCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Objetosplanimetria.
     * @param {objetosplanimetriaDeleteArgs} args - Arguments to delete one Objetosplanimetria.
     * @example
     * // Delete one Objetosplanimetria
     * const Objetosplanimetria = await prisma.objetosplanimetria.delete({
     *   where: {
     *     // ... filter to delete one Objetosplanimetria
     *   }
     * })
     * 
    **/
    delete<T extends objetosplanimetriaDeleteArgs>(
      args: SelectSubset<T, objetosplanimetriaDeleteArgs>
    ): Prisma__objetosplanimetriaClient<objetosplanimetriaGetPayload<T>>

    /**
     * Update one Objetosplanimetria.
     * @param {objetosplanimetriaUpdateArgs} args - Arguments to update one Objetosplanimetria.
     * @example
     * // Update one Objetosplanimetria
     * const objetosplanimetria = await prisma.objetosplanimetria.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends objetosplanimetriaUpdateArgs>(
      args: SelectSubset<T, objetosplanimetriaUpdateArgs>
    ): Prisma__objetosplanimetriaClient<objetosplanimetriaGetPayload<T>>

    /**
     * Delete zero or more Objetosplanimetrias.
     * @param {objetosplanimetriaDeleteManyArgs} args - Arguments to filter Objetosplanimetrias to delete.
     * @example
     * // Delete a few Objetosplanimetrias
     * const { count } = await prisma.objetosplanimetria.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends objetosplanimetriaDeleteManyArgs>(
      args?: SelectSubset<T, objetosplanimetriaDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Objetosplanimetrias.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {objetosplanimetriaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Objetosplanimetrias
     * const objetosplanimetria = await prisma.objetosplanimetria.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends objetosplanimetriaUpdateManyArgs>(
      args: SelectSubset<T, objetosplanimetriaUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Objetosplanimetria.
     * @param {objetosplanimetriaUpsertArgs} args - Arguments to update or create a Objetosplanimetria.
     * @example
     * // Update or create a Objetosplanimetria
     * const objetosplanimetria = await prisma.objetosplanimetria.upsert({
     *   create: {
     *     // ... data to create a Objetosplanimetria
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Objetosplanimetria we want to update
     *   }
     * })
    **/
    upsert<T extends objetosplanimetriaUpsertArgs>(
      args: SelectSubset<T, objetosplanimetriaUpsertArgs>
    ): Prisma__objetosplanimetriaClient<objetosplanimetriaGetPayload<T>>

    /**
     * Count the number of Objetosplanimetrias.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {objetosplanimetriaCountArgs} args - Arguments to filter Objetosplanimetrias to count.
     * @example
     * // Count the number of Objetosplanimetrias
     * const count = await prisma.objetosplanimetria.count({
     *   where: {
     *     // ... the filter for the Objetosplanimetrias we want to count
     *   }
     * })
    **/
    count<T extends objetosplanimetriaCountArgs>(
      args?: Subset<T, objetosplanimetriaCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ObjetosplanimetriaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Objetosplanimetria.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ObjetosplanimetriaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ObjetosplanimetriaAggregateArgs>(args: Subset<T, ObjetosplanimetriaAggregateArgs>): PrismaPromise<GetObjetosplanimetriaAggregateType<T>>

    /**
     * Group by Objetosplanimetria.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ObjetosplanimetriaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ObjetosplanimetriaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ObjetosplanimetriaGroupByArgs['orderBy'] }
        : { orderBy?: ObjetosplanimetriaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ObjetosplanimetriaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetObjetosplanimetriaGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for objetosplanimetria.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__objetosplanimetriaClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * objetosplanimetria base type for findUnique actions
   */
  export type objetosplanimetriaFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the objetosplanimetria
     * 
    **/
    select?: objetosplanimetriaSelect | null
    /**
     * Filter, which objetosplanimetria to fetch.
     * 
    **/
    where: objetosplanimetriaWhereUniqueInput
  }

  /**
   * objetosplanimetria: findUnique
   */
  export interface objetosplanimetriaFindUniqueArgs extends objetosplanimetriaFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * objetosplanimetria findUniqueOrThrow
   */
  export type objetosplanimetriaFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the objetosplanimetria
     * 
    **/
    select?: objetosplanimetriaSelect | null
    /**
     * Filter, which objetosplanimetria to fetch.
     * 
    **/
    where: objetosplanimetriaWhereUniqueInput
  }


  /**
   * objetosplanimetria base type for findFirst actions
   */
  export type objetosplanimetriaFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the objetosplanimetria
     * 
    **/
    select?: objetosplanimetriaSelect | null
    /**
     * Filter, which objetosplanimetria to fetch.
     * 
    **/
    where?: objetosplanimetriaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of objetosplanimetrias to fetch.
     * 
    **/
    orderBy?: Enumerable<objetosplanimetriaOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for objetosplanimetrias.
     * 
    **/
    cursor?: objetosplanimetriaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` objetosplanimetrias from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` objetosplanimetrias.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of objetosplanimetrias.
     * 
    **/
    distinct?: Enumerable<ObjetosplanimetriaScalarFieldEnum>
  }

  /**
   * objetosplanimetria: findFirst
   */
  export interface objetosplanimetriaFindFirstArgs extends objetosplanimetriaFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * objetosplanimetria findFirstOrThrow
   */
  export type objetosplanimetriaFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the objetosplanimetria
     * 
    **/
    select?: objetosplanimetriaSelect | null
    /**
     * Filter, which objetosplanimetria to fetch.
     * 
    **/
    where?: objetosplanimetriaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of objetosplanimetrias to fetch.
     * 
    **/
    orderBy?: Enumerable<objetosplanimetriaOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for objetosplanimetrias.
     * 
    **/
    cursor?: objetosplanimetriaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` objetosplanimetrias from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` objetosplanimetrias.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of objetosplanimetrias.
     * 
    **/
    distinct?: Enumerable<ObjetosplanimetriaScalarFieldEnum>
  }


  /**
   * objetosplanimetria findMany
   */
  export type objetosplanimetriaFindManyArgs = {
    /**
     * Select specific fields to fetch from the objetosplanimetria
     * 
    **/
    select?: objetosplanimetriaSelect | null
    /**
     * Filter, which objetosplanimetrias to fetch.
     * 
    **/
    where?: objetosplanimetriaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of objetosplanimetrias to fetch.
     * 
    **/
    orderBy?: Enumerable<objetosplanimetriaOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing objetosplanimetrias.
     * 
    **/
    cursor?: objetosplanimetriaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` objetosplanimetrias from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` objetosplanimetrias.
     * 
    **/
    skip?: number
    distinct?: Enumerable<ObjetosplanimetriaScalarFieldEnum>
  }


  /**
   * objetosplanimetria create
   */
  export type objetosplanimetriaCreateArgs = {
    /**
     * Select specific fields to fetch from the objetosplanimetria
     * 
    **/
    select?: objetosplanimetriaSelect | null
    /**
     * The data needed to create a objetosplanimetria.
     * 
    **/
    data: XOR<objetosplanimetriaCreateInput, objetosplanimetriaUncheckedCreateInput>
  }


  /**
   * objetosplanimetria createMany
   */
  export type objetosplanimetriaCreateManyArgs = {
    /**
     * The data used to create many objetosplanimetrias.
     * 
    **/
    data: Enumerable<objetosplanimetriaCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * objetosplanimetria update
   */
  export type objetosplanimetriaUpdateArgs = {
    /**
     * Select specific fields to fetch from the objetosplanimetria
     * 
    **/
    select?: objetosplanimetriaSelect | null
    /**
     * The data needed to update a objetosplanimetria.
     * 
    **/
    data: XOR<objetosplanimetriaUpdateInput, objetosplanimetriaUncheckedUpdateInput>
    /**
     * Choose, which objetosplanimetria to update.
     * 
    **/
    where: objetosplanimetriaWhereUniqueInput
  }


  /**
   * objetosplanimetria updateMany
   */
  export type objetosplanimetriaUpdateManyArgs = {
    /**
     * The data used to update objetosplanimetrias.
     * 
    **/
    data: XOR<objetosplanimetriaUpdateManyMutationInput, objetosplanimetriaUncheckedUpdateManyInput>
    /**
     * Filter which objetosplanimetrias to update
     * 
    **/
    where?: objetosplanimetriaWhereInput
  }


  /**
   * objetosplanimetria upsert
   */
  export type objetosplanimetriaUpsertArgs = {
    /**
     * Select specific fields to fetch from the objetosplanimetria
     * 
    **/
    select?: objetosplanimetriaSelect | null
    /**
     * The filter to search for the objetosplanimetria to update in case it exists.
     * 
    **/
    where: objetosplanimetriaWhereUniqueInput
    /**
     * In case the objetosplanimetria found by the `where` argument doesn't exist, create a new objetosplanimetria with this data.
     * 
    **/
    create: XOR<objetosplanimetriaCreateInput, objetosplanimetriaUncheckedCreateInput>
    /**
     * In case the objetosplanimetria was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<objetosplanimetriaUpdateInput, objetosplanimetriaUncheckedUpdateInput>
  }


  /**
   * objetosplanimetria delete
   */
  export type objetosplanimetriaDeleteArgs = {
    /**
     * Select specific fields to fetch from the objetosplanimetria
     * 
    **/
    select?: objetosplanimetriaSelect | null
    /**
     * Filter which objetosplanimetria to delete.
     * 
    **/
    where: objetosplanimetriaWhereUniqueInput
  }


  /**
   * objetosplanimetria deleteMany
   */
  export type objetosplanimetriaDeleteManyArgs = {
    /**
     * Filter which objetosplanimetrias to delete
     * 
    **/
    where?: objetosplanimetriaWhereInput
  }


  /**
   * objetosplanimetria without action
   */
  export type objetosplanimetriaArgs = {
    /**
     * Select specific fields to fetch from the objetosplanimetria
     * 
    **/
    select?: objetosplanimetriaSelect | null
  }



  /**
   * Model reldispositivodispositivo
   */


  export type AggregateReldispositivodispositivo = {
    _count: ReldispositivodispositivoCountAggregateOutputType | null
    _avg: ReldispositivodispositivoAvgAggregateOutputType | null
    _sum: ReldispositivodispositivoSumAggregateOutputType | null
    _min: ReldispositivodispositivoMinAggregateOutputType | null
    _max: ReldispositivodispositivoMaxAggregateOutputType | null
  }

  export type ReldispositivodispositivoAvgAggregateOutputType = {
    IDRelDisDispositivo: number | null
    IDDispositivoPadre: number | null
    IDDispositivoHijo: number | null
  }

  export type ReldispositivodispositivoSumAggregateOutputType = {
    IDRelDisDispositivo: number | null
    IDDispositivoPadre: number | null
    IDDispositivoHijo: number | null
  }

  export type ReldispositivodispositivoMinAggregateOutputType = {
    IDRelDisDispositivo: number | null
    IDDispositivoPadre: number | null
    IDDispositivoHijo: number | null
  }

  export type ReldispositivodispositivoMaxAggregateOutputType = {
    IDRelDisDispositivo: number | null
    IDDispositivoPadre: number | null
    IDDispositivoHijo: number | null
  }

  export type ReldispositivodispositivoCountAggregateOutputType = {
    IDRelDisDispositivo: number
    IDDispositivoPadre: number
    IDDispositivoHijo: number
    _all: number
  }


  export type ReldispositivodispositivoAvgAggregateInputType = {
    IDRelDisDispositivo?: true
    IDDispositivoPadre?: true
    IDDispositivoHijo?: true
  }

  export type ReldispositivodispositivoSumAggregateInputType = {
    IDRelDisDispositivo?: true
    IDDispositivoPadre?: true
    IDDispositivoHijo?: true
  }

  export type ReldispositivodispositivoMinAggregateInputType = {
    IDRelDisDispositivo?: true
    IDDispositivoPadre?: true
    IDDispositivoHijo?: true
  }

  export type ReldispositivodispositivoMaxAggregateInputType = {
    IDRelDisDispositivo?: true
    IDDispositivoPadre?: true
    IDDispositivoHijo?: true
  }

  export type ReldispositivodispositivoCountAggregateInputType = {
    IDRelDisDispositivo?: true
    IDDispositivoPadre?: true
    IDDispositivoHijo?: true
    _all?: true
  }

  export type ReldispositivodispositivoAggregateArgs = {
    /**
     * Filter which reldispositivodispositivo to aggregate.
     * 
    **/
    where?: reldispositivodispositivoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of reldispositivodispositivos to fetch.
     * 
    **/
    orderBy?: Enumerable<reldispositivodispositivoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: reldispositivodispositivoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` reldispositivodispositivos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` reldispositivodispositivos.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned reldispositivodispositivos
    **/
    _count?: true | ReldispositivodispositivoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ReldispositivodispositivoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ReldispositivodispositivoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReldispositivodispositivoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReldispositivodispositivoMaxAggregateInputType
  }

  export type GetReldispositivodispositivoAggregateType<T extends ReldispositivodispositivoAggregateArgs> = {
        [P in keyof T & keyof AggregateReldispositivodispositivo]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReldispositivodispositivo[P]>
      : GetScalarType<T[P], AggregateReldispositivodispositivo[P]>
  }




  export type ReldispositivodispositivoGroupByArgs = {
    where?: reldispositivodispositivoWhereInput
    orderBy?: Enumerable<reldispositivodispositivoOrderByWithAggregationInput>
    by: Array<ReldispositivodispositivoScalarFieldEnum>
    having?: reldispositivodispositivoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReldispositivodispositivoCountAggregateInputType | true
    _avg?: ReldispositivodispositivoAvgAggregateInputType
    _sum?: ReldispositivodispositivoSumAggregateInputType
    _min?: ReldispositivodispositivoMinAggregateInputType
    _max?: ReldispositivodispositivoMaxAggregateInputType
  }


  export type ReldispositivodispositivoGroupByOutputType = {
    IDRelDisDispositivo: number
    IDDispositivoPadre: number | null
    IDDispositivoHijo: number | null
    _count: ReldispositivodispositivoCountAggregateOutputType | null
    _avg: ReldispositivodispositivoAvgAggregateOutputType | null
    _sum: ReldispositivodispositivoSumAggregateOutputType | null
    _min: ReldispositivodispositivoMinAggregateOutputType | null
    _max: ReldispositivodispositivoMaxAggregateOutputType | null
  }

  type GetReldispositivodispositivoGroupByPayload<T extends ReldispositivodispositivoGroupByArgs> = PrismaPromise<
    Array<
      PickArray<ReldispositivodispositivoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReldispositivodispositivoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReldispositivodispositivoGroupByOutputType[P]>
            : GetScalarType<T[P], ReldispositivodispositivoGroupByOutputType[P]>
        }
      >
    >


  export type reldispositivodispositivoSelect = {
    IDRelDisDispositivo?: boolean
    IDDispositivoPadre?: boolean
    IDDispositivoHijo?: boolean
  }


  export type reldispositivodispositivoGetPayload<S extends boolean | null | undefined | reldispositivodispositivoArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? reldispositivodispositivo :
    S extends undefined ? never :
    S extends { include: any } & (reldispositivodispositivoArgs | reldispositivodispositivoFindManyArgs)
    ? reldispositivodispositivo 
    : S extends { select: any } & (reldispositivodispositivoArgs | reldispositivodispositivoFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof reldispositivodispositivo ? reldispositivodispositivo[P] : never
  } 
      : reldispositivodispositivo


  type reldispositivodispositivoCountArgs = Merge<
    Omit<reldispositivodispositivoFindManyArgs, 'select' | 'include'> & {
      select?: ReldispositivodispositivoCountAggregateInputType | true
    }
  >

  export interface reldispositivodispositivoDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Reldispositivodispositivo that matches the filter.
     * @param {reldispositivodispositivoFindUniqueArgs} args - Arguments to find a Reldispositivodispositivo
     * @example
     * // Get one Reldispositivodispositivo
     * const reldispositivodispositivo = await prisma.reldispositivodispositivo.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends reldispositivodispositivoFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, reldispositivodispositivoFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'reldispositivodispositivo'> extends True ? Prisma__reldispositivodispositivoClient<reldispositivodispositivoGetPayload<T>> : Prisma__reldispositivodispositivoClient<reldispositivodispositivoGetPayload<T> | null, null>

    /**
     * Find one Reldispositivodispositivo that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {reldispositivodispositivoFindUniqueOrThrowArgs} args - Arguments to find a Reldispositivodispositivo
     * @example
     * // Get one Reldispositivodispositivo
     * const reldispositivodispositivo = await prisma.reldispositivodispositivo.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends reldispositivodispositivoFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, reldispositivodispositivoFindUniqueOrThrowArgs>
    ): Prisma__reldispositivodispositivoClient<reldispositivodispositivoGetPayload<T>>

    /**
     * Find the first Reldispositivodispositivo that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reldispositivodispositivoFindFirstArgs} args - Arguments to find a Reldispositivodispositivo
     * @example
     * // Get one Reldispositivodispositivo
     * const reldispositivodispositivo = await prisma.reldispositivodispositivo.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends reldispositivodispositivoFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, reldispositivodispositivoFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'reldispositivodispositivo'> extends True ? Prisma__reldispositivodispositivoClient<reldispositivodispositivoGetPayload<T>> : Prisma__reldispositivodispositivoClient<reldispositivodispositivoGetPayload<T> | null, null>

    /**
     * Find the first Reldispositivodispositivo that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reldispositivodispositivoFindFirstOrThrowArgs} args - Arguments to find a Reldispositivodispositivo
     * @example
     * // Get one Reldispositivodispositivo
     * const reldispositivodispositivo = await prisma.reldispositivodispositivo.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends reldispositivodispositivoFindFirstOrThrowArgs>(
      args?: SelectSubset<T, reldispositivodispositivoFindFirstOrThrowArgs>
    ): Prisma__reldispositivodispositivoClient<reldispositivodispositivoGetPayload<T>>

    /**
     * Find zero or more Reldispositivodispositivos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reldispositivodispositivoFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Reldispositivodispositivos
     * const reldispositivodispositivos = await prisma.reldispositivodispositivo.findMany()
     * 
     * // Get first 10 Reldispositivodispositivos
     * const reldispositivodispositivos = await prisma.reldispositivodispositivo.findMany({ take: 10 })
     * 
     * // Only select the `IDRelDisDispositivo`
     * const reldispositivodispositivoWithIDRelDisDispositivoOnly = await prisma.reldispositivodispositivo.findMany({ select: { IDRelDisDispositivo: true } })
     * 
    **/
    findMany<T extends reldispositivodispositivoFindManyArgs>(
      args?: SelectSubset<T, reldispositivodispositivoFindManyArgs>
    ): PrismaPromise<Array<reldispositivodispositivoGetPayload<T>>>

    /**
     * Create a Reldispositivodispositivo.
     * @param {reldispositivodispositivoCreateArgs} args - Arguments to create a Reldispositivodispositivo.
     * @example
     * // Create one Reldispositivodispositivo
     * const Reldispositivodispositivo = await prisma.reldispositivodispositivo.create({
     *   data: {
     *     // ... data to create a Reldispositivodispositivo
     *   }
     * })
     * 
    **/
    create<T extends reldispositivodispositivoCreateArgs>(
      args: SelectSubset<T, reldispositivodispositivoCreateArgs>
    ): Prisma__reldispositivodispositivoClient<reldispositivodispositivoGetPayload<T>>

    /**
     * Create many Reldispositivodispositivos.
     *     @param {reldispositivodispositivoCreateManyArgs} args - Arguments to create many Reldispositivodispositivos.
     *     @example
     *     // Create many Reldispositivodispositivos
     *     const reldispositivodispositivo = await prisma.reldispositivodispositivo.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends reldispositivodispositivoCreateManyArgs>(
      args?: SelectSubset<T, reldispositivodispositivoCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Reldispositivodispositivo.
     * @param {reldispositivodispositivoDeleteArgs} args - Arguments to delete one Reldispositivodispositivo.
     * @example
     * // Delete one Reldispositivodispositivo
     * const Reldispositivodispositivo = await prisma.reldispositivodispositivo.delete({
     *   where: {
     *     // ... filter to delete one Reldispositivodispositivo
     *   }
     * })
     * 
    **/
    delete<T extends reldispositivodispositivoDeleteArgs>(
      args: SelectSubset<T, reldispositivodispositivoDeleteArgs>
    ): Prisma__reldispositivodispositivoClient<reldispositivodispositivoGetPayload<T>>

    /**
     * Update one Reldispositivodispositivo.
     * @param {reldispositivodispositivoUpdateArgs} args - Arguments to update one Reldispositivodispositivo.
     * @example
     * // Update one Reldispositivodispositivo
     * const reldispositivodispositivo = await prisma.reldispositivodispositivo.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends reldispositivodispositivoUpdateArgs>(
      args: SelectSubset<T, reldispositivodispositivoUpdateArgs>
    ): Prisma__reldispositivodispositivoClient<reldispositivodispositivoGetPayload<T>>

    /**
     * Delete zero or more Reldispositivodispositivos.
     * @param {reldispositivodispositivoDeleteManyArgs} args - Arguments to filter Reldispositivodispositivos to delete.
     * @example
     * // Delete a few Reldispositivodispositivos
     * const { count } = await prisma.reldispositivodispositivo.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends reldispositivodispositivoDeleteManyArgs>(
      args?: SelectSubset<T, reldispositivodispositivoDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Reldispositivodispositivos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reldispositivodispositivoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Reldispositivodispositivos
     * const reldispositivodispositivo = await prisma.reldispositivodispositivo.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends reldispositivodispositivoUpdateManyArgs>(
      args: SelectSubset<T, reldispositivodispositivoUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Reldispositivodispositivo.
     * @param {reldispositivodispositivoUpsertArgs} args - Arguments to update or create a Reldispositivodispositivo.
     * @example
     * // Update or create a Reldispositivodispositivo
     * const reldispositivodispositivo = await prisma.reldispositivodispositivo.upsert({
     *   create: {
     *     // ... data to create a Reldispositivodispositivo
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Reldispositivodispositivo we want to update
     *   }
     * })
    **/
    upsert<T extends reldispositivodispositivoUpsertArgs>(
      args: SelectSubset<T, reldispositivodispositivoUpsertArgs>
    ): Prisma__reldispositivodispositivoClient<reldispositivodispositivoGetPayload<T>>

    /**
     * Count the number of Reldispositivodispositivos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reldispositivodispositivoCountArgs} args - Arguments to filter Reldispositivodispositivos to count.
     * @example
     * // Count the number of Reldispositivodispositivos
     * const count = await prisma.reldispositivodispositivo.count({
     *   where: {
     *     // ... the filter for the Reldispositivodispositivos we want to count
     *   }
     * })
    **/
    count<T extends reldispositivodispositivoCountArgs>(
      args?: Subset<T, reldispositivodispositivoCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReldispositivodispositivoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Reldispositivodispositivo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReldispositivodispositivoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReldispositivodispositivoAggregateArgs>(args: Subset<T, ReldispositivodispositivoAggregateArgs>): PrismaPromise<GetReldispositivodispositivoAggregateType<T>>

    /**
     * Group by Reldispositivodispositivo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReldispositivodispositivoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReldispositivodispositivoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReldispositivodispositivoGroupByArgs['orderBy'] }
        : { orderBy?: ReldispositivodispositivoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReldispositivodispositivoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReldispositivodispositivoGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for reldispositivodispositivo.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__reldispositivodispositivoClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * reldispositivodispositivo base type for findUnique actions
   */
  export type reldispositivodispositivoFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the reldispositivodispositivo
     * 
    **/
    select?: reldispositivodispositivoSelect | null
    /**
     * Filter, which reldispositivodispositivo to fetch.
     * 
    **/
    where: reldispositivodispositivoWhereUniqueInput
  }

  /**
   * reldispositivodispositivo: findUnique
   */
  export interface reldispositivodispositivoFindUniqueArgs extends reldispositivodispositivoFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * reldispositivodispositivo findUniqueOrThrow
   */
  export type reldispositivodispositivoFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the reldispositivodispositivo
     * 
    **/
    select?: reldispositivodispositivoSelect | null
    /**
     * Filter, which reldispositivodispositivo to fetch.
     * 
    **/
    where: reldispositivodispositivoWhereUniqueInput
  }


  /**
   * reldispositivodispositivo base type for findFirst actions
   */
  export type reldispositivodispositivoFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the reldispositivodispositivo
     * 
    **/
    select?: reldispositivodispositivoSelect | null
    /**
     * Filter, which reldispositivodispositivo to fetch.
     * 
    **/
    where?: reldispositivodispositivoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of reldispositivodispositivos to fetch.
     * 
    **/
    orderBy?: Enumerable<reldispositivodispositivoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for reldispositivodispositivos.
     * 
    **/
    cursor?: reldispositivodispositivoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` reldispositivodispositivos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` reldispositivodispositivos.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of reldispositivodispositivos.
     * 
    **/
    distinct?: Enumerable<ReldispositivodispositivoScalarFieldEnum>
  }

  /**
   * reldispositivodispositivo: findFirst
   */
  export interface reldispositivodispositivoFindFirstArgs extends reldispositivodispositivoFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * reldispositivodispositivo findFirstOrThrow
   */
  export type reldispositivodispositivoFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the reldispositivodispositivo
     * 
    **/
    select?: reldispositivodispositivoSelect | null
    /**
     * Filter, which reldispositivodispositivo to fetch.
     * 
    **/
    where?: reldispositivodispositivoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of reldispositivodispositivos to fetch.
     * 
    **/
    orderBy?: Enumerable<reldispositivodispositivoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for reldispositivodispositivos.
     * 
    **/
    cursor?: reldispositivodispositivoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` reldispositivodispositivos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` reldispositivodispositivos.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of reldispositivodispositivos.
     * 
    **/
    distinct?: Enumerable<ReldispositivodispositivoScalarFieldEnum>
  }


  /**
   * reldispositivodispositivo findMany
   */
  export type reldispositivodispositivoFindManyArgs = {
    /**
     * Select specific fields to fetch from the reldispositivodispositivo
     * 
    **/
    select?: reldispositivodispositivoSelect | null
    /**
     * Filter, which reldispositivodispositivos to fetch.
     * 
    **/
    where?: reldispositivodispositivoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of reldispositivodispositivos to fetch.
     * 
    **/
    orderBy?: Enumerable<reldispositivodispositivoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing reldispositivodispositivos.
     * 
    **/
    cursor?: reldispositivodispositivoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` reldispositivodispositivos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` reldispositivodispositivos.
     * 
    **/
    skip?: number
    distinct?: Enumerable<ReldispositivodispositivoScalarFieldEnum>
  }


  /**
   * reldispositivodispositivo create
   */
  export type reldispositivodispositivoCreateArgs = {
    /**
     * Select specific fields to fetch from the reldispositivodispositivo
     * 
    **/
    select?: reldispositivodispositivoSelect | null
    /**
     * The data needed to create a reldispositivodispositivo.
     * 
    **/
    data: XOR<reldispositivodispositivoCreateInput, reldispositivodispositivoUncheckedCreateInput>
  }


  /**
   * reldispositivodispositivo createMany
   */
  export type reldispositivodispositivoCreateManyArgs = {
    /**
     * The data used to create many reldispositivodispositivos.
     * 
    **/
    data: Enumerable<reldispositivodispositivoCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * reldispositivodispositivo update
   */
  export type reldispositivodispositivoUpdateArgs = {
    /**
     * Select specific fields to fetch from the reldispositivodispositivo
     * 
    **/
    select?: reldispositivodispositivoSelect | null
    /**
     * The data needed to update a reldispositivodispositivo.
     * 
    **/
    data: XOR<reldispositivodispositivoUpdateInput, reldispositivodispositivoUncheckedUpdateInput>
    /**
     * Choose, which reldispositivodispositivo to update.
     * 
    **/
    where: reldispositivodispositivoWhereUniqueInput
  }


  /**
   * reldispositivodispositivo updateMany
   */
  export type reldispositivodispositivoUpdateManyArgs = {
    /**
     * The data used to update reldispositivodispositivos.
     * 
    **/
    data: XOR<reldispositivodispositivoUpdateManyMutationInput, reldispositivodispositivoUncheckedUpdateManyInput>
    /**
     * Filter which reldispositivodispositivos to update
     * 
    **/
    where?: reldispositivodispositivoWhereInput
  }


  /**
   * reldispositivodispositivo upsert
   */
  export type reldispositivodispositivoUpsertArgs = {
    /**
     * Select specific fields to fetch from the reldispositivodispositivo
     * 
    **/
    select?: reldispositivodispositivoSelect | null
    /**
     * The filter to search for the reldispositivodispositivo to update in case it exists.
     * 
    **/
    where: reldispositivodispositivoWhereUniqueInput
    /**
     * In case the reldispositivodispositivo found by the `where` argument doesn't exist, create a new reldispositivodispositivo with this data.
     * 
    **/
    create: XOR<reldispositivodispositivoCreateInput, reldispositivodispositivoUncheckedCreateInput>
    /**
     * In case the reldispositivodispositivo was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<reldispositivodispositivoUpdateInput, reldispositivodispositivoUncheckedUpdateInput>
  }


  /**
   * reldispositivodispositivo delete
   */
  export type reldispositivodispositivoDeleteArgs = {
    /**
     * Select specific fields to fetch from the reldispositivodispositivo
     * 
    **/
    select?: reldispositivodispositivoSelect | null
    /**
     * Filter which reldispositivodispositivo to delete.
     * 
    **/
    where: reldispositivodispositivoWhereUniqueInput
  }


  /**
   * reldispositivodispositivo deleteMany
   */
  export type reldispositivodispositivoDeleteManyArgs = {
    /**
     * Filter which reldispositivodispositivos to delete
     * 
    **/
    where?: reldispositivodispositivoWhereInput
  }


  /**
   * reldispositivodispositivo without action
   */
  export type reldispositivodispositivoArgs = {
    /**
     * Select specific fields to fetch from the reldispositivodispositivo
     * 
    **/
    select?: reldispositivodispositivoSelect | null
  }



  /**
   * Model reldispositivogateway
   */


  export type AggregateReldispositivogateway = {
    _count: ReldispositivogatewayCountAggregateOutputType | null
    _avg: ReldispositivogatewayAvgAggregateOutputType | null
    _sum: ReldispositivogatewaySumAggregateOutputType | null
    _min: ReldispositivogatewayMinAggregateOutputType | null
    _max: ReldispositivogatewayMaxAggregateOutputType | null
  }

  export type ReldispositivogatewayAvgAggregateOutputType = {
    IDRelDisGateway: number | null
    IDDispositivo: number | null
    IDGateway: number | null
  }

  export type ReldispositivogatewaySumAggregateOutputType = {
    IDRelDisGateway: number | null
    IDDispositivo: number | null
    IDGateway: number | null
  }

  export type ReldispositivogatewayMinAggregateOutputType = {
    IDRelDisGateway: number | null
    IDDispositivo: number | null
    IDGateway: number | null
  }

  export type ReldispositivogatewayMaxAggregateOutputType = {
    IDRelDisGateway: number | null
    IDDispositivo: number | null
    IDGateway: number | null
  }

  export type ReldispositivogatewayCountAggregateOutputType = {
    IDRelDisGateway: number
    IDDispositivo: number
    IDGateway: number
    _all: number
  }


  export type ReldispositivogatewayAvgAggregateInputType = {
    IDRelDisGateway?: true
    IDDispositivo?: true
    IDGateway?: true
  }

  export type ReldispositivogatewaySumAggregateInputType = {
    IDRelDisGateway?: true
    IDDispositivo?: true
    IDGateway?: true
  }

  export type ReldispositivogatewayMinAggregateInputType = {
    IDRelDisGateway?: true
    IDDispositivo?: true
    IDGateway?: true
  }

  export type ReldispositivogatewayMaxAggregateInputType = {
    IDRelDisGateway?: true
    IDDispositivo?: true
    IDGateway?: true
  }

  export type ReldispositivogatewayCountAggregateInputType = {
    IDRelDisGateway?: true
    IDDispositivo?: true
    IDGateway?: true
    _all?: true
  }

  export type ReldispositivogatewayAggregateArgs = {
    /**
     * Filter which reldispositivogateway to aggregate.
     * 
    **/
    where?: reldispositivogatewayWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of reldispositivogateways to fetch.
     * 
    **/
    orderBy?: Enumerable<reldispositivogatewayOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: reldispositivogatewayWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` reldispositivogateways from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` reldispositivogateways.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned reldispositivogateways
    **/
    _count?: true | ReldispositivogatewayCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ReldispositivogatewayAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ReldispositivogatewaySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReldispositivogatewayMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReldispositivogatewayMaxAggregateInputType
  }

  export type GetReldispositivogatewayAggregateType<T extends ReldispositivogatewayAggregateArgs> = {
        [P in keyof T & keyof AggregateReldispositivogateway]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReldispositivogateway[P]>
      : GetScalarType<T[P], AggregateReldispositivogateway[P]>
  }




  export type ReldispositivogatewayGroupByArgs = {
    where?: reldispositivogatewayWhereInput
    orderBy?: Enumerable<reldispositivogatewayOrderByWithAggregationInput>
    by: Array<ReldispositivogatewayScalarFieldEnum>
    having?: reldispositivogatewayScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReldispositivogatewayCountAggregateInputType | true
    _avg?: ReldispositivogatewayAvgAggregateInputType
    _sum?: ReldispositivogatewaySumAggregateInputType
    _min?: ReldispositivogatewayMinAggregateInputType
    _max?: ReldispositivogatewayMaxAggregateInputType
  }


  export type ReldispositivogatewayGroupByOutputType = {
    IDRelDisGateway: number
    IDDispositivo: number | null
    IDGateway: number | null
    _count: ReldispositivogatewayCountAggregateOutputType | null
    _avg: ReldispositivogatewayAvgAggregateOutputType | null
    _sum: ReldispositivogatewaySumAggregateOutputType | null
    _min: ReldispositivogatewayMinAggregateOutputType | null
    _max: ReldispositivogatewayMaxAggregateOutputType | null
  }

  type GetReldispositivogatewayGroupByPayload<T extends ReldispositivogatewayGroupByArgs> = PrismaPromise<
    Array<
      PickArray<ReldispositivogatewayGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReldispositivogatewayGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReldispositivogatewayGroupByOutputType[P]>
            : GetScalarType<T[P], ReldispositivogatewayGroupByOutputType[P]>
        }
      >
    >


  export type reldispositivogatewaySelect = {
    IDRelDisGateway?: boolean
    IDDispositivo?: boolean
    IDGateway?: boolean
  }


  export type reldispositivogatewayGetPayload<S extends boolean | null | undefined | reldispositivogatewayArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? reldispositivogateway :
    S extends undefined ? never :
    S extends { include: any } & (reldispositivogatewayArgs | reldispositivogatewayFindManyArgs)
    ? reldispositivogateway 
    : S extends { select: any } & (reldispositivogatewayArgs | reldispositivogatewayFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof reldispositivogateway ? reldispositivogateway[P] : never
  } 
      : reldispositivogateway


  type reldispositivogatewayCountArgs = Merge<
    Omit<reldispositivogatewayFindManyArgs, 'select' | 'include'> & {
      select?: ReldispositivogatewayCountAggregateInputType | true
    }
  >

  export interface reldispositivogatewayDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Reldispositivogateway that matches the filter.
     * @param {reldispositivogatewayFindUniqueArgs} args - Arguments to find a Reldispositivogateway
     * @example
     * // Get one Reldispositivogateway
     * const reldispositivogateway = await prisma.reldispositivogateway.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends reldispositivogatewayFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, reldispositivogatewayFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'reldispositivogateway'> extends True ? Prisma__reldispositivogatewayClient<reldispositivogatewayGetPayload<T>> : Prisma__reldispositivogatewayClient<reldispositivogatewayGetPayload<T> | null, null>

    /**
     * Find one Reldispositivogateway that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {reldispositivogatewayFindUniqueOrThrowArgs} args - Arguments to find a Reldispositivogateway
     * @example
     * // Get one Reldispositivogateway
     * const reldispositivogateway = await prisma.reldispositivogateway.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends reldispositivogatewayFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, reldispositivogatewayFindUniqueOrThrowArgs>
    ): Prisma__reldispositivogatewayClient<reldispositivogatewayGetPayload<T>>

    /**
     * Find the first Reldispositivogateway that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reldispositivogatewayFindFirstArgs} args - Arguments to find a Reldispositivogateway
     * @example
     * // Get one Reldispositivogateway
     * const reldispositivogateway = await prisma.reldispositivogateway.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends reldispositivogatewayFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, reldispositivogatewayFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'reldispositivogateway'> extends True ? Prisma__reldispositivogatewayClient<reldispositivogatewayGetPayload<T>> : Prisma__reldispositivogatewayClient<reldispositivogatewayGetPayload<T> | null, null>

    /**
     * Find the first Reldispositivogateway that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reldispositivogatewayFindFirstOrThrowArgs} args - Arguments to find a Reldispositivogateway
     * @example
     * // Get one Reldispositivogateway
     * const reldispositivogateway = await prisma.reldispositivogateway.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends reldispositivogatewayFindFirstOrThrowArgs>(
      args?: SelectSubset<T, reldispositivogatewayFindFirstOrThrowArgs>
    ): Prisma__reldispositivogatewayClient<reldispositivogatewayGetPayload<T>>

    /**
     * Find zero or more Reldispositivogateways that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reldispositivogatewayFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Reldispositivogateways
     * const reldispositivogateways = await prisma.reldispositivogateway.findMany()
     * 
     * // Get first 10 Reldispositivogateways
     * const reldispositivogateways = await prisma.reldispositivogateway.findMany({ take: 10 })
     * 
     * // Only select the `IDRelDisGateway`
     * const reldispositivogatewayWithIDRelDisGatewayOnly = await prisma.reldispositivogateway.findMany({ select: { IDRelDisGateway: true } })
     * 
    **/
    findMany<T extends reldispositivogatewayFindManyArgs>(
      args?: SelectSubset<T, reldispositivogatewayFindManyArgs>
    ): PrismaPromise<Array<reldispositivogatewayGetPayload<T>>>

    /**
     * Create a Reldispositivogateway.
     * @param {reldispositivogatewayCreateArgs} args - Arguments to create a Reldispositivogateway.
     * @example
     * // Create one Reldispositivogateway
     * const Reldispositivogateway = await prisma.reldispositivogateway.create({
     *   data: {
     *     // ... data to create a Reldispositivogateway
     *   }
     * })
     * 
    **/
    create<T extends reldispositivogatewayCreateArgs>(
      args: SelectSubset<T, reldispositivogatewayCreateArgs>
    ): Prisma__reldispositivogatewayClient<reldispositivogatewayGetPayload<T>>

    /**
     * Create many Reldispositivogateways.
     *     @param {reldispositivogatewayCreateManyArgs} args - Arguments to create many Reldispositivogateways.
     *     @example
     *     // Create many Reldispositivogateways
     *     const reldispositivogateway = await prisma.reldispositivogateway.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends reldispositivogatewayCreateManyArgs>(
      args?: SelectSubset<T, reldispositivogatewayCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Reldispositivogateway.
     * @param {reldispositivogatewayDeleteArgs} args - Arguments to delete one Reldispositivogateway.
     * @example
     * // Delete one Reldispositivogateway
     * const Reldispositivogateway = await prisma.reldispositivogateway.delete({
     *   where: {
     *     // ... filter to delete one Reldispositivogateway
     *   }
     * })
     * 
    **/
    delete<T extends reldispositivogatewayDeleteArgs>(
      args: SelectSubset<T, reldispositivogatewayDeleteArgs>
    ): Prisma__reldispositivogatewayClient<reldispositivogatewayGetPayload<T>>

    /**
     * Update one Reldispositivogateway.
     * @param {reldispositivogatewayUpdateArgs} args - Arguments to update one Reldispositivogateway.
     * @example
     * // Update one Reldispositivogateway
     * const reldispositivogateway = await prisma.reldispositivogateway.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends reldispositivogatewayUpdateArgs>(
      args: SelectSubset<T, reldispositivogatewayUpdateArgs>
    ): Prisma__reldispositivogatewayClient<reldispositivogatewayGetPayload<T>>

    /**
     * Delete zero or more Reldispositivogateways.
     * @param {reldispositivogatewayDeleteManyArgs} args - Arguments to filter Reldispositivogateways to delete.
     * @example
     * // Delete a few Reldispositivogateways
     * const { count } = await prisma.reldispositivogateway.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends reldispositivogatewayDeleteManyArgs>(
      args?: SelectSubset<T, reldispositivogatewayDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Reldispositivogateways.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reldispositivogatewayUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Reldispositivogateways
     * const reldispositivogateway = await prisma.reldispositivogateway.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends reldispositivogatewayUpdateManyArgs>(
      args: SelectSubset<T, reldispositivogatewayUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Reldispositivogateway.
     * @param {reldispositivogatewayUpsertArgs} args - Arguments to update or create a Reldispositivogateway.
     * @example
     * // Update or create a Reldispositivogateway
     * const reldispositivogateway = await prisma.reldispositivogateway.upsert({
     *   create: {
     *     // ... data to create a Reldispositivogateway
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Reldispositivogateway we want to update
     *   }
     * })
    **/
    upsert<T extends reldispositivogatewayUpsertArgs>(
      args: SelectSubset<T, reldispositivogatewayUpsertArgs>
    ): Prisma__reldispositivogatewayClient<reldispositivogatewayGetPayload<T>>

    /**
     * Count the number of Reldispositivogateways.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reldispositivogatewayCountArgs} args - Arguments to filter Reldispositivogateways to count.
     * @example
     * // Count the number of Reldispositivogateways
     * const count = await prisma.reldispositivogateway.count({
     *   where: {
     *     // ... the filter for the Reldispositivogateways we want to count
     *   }
     * })
    **/
    count<T extends reldispositivogatewayCountArgs>(
      args?: Subset<T, reldispositivogatewayCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReldispositivogatewayCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Reldispositivogateway.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReldispositivogatewayAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReldispositivogatewayAggregateArgs>(args: Subset<T, ReldispositivogatewayAggregateArgs>): PrismaPromise<GetReldispositivogatewayAggregateType<T>>

    /**
     * Group by Reldispositivogateway.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReldispositivogatewayGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReldispositivogatewayGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReldispositivogatewayGroupByArgs['orderBy'] }
        : { orderBy?: ReldispositivogatewayGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReldispositivogatewayGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReldispositivogatewayGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for reldispositivogateway.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__reldispositivogatewayClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * reldispositivogateway base type for findUnique actions
   */
  export type reldispositivogatewayFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the reldispositivogateway
     * 
    **/
    select?: reldispositivogatewaySelect | null
    /**
     * Filter, which reldispositivogateway to fetch.
     * 
    **/
    where: reldispositivogatewayWhereUniqueInput
  }

  /**
   * reldispositivogateway: findUnique
   */
  export interface reldispositivogatewayFindUniqueArgs extends reldispositivogatewayFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * reldispositivogateway findUniqueOrThrow
   */
  export type reldispositivogatewayFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the reldispositivogateway
     * 
    **/
    select?: reldispositivogatewaySelect | null
    /**
     * Filter, which reldispositivogateway to fetch.
     * 
    **/
    where: reldispositivogatewayWhereUniqueInput
  }


  /**
   * reldispositivogateway base type for findFirst actions
   */
  export type reldispositivogatewayFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the reldispositivogateway
     * 
    **/
    select?: reldispositivogatewaySelect | null
    /**
     * Filter, which reldispositivogateway to fetch.
     * 
    **/
    where?: reldispositivogatewayWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of reldispositivogateways to fetch.
     * 
    **/
    orderBy?: Enumerable<reldispositivogatewayOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for reldispositivogateways.
     * 
    **/
    cursor?: reldispositivogatewayWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` reldispositivogateways from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` reldispositivogateways.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of reldispositivogateways.
     * 
    **/
    distinct?: Enumerable<ReldispositivogatewayScalarFieldEnum>
  }

  /**
   * reldispositivogateway: findFirst
   */
  export interface reldispositivogatewayFindFirstArgs extends reldispositivogatewayFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * reldispositivogateway findFirstOrThrow
   */
  export type reldispositivogatewayFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the reldispositivogateway
     * 
    **/
    select?: reldispositivogatewaySelect | null
    /**
     * Filter, which reldispositivogateway to fetch.
     * 
    **/
    where?: reldispositivogatewayWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of reldispositivogateways to fetch.
     * 
    **/
    orderBy?: Enumerable<reldispositivogatewayOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for reldispositivogateways.
     * 
    **/
    cursor?: reldispositivogatewayWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` reldispositivogateways from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` reldispositivogateways.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of reldispositivogateways.
     * 
    **/
    distinct?: Enumerable<ReldispositivogatewayScalarFieldEnum>
  }


  /**
   * reldispositivogateway findMany
   */
  export type reldispositivogatewayFindManyArgs = {
    /**
     * Select specific fields to fetch from the reldispositivogateway
     * 
    **/
    select?: reldispositivogatewaySelect | null
    /**
     * Filter, which reldispositivogateways to fetch.
     * 
    **/
    where?: reldispositivogatewayWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of reldispositivogateways to fetch.
     * 
    **/
    orderBy?: Enumerable<reldispositivogatewayOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing reldispositivogateways.
     * 
    **/
    cursor?: reldispositivogatewayWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` reldispositivogateways from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` reldispositivogateways.
     * 
    **/
    skip?: number
    distinct?: Enumerable<ReldispositivogatewayScalarFieldEnum>
  }


  /**
   * reldispositivogateway create
   */
  export type reldispositivogatewayCreateArgs = {
    /**
     * Select specific fields to fetch from the reldispositivogateway
     * 
    **/
    select?: reldispositivogatewaySelect | null
    /**
     * The data needed to create a reldispositivogateway.
     * 
    **/
    data: XOR<reldispositivogatewayCreateInput, reldispositivogatewayUncheckedCreateInput>
  }


  /**
   * reldispositivogateway createMany
   */
  export type reldispositivogatewayCreateManyArgs = {
    /**
     * The data used to create many reldispositivogateways.
     * 
    **/
    data: Enumerable<reldispositivogatewayCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * reldispositivogateway update
   */
  export type reldispositivogatewayUpdateArgs = {
    /**
     * Select specific fields to fetch from the reldispositivogateway
     * 
    **/
    select?: reldispositivogatewaySelect | null
    /**
     * The data needed to update a reldispositivogateway.
     * 
    **/
    data: XOR<reldispositivogatewayUpdateInput, reldispositivogatewayUncheckedUpdateInput>
    /**
     * Choose, which reldispositivogateway to update.
     * 
    **/
    where: reldispositivogatewayWhereUniqueInput
  }


  /**
   * reldispositivogateway updateMany
   */
  export type reldispositivogatewayUpdateManyArgs = {
    /**
     * The data used to update reldispositivogateways.
     * 
    **/
    data: XOR<reldispositivogatewayUpdateManyMutationInput, reldispositivogatewayUncheckedUpdateManyInput>
    /**
     * Filter which reldispositivogateways to update
     * 
    **/
    where?: reldispositivogatewayWhereInput
  }


  /**
   * reldispositivogateway upsert
   */
  export type reldispositivogatewayUpsertArgs = {
    /**
     * Select specific fields to fetch from the reldispositivogateway
     * 
    **/
    select?: reldispositivogatewaySelect | null
    /**
     * The filter to search for the reldispositivogateway to update in case it exists.
     * 
    **/
    where: reldispositivogatewayWhereUniqueInput
    /**
     * In case the reldispositivogateway found by the `where` argument doesn't exist, create a new reldispositivogateway with this data.
     * 
    **/
    create: XOR<reldispositivogatewayCreateInput, reldispositivogatewayUncheckedCreateInput>
    /**
     * In case the reldispositivogateway was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<reldispositivogatewayUpdateInput, reldispositivogatewayUncheckedUpdateInput>
  }


  /**
   * reldispositivogateway delete
   */
  export type reldispositivogatewayDeleteArgs = {
    /**
     * Select specific fields to fetch from the reldispositivogateway
     * 
    **/
    select?: reldispositivogatewaySelect | null
    /**
     * Filter which reldispositivogateway to delete.
     * 
    **/
    where: reldispositivogatewayWhereUniqueInput
  }


  /**
   * reldispositivogateway deleteMany
   */
  export type reldispositivogatewayDeleteManyArgs = {
    /**
     * Filter which reldispositivogateways to delete
     * 
    **/
    where?: reldispositivogatewayWhereInput
  }


  /**
   * reldispositivogateway without action
   */
  export type reldispositivogatewayArgs = {
    /**
     * Select specific fields to fetch from the reldispositivogateway
     * 
    **/
    select?: reldispositivogatewaySelect | null
  }



  /**
   * Model reldispositivogrupodispositivo
   */


  export type AggregateReldispositivogrupodispositivo = {
    _count: ReldispositivogrupodispositivoCountAggregateOutputType | null
    _avg: ReldispositivogrupodispositivoAvgAggregateOutputType | null
    _sum: ReldispositivogrupodispositivoSumAggregateOutputType | null
    _min: ReldispositivogrupodispositivoMinAggregateOutputType | null
    _max: ReldispositivogrupodispositivoMaxAggregateOutputType | null
  }

  export type ReldispositivogrupodispositivoAvgAggregateOutputType = {
    IDRelDisGrupoDis: number | null
  }

  export type ReldispositivogrupodispositivoSumAggregateOutputType = {
    IDRelDisGrupoDis: number | null
  }

  export type ReldispositivogrupodispositivoMinAggregateOutputType = {
    IDRelDisGrupoDis: number | null
    IDGrupo: string | null
    IDDispositivo: string | null
  }

  export type ReldispositivogrupodispositivoMaxAggregateOutputType = {
    IDRelDisGrupoDis: number | null
    IDGrupo: string | null
    IDDispositivo: string | null
  }

  export type ReldispositivogrupodispositivoCountAggregateOutputType = {
    IDRelDisGrupoDis: number
    IDGrupo: number
    IDDispositivo: number
    _all: number
  }


  export type ReldispositivogrupodispositivoAvgAggregateInputType = {
    IDRelDisGrupoDis?: true
  }

  export type ReldispositivogrupodispositivoSumAggregateInputType = {
    IDRelDisGrupoDis?: true
  }

  export type ReldispositivogrupodispositivoMinAggregateInputType = {
    IDRelDisGrupoDis?: true
    IDGrupo?: true
    IDDispositivo?: true
  }

  export type ReldispositivogrupodispositivoMaxAggregateInputType = {
    IDRelDisGrupoDis?: true
    IDGrupo?: true
    IDDispositivo?: true
  }

  export type ReldispositivogrupodispositivoCountAggregateInputType = {
    IDRelDisGrupoDis?: true
    IDGrupo?: true
    IDDispositivo?: true
    _all?: true
  }

  export type ReldispositivogrupodispositivoAggregateArgs = {
    /**
     * Filter which reldispositivogrupodispositivo to aggregate.
     * 
    **/
    where?: reldispositivogrupodispositivoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of reldispositivogrupodispositivos to fetch.
     * 
    **/
    orderBy?: Enumerable<reldispositivogrupodispositivoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: reldispositivogrupodispositivoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` reldispositivogrupodispositivos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` reldispositivogrupodispositivos.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned reldispositivogrupodispositivos
    **/
    _count?: true | ReldispositivogrupodispositivoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ReldispositivogrupodispositivoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ReldispositivogrupodispositivoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReldispositivogrupodispositivoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReldispositivogrupodispositivoMaxAggregateInputType
  }

  export type GetReldispositivogrupodispositivoAggregateType<T extends ReldispositivogrupodispositivoAggregateArgs> = {
        [P in keyof T & keyof AggregateReldispositivogrupodispositivo]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReldispositivogrupodispositivo[P]>
      : GetScalarType<T[P], AggregateReldispositivogrupodispositivo[P]>
  }




  export type ReldispositivogrupodispositivoGroupByArgs = {
    where?: reldispositivogrupodispositivoWhereInput
    orderBy?: Enumerable<reldispositivogrupodispositivoOrderByWithAggregationInput>
    by: Array<ReldispositivogrupodispositivoScalarFieldEnum>
    having?: reldispositivogrupodispositivoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReldispositivogrupodispositivoCountAggregateInputType | true
    _avg?: ReldispositivogrupodispositivoAvgAggregateInputType
    _sum?: ReldispositivogrupodispositivoSumAggregateInputType
    _min?: ReldispositivogrupodispositivoMinAggregateInputType
    _max?: ReldispositivogrupodispositivoMaxAggregateInputType
  }


  export type ReldispositivogrupodispositivoGroupByOutputType = {
    IDRelDisGrupoDis: number
    IDGrupo: string | null
    IDDispositivo: string | null
    _count: ReldispositivogrupodispositivoCountAggregateOutputType | null
    _avg: ReldispositivogrupodispositivoAvgAggregateOutputType | null
    _sum: ReldispositivogrupodispositivoSumAggregateOutputType | null
    _min: ReldispositivogrupodispositivoMinAggregateOutputType | null
    _max: ReldispositivogrupodispositivoMaxAggregateOutputType | null
  }

  type GetReldispositivogrupodispositivoGroupByPayload<T extends ReldispositivogrupodispositivoGroupByArgs> = PrismaPromise<
    Array<
      PickArray<ReldispositivogrupodispositivoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReldispositivogrupodispositivoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReldispositivogrupodispositivoGroupByOutputType[P]>
            : GetScalarType<T[P], ReldispositivogrupodispositivoGroupByOutputType[P]>
        }
      >
    >


  export type reldispositivogrupodispositivoSelect = {
    IDRelDisGrupoDis?: boolean
    IDGrupo?: boolean
    IDDispositivo?: boolean
  }


  export type reldispositivogrupodispositivoGetPayload<S extends boolean | null | undefined | reldispositivogrupodispositivoArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? reldispositivogrupodispositivo :
    S extends undefined ? never :
    S extends { include: any } & (reldispositivogrupodispositivoArgs | reldispositivogrupodispositivoFindManyArgs)
    ? reldispositivogrupodispositivo 
    : S extends { select: any } & (reldispositivogrupodispositivoArgs | reldispositivogrupodispositivoFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof reldispositivogrupodispositivo ? reldispositivogrupodispositivo[P] : never
  } 
      : reldispositivogrupodispositivo


  type reldispositivogrupodispositivoCountArgs = Merge<
    Omit<reldispositivogrupodispositivoFindManyArgs, 'select' | 'include'> & {
      select?: ReldispositivogrupodispositivoCountAggregateInputType | true
    }
  >

  export interface reldispositivogrupodispositivoDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Reldispositivogrupodispositivo that matches the filter.
     * @param {reldispositivogrupodispositivoFindUniqueArgs} args - Arguments to find a Reldispositivogrupodispositivo
     * @example
     * // Get one Reldispositivogrupodispositivo
     * const reldispositivogrupodispositivo = await prisma.reldispositivogrupodispositivo.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends reldispositivogrupodispositivoFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, reldispositivogrupodispositivoFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'reldispositivogrupodispositivo'> extends True ? Prisma__reldispositivogrupodispositivoClient<reldispositivogrupodispositivoGetPayload<T>> : Prisma__reldispositivogrupodispositivoClient<reldispositivogrupodispositivoGetPayload<T> | null, null>

    /**
     * Find one Reldispositivogrupodispositivo that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {reldispositivogrupodispositivoFindUniqueOrThrowArgs} args - Arguments to find a Reldispositivogrupodispositivo
     * @example
     * // Get one Reldispositivogrupodispositivo
     * const reldispositivogrupodispositivo = await prisma.reldispositivogrupodispositivo.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends reldispositivogrupodispositivoFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, reldispositivogrupodispositivoFindUniqueOrThrowArgs>
    ): Prisma__reldispositivogrupodispositivoClient<reldispositivogrupodispositivoGetPayload<T>>

    /**
     * Find the first Reldispositivogrupodispositivo that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reldispositivogrupodispositivoFindFirstArgs} args - Arguments to find a Reldispositivogrupodispositivo
     * @example
     * // Get one Reldispositivogrupodispositivo
     * const reldispositivogrupodispositivo = await prisma.reldispositivogrupodispositivo.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends reldispositivogrupodispositivoFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, reldispositivogrupodispositivoFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'reldispositivogrupodispositivo'> extends True ? Prisma__reldispositivogrupodispositivoClient<reldispositivogrupodispositivoGetPayload<T>> : Prisma__reldispositivogrupodispositivoClient<reldispositivogrupodispositivoGetPayload<T> | null, null>

    /**
     * Find the first Reldispositivogrupodispositivo that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reldispositivogrupodispositivoFindFirstOrThrowArgs} args - Arguments to find a Reldispositivogrupodispositivo
     * @example
     * // Get one Reldispositivogrupodispositivo
     * const reldispositivogrupodispositivo = await prisma.reldispositivogrupodispositivo.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends reldispositivogrupodispositivoFindFirstOrThrowArgs>(
      args?: SelectSubset<T, reldispositivogrupodispositivoFindFirstOrThrowArgs>
    ): Prisma__reldispositivogrupodispositivoClient<reldispositivogrupodispositivoGetPayload<T>>

    /**
     * Find zero or more Reldispositivogrupodispositivos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reldispositivogrupodispositivoFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Reldispositivogrupodispositivos
     * const reldispositivogrupodispositivos = await prisma.reldispositivogrupodispositivo.findMany()
     * 
     * // Get first 10 Reldispositivogrupodispositivos
     * const reldispositivogrupodispositivos = await prisma.reldispositivogrupodispositivo.findMany({ take: 10 })
     * 
     * // Only select the `IDRelDisGrupoDis`
     * const reldispositivogrupodispositivoWithIDRelDisGrupoDisOnly = await prisma.reldispositivogrupodispositivo.findMany({ select: { IDRelDisGrupoDis: true } })
     * 
    **/
    findMany<T extends reldispositivogrupodispositivoFindManyArgs>(
      args?: SelectSubset<T, reldispositivogrupodispositivoFindManyArgs>
    ): PrismaPromise<Array<reldispositivogrupodispositivoGetPayload<T>>>

    /**
     * Create a Reldispositivogrupodispositivo.
     * @param {reldispositivogrupodispositivoCreateArgs} args - Arguments to create a Reldispositivogrupodispositivo.
     * @example
     * // Create one Reldispositivogrupodispositivo
     * const Reldispositivogrupodispositivo = await prisma.reldispositivogrupodispositivo.create({
     *   data: {
     *     // ... data to create a Reldispositivogrupodispositivo
     *   }
     * })
     * 
    **/
    create<T extends reldispositivogrupodispositivoCreateArgs>(
      args: SelectSubset<T, reldispositivogrupodispositivoCreateArgs>
    ): Prisma__reldispositivogrupodispositivoClient<reldispositivogrupodispositivoGetPayload<T>>

    /**
     * Create many Reldispositivogrupodispositivos.
     *     @param {reldispositivogrupodispositivoCreateManyArgs} args - Arguments to create many Reldispositivogrupodispositivos.
     *     @example
     *     // Create many Reldispositivogrupodispositivos
     *     const reldispositivogrupodispositivo = await prisma.reldispositivogrupodispositivo.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends reldispositivogrupodispositivoCreateManyArgs>(
      args?: SelectSubset<T, reldispositivogrupodispositivoCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Reldispositivogrupodispositivo.
     * @param {reldispositivogrupodispositivoDeleteArgs} args - Arguments to delete one Reldispositivogrupodispositivo.
     * @example
     * // Delete one Reldispositivogrupodispositivo
     * const Reldispositivogrupodispositivo = await prisma.reldispositivogrupodispositivo.delete({
     *   where: {
     *     // ... filter to delete one Reldispositivogrupodispositivo
     *   }
     * })
     * 
    **/
    delete<T extends reldispositivogrupodispositivoDeleteArgs>(
      args: SelectSubset<T, reldispositivogrupodispositivoDeleteArgs>
    ): Prisma__reldispositivogrupodispositivoClient<reldispositivogrupodispositivoGetPayload<T>>

    /**
     * Update one Reldispositivogrupodispositivo.
     * @param {reldispositivogrupodispositivoUpdateArgs} args - Arguments to update one Reldispositivogrupodispositivo.
     * @example
     * // Update one Reldispositivogrupodispositivo
     * const reldispositivogrupodispositivo = await prisma.reldispositivogrupodispositivo.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends reldispositivogrupodispositivoUpdateArgs>(
      args: SelectSubset<T, reldispositivogrupodispositivoUpdateArgs>
    ): Prisma__reldispositivogrupodispositivoClient<reldispositivogrupodispositivoGetPayload<T>>

    /**
     * Delete zero or more Reldispositivogrupodispositivos.
     * @param {reldispositivogrupodispositivoDeleteManyArgs} args - Arguments to filter Reldispositivogrupodispositivos to delete.
     * @example
     * // Delete a few Reldispositivogrupodispositivos
     * const { count } = await prisma.reldispositivogrupodispositivo.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends reldispositivogrupodispositivoDeleteManyArgs>(
      args?: SelectSubset<T, reldispositivogrupodispositivoDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Reldispositivogrupodispositivos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reldispositivogrupodispositivoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Reldispositivogrupodispositivos
     * const reldispositivogrupodispositivo = await prisma.reldispositivogrupodispositivo.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends reldispositivogrupodispositivoUpdateManyArgs>(
      args: SelectSubset<T, reldispositivogrupodispositivoUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Reldispositivogrupodispositivo.
     * @param {reldispositivogrupodispositivoUpsertArgs} args - Arguments to update or create a Reldispositivogrupodispositivo.
     * @example
     * // Update or create a Reldispositivogrupodispositivo
     * const reldispositivogrupodispositivo = await prisma.reldispositivogrupodispositivo.upsert({
     *   create: {
     *     // ... data to create a Reldispositivogrupodispositivo
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Reldispositivogrupodispositivo we want to update
     *   }
     * })
    **/
    upsert<T extends reldispositivogrupodispositivoUpsertArgs>(
      args: SelectSubset<T, reldispositivogrupodispositivoUpsertArgs>
    ): Prisma__reldispositivogrupodispositivoClient<reldispositivogrupodispositivoGetPayload<T>>

    /**
     * Count the number of Reldispositivogrupodispositivos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reldispositivogrupodispositivoCountArgs} args - Arguments to filter Reldispositivogrupodispositivos to count.
     * @example
     * // Count the number of Reldispositivogrupodispositivos
     * const count = await prisma.reldispositivogrupodispositivo.count({
     *   where: {
     *     // ... the filter for the Reldispositivogrupodispositivos we want to count
     *   }
     * })
    **/
    count<T extends reldispositivogrupodispositivoCountArgs>(
      args?: Subset<T, reldispositivogrupodispositivoCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReldispositivogrupodispositivoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Reldispositivogrupodispositivo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReldispositivogrupodispositivoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReldispositivogrupodispositivoAggregateArgs>(args: Subset<T, ReldispositivogrupodispositivoAggregateArgs>): PrismaPromise<GetReldispositivogrupodispositivoAggregateType<T>>

    /**
     * Group by Reldispositivogrupodispositivo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReldispositivogrupodispositivoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReldispositivogrupodispositivoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReldispositivogrupodispositivoGroupByArgs['orderBy'] }
        : { orderBy?: ReldispositivogrupodispositivoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReldispositivogrupodispositivoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReldispositivogrupodispositivoGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for reldispositivogrupodispositivo.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__reldispositivogrupodispositivoClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * reldispositivogrupodispositivo base type for findUnique actions
   */
  export type reldispositivogrupodispositivoFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the reldispositivogrupodispositivo
     * 
    **/
    select?: reldispositivogrupodispositivoSelect | null
    /**
     * Filter, which reldispositivogrupodispositivo to fetch.
     * 
    **/
    where: reldispositivogrupodispositivoWhereUniqueInput
  }

  /**
   * reldispositivogrupodispositivo: findUnique
   */
  export interface reldispositivogrupodispositivoFindUniqueArgs extends reldispositivogrupodispositivoFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * reldispositivogrupodispositivo findUniqueOrThrow
   */
  export type reldispositivogrupodispositivoFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the reldispositivogrupodispositivo
     * 
    **/
    select?: reldispositivogrupodispositivoSelect | null
    /**
     * Filter, which reldispositivogrupodispositivo to fetch.
     * 
    **/
    where: reldispositivogrupodispositivoWhereUniqueInput
  }


  /**
   * reldispositivogrupodispositivo base type for findFirst actions
   */
  export type reldispositivogrupodispositivoFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the reldispositivogrupodispositivo
     * 
    **/
    select?: reldispositivogrupodispositivoSelect | null
    /**
     * Filter, which reldispositivogrupodispositivo to fetch.
     * 
    **/
    where?: reldispositivogrupodispositivoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of reldispositivogrupodispositivos to fetch.
     * 
    **/
    orderBy?: Enumerable<reldispositivogrupodispositivoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for reldispositivogrupodispositivos.
     * 
    **/
    cursor?: reldispositivogrupodispositivoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` reldispositivogrupodispositivos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` reldispositivogrupodispositivos.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of reldispositivogrupodispositivos.
     * 
    **/
    distinct?: Enumerable<ReldispositivogrupodispositivoScalarFieldEnum>
  }

  /**
   * reldispositivogrupodispositivo: findFirst
   */
  export interface reldispositivogrupodispositivoFindFirstArgs extends reldispositivogrupodispositivoFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * reldispositivogrupodispositivo findFirstOrThrow
   */
  export type reldispositivogrupodispositivoFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the reldispositivogrupodispositivo
     * 
    **/
    select?: reldispositivogrupodispositivoSelect | null
    /**
     * Filter, which reldispositivogrupodispositivo to fetch.
     * 
    **/
    where?: reldispositivogrupodispositivoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of reldispositivogrupodispositivos to fetch.
     * 
    **/
    orderBy?: Enumerable<reldispositivogrupodispositivoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for reldispositivogrupodispositivos.
     * 
    **/
    cursor?: reldispositivogrupodispositivoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` reldispositivogrupodispositivos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` reldispositivogrupodispositivos.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of reldispositivogrupodispositivos.
     * 
    **/
    distinct?: Enumerable<ReldispositivogrupodispositivoScalarFieldEnum>
  }


  /**
   * reldispositivogrupodispositivo findMany
   */
  export type reldispositivogrupodispositivoFindManyArgs = {
    /**
     * Select specific fields to fetch from the reldispositivogrupodispositivo
     * 
    **/
    select?: reldispositivogrupodispositivoSelect | null
    /**
     * Filter, which reldispositivogrupodispositivos to fetch.
     * 
    **/
    where?: reldispositivogrupodispositivoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of reldispositivogrupodispositivos to fetch.
     * 
    **/
    orderBy?: Enumerable<reldispositivogrupodispositivoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing reldispositivogrupodispositivos.
     * 
    **/
    cursor?: reldispositivogrupodispositivoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` reldispositivogrupodispositivos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` reldispositivogrupodispositivos.
     * 
    **/
    skip?: number
    distinct?: Enumerable<ReldispositivogrupodispositivoScalarFieldEnum>
  }


  /**
   * reldispositivogrupodispositivo create
   */
  export type reldispositivogrupodispositivoCreateArgs = {
    /**
     * Select specific fields to fetch from the reldispositivogrupodispositivo
     * 
    **/
    select?: reldispositivogrupodispositivoSelect | null
    /**
     * The data needed to create a reldispositivogrupodispositivo.
     * 
    **/
    data: XOR<reldispositivogrupodispositivoCreateInput, reldispositivogrupodispositivoUncheckedCreateInput>
  }


  /**
   * reldispositivogrupodispositivo createMany
   */
  export type reldispositivogrupodispositivoCreateManyArgs = {
    /**
     * The data used to create many reldispositivogrupodispositivos.
     * 
    **/
    data: Enumerable<reldispositivogrupodispositivoCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * reldispositivogrupodispositivo update
   */
  export type reldispositivogrupodispositivoUpdateArgs = {
    /**
     * Select specific fields to fetch from the reldispositivogrupodispositivo
     * 
    **/
    select?: reldispositivogrupodispositivoSelect | null
    /**
     * The data needed to update a reldispositivogrupodispositivo.
     * 
    **/
    data: XOR<reldispositivogrupodispositivoUpdateInput, reldispositivogrupodispositivoUncheckedUpdateInput>
    /**
     * Choose, which reldispositivogrupodispositivo to update.
     * 
    **/
    where: reldispositivogrupodispositivoWhereUniqueInput
  }


  /**
   * reldispositivogrupodispositivo updateMany
   */
  export type reldispositivogrupodispositivoUpdateManyArgs = {
    /**
     * The data used to update reldispositivogrupodispositivos.
     * 
    **/
    data: XOR<reldispositivogrupodispositivoUpdateManyMutationInput, reldispositivogrupodispositivoUncheckedUpdateManyInput>
    /**
     * Filter which reldispositivogrupodispositivos to update
     * 
    **/
    where?: reldispositivogrupodispositivoWhereInput
  }


  /**
   * reldispositivogrupodispositivo upsert
   */
  export type reldispositivogrupodispositivoUpsertArgs = {
    /**
     * Select specific fields to fetch from the reldispositivogrupodispositivo
     * 
    **/
    select?: reldispositivogrupodispositivoSelect | null
    /**
     * The filter to search for the reldispositivogrupodispositivo to update in case it exists.
     * 
    **/
    where: reldispositivogrupodispositivoWhereUniqueInput
    /**
     * In case the reldispositivogrupodispositivo found by the `where` argument doesn't exist, create a new reldispositivogrupodispositivo with this data.
     * 
    **/
    create: XOR<reldispositivogrupodispositivoCreateInput, reldispositivogrupodispositivoUncheckedCreateInput>
    /**
     * In case the reldispositivogrupodispositivo was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<reldispositivogrupodispositivoUpdateInput, reldispositivogrupodispositivoUncheckedUpdateInput>
  }


  /**
   * reldispositivogrupodispositivo delete
   */
  export type reldispositivogrupodispositivoDeleteArgs = {
    /**
     * Select specific fields to fetch from the reldispositivogrupodispositivo
     * 
    **/
    select?: reldispositivogrupodispositivoSelect | null
    /**
     * Filter which reldispositivogrupodispositivo to delete.
     * 
    **/
    where: reldispositivogrupodispositivoWhereUniqueInput
  }


  /**
   * reldispositivogrupodispositivo deleteMany
   */
  export type reldispositivogrupodispositivoDeleteManyArgs = {
    /**
     * Filter which reldispositivogrupodispositivos to delete
     * 
    **/
    where?: reldispositivogrupodispositivoWhereInput
  }


  /**
   * reldispositivogrupodispositivo without action
   */
  export type reldispositivogrupodispositivoArgs = {
    /**
     * Select specific fields to fetch from the reldispositivogrupodispositivo
     * 
    **/
    select?: reldispositivogrupodispositivoSelect | null
  }



  /**
   * Model reldispositivoperfildispositivo
   */


  export type AggregateReldispositivoperfildispositivo = {
    _count: ReldispositivoperfildispositivoCountAggregateOutputType | null
    _avg: ReldispositivoperfildispositivoAvgAggregateOutputType | null
    _sum: ReldispositivoperfildispositivoSumAggregateOutputType | null
    _min: ReldispositivoperfildispositivoMinAggregateOutputType | null
    _max: ReldispositivoperfildispositivoMaxAggregateOutputType | null
  }

  export type ReldispositivoperfildispositivoAvgAggregateOutputType = {
    IDRelDisPerfil: number | null
    IDDispositivo: number | null
    IDPerfilDispositivo: number | null
  }

  export type ReldispositivoperfildispositivoSumAggregateOutputType = {
    IDRelDisPerfil: number | null
    IDDispositivo: number | null
    IDPerfilDispositivo: number | null
  }

  export type ReldispositivoperfildispositivoMinAggregateOutputType = {
    IDRelDisPerfil: number | null
    IDDispositivo: number | null
    IDPerfilDispositivo: number | null
  }

  export type ReldispositivoperfildispositivoMaxAggregateOutputType = {
    IDRelDisPerfil: number | null
    IDDispositivo: number | null
    IDPerfilDispositivo: number | null
  }

  export type ReldispositivoperfildispositivoCountAggregateOutputType = {
    IDRelDisPerfil: number
    IDDispositivo: number
    IDPerfilDispositivo: number
    _all: number
  }


  export type ReldispositivoperfildispositivoAvgAggregateInputType = {
    IDRelDisPerfil?: true
    IDDispositivo?: true
    IDPerfilDispositivo?: true
  }

  export type ReldispositivoperfildispositivoSumAggregateInputType = {
    IDRelDisPerfil?: true
    IDDispositivo?: true
    IDPerfilDispositivo?: true
  }

  export type ReldispositivoperfildispositivoMinAggregateInputType = {
    IDRelDisPerfil?: true
    IDDispositivo?: true
    IDPerfilDispositivo?: true
  }

  export type ReldispositivoperfildispositivoMaxAggregateInputType = {
    IDRelDisPerfil?: true
    IDDispositivo?: true
    IDPerfilDispositivo?: true
  }

  export type ReldispositivoperfildispositivoCountAggregateInputType = {
    IDRelDisPerfil?: true
    IDDispositivo?: true
    IDPerfilDispositivo?: true
    _all?: true
  }

  export type ReldispositivoperfildispositivoAggregateArgs = {
    /**
     * Filter which reldispositivoperfildispositivo to aggregate.
     * 
    **/
    where?: reldispositivoperfildispositivoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of reldispositivoperfildispositivos to fetch.
     * 
    **/
    orderBy?: Enumerable<reldispositivoperfildispositivoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: reldispositivoperfildispositivoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` reldispositivoperfildispositivos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` reldispositivoperfildispositivos.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned reldispositivoperfildispositivos
    **/
    _count?: true | ReldispositivoperfildispositivoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ReldispositivoperfildispositivoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ReldispositivoperfildispositivoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReldispositivoperfildispositivoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReldispositivoperfildispositivoMaxAggregateInputType
  }

  export type GetReldispositivoperfildispositivoAggregateType<T extends ReldispositivoperfildispositivoAggregateArgs> = {
        [P in keyof T & keyof AggregateReldispositivoperfildispositivo]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReldispositivoperfildispositivo[P]>
      : GetScalarType<T[P], AggregateReldispositivoperfildispositivo[P]>
  }




  export type ReldispositivoperfildispositivoGroupByArgs = {
    where?: reldispositivoperfildispositivoWhereInput
    orderBy?: Enumerable<reldispositivoperfildispositivoOrderByWithAggregationInput>
    by: Array<ReldispositivoperfildispositivoScalarFieldEnum>
    having?: reldispositivoperfildispositivoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReldispositivoperfildispositivoCountAggregateInputType | true
    _avg?: ReldispositivoperfildispositivoAvgAggregateInputType
    _sum?: ReldispositivoperfildispositivoSumAggregateInputType
    _min?: ReldispositivoperfildispositivoMinAggregateInputType
    _max?: ReldispositivoperfildispositivoMaxAggregateInputType
  }


  export type ReldispositivoperfildispositivoGroupByOutputType = {
    IDRelDisPerfil: number
    IDDispositivo: number
    IDPerfilDispositivo: number
    _count: ReldispositivoperfildispositivoCountAggregateOutputType | null
    _avg: ReldispositivoperfildispositivoAvgAggregateOutputType | null
    _sum: ReldispositivoperfildispositivoSumAggregateOutputType | null
    _min: ReldispositivoperfildispositivoMinAggregateOutputType | null
    _max: ReldispositivoperfildispositivoMaxAggregateOutputType | null
  }

  type GetReldispositivoperfildispositivoGroupByPayload<T extends ReldispositivoperfildispositivoGroupByArgs> = PrismaPromise<
    Array<
      PickArray<ReldispositivoperfildispositivoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReldispositivoperfildispositivoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReldispositivoperfildispositivoGroupByOutputType[P]>
            : GetScalarType<T[P], ReldispositivoperfildispositivoGroupByOutputType[P]>
        }
      >
    >


  export type reldispositivoperfildispositivoSelect = {
    IDRelDisPerfil?: boolean
    IDDispositivo?: boolean
    IDPerfilDispositivo?: boolean
  }


  export type reldispositivoperfildispositivoGetPayload<S extends boolean | null | undefined | reldispositivoperfildispositivoArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? reldispositivoperfildispositivo :
    S extends undefined ? never :
    S extends { include: any } & (reldispositivoperfildispositivoArgs | reldispositivoperfildispositivoFindManyArgs)
    ? reldispositivoperfildispositivo 
    : S extends { select: any } & (reldispositivoperfildispositivoArgs | reldispositivoperfildispositivoFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof reldispositivoperfildispositivo ? reldispositivoperfildispositivo[P] : never
  } 
      : reldispositivoperfildispositivo


  type reldispositivoperfildispositivoCountArgs = Merge<
    Omit<reldispositivoperfildispositivoFindManyArgs, 'select' | 'include'> & {
      select?: ReldispositivoperfildispositivoCountAggregateInputType | true
    }
  >

  export interface reldispositivoperfildispositivoDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Reldispositivoperfildispositivo that matches the filter.
     * @param {reldispositivoperfildispositivoFindUniqueArgs} args - Arguments to find a Reldispositivoperfildispositivo
     * @example
     * // Get one Reldispositivoperfildispositivo
     * const reldispositivoperfildispositivo = await prisma.reldispositivoperfildispositivo.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends reldispositivoperfildispositivoFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, reldispositivoperfildispositivoFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'reldispositivoperfildispositivo'> extends True ? Prisma__reldispositivoperfildispositivoClient<reldispositivoperfildispositivoGetPayload<T>> : Prisma__reldispositivoperfildispositivoClient<reldispositivoperfildispositivoGetPayload<T> | null, null>

    /**
     * Find one Reldispositivoperfildispositivo that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {reldispositivoperfildispositivoFindUniqueOrThrowArgs} args - Arguments to find a Reldispositivoperfildispositivo
     * @example
     * // Get one Reldispositivoperfildispositivo
     * const reldispositivoperfildispositivo = await prisma.reldispositivoperfildispositivo.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends reldispositivoperfildispositivoFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, reldispositivoperfildispositivoFindUniqueOrThrowArgs>
    ): Prisma__reldispositivoperfildispositivoClient<reldispositivoperfildispositivoGetPayload<T>>

    /**
     * Find the first Reldispositivoperfildispositivo that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reldispositivoperfildispositivoFindFirstArgs} args - Arguments to find a Reldispositivoperfildispositivo
     * @example
     * // Get one Reldispositivoperfildispositivo
     * const reldispositivoperfildispositivo = await prisma.reldispositivoperfildispositivo.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends reldispositivoperfildispositivoFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, reldispositivoperfildispositivoFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'reldispositivoperfildispositivo'> extends True ? Prisma__reldispositivoperfildispositivoClient<reldispositivoperfildispositivoGetPayload<T>> : Prisma__reldispositivoperfildispositivoClient<reldispositivoperfildispositivoGetPayload<T> | null, null>

    /**
     * Find the first Reldispositivoperfildispositivo that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reldispositivoperfildispositivoFindFirstOrThrowArgs} args - Arguments to find a Reldispositivoperfildispositivo
     * @example
     * // Get one Reldispositivoperfildispositivo
     * const reldispositivoperfildispositivo = await prisma.reldispositivoperfildispositivo.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends reldispositivoperfildispositivoFindFirstOrThrowArgs>(
      args?: SelectSubset<T, reldispositivoperfildispositivoFindFirstOrThrowArgs>
    ): Prisma__reldispositivoperfildispositivoClient<reldispositivoperfildispositivoGetPayload<T>>

    /**
     * Find zero or more Reldispositivoperfildispositivos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reldispositivoperfildispositivoFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Reldispositivoperfildispositivos
     * const reldispositivoperfildispositivos = await prisma.reldispositivoperfildispositivo.findMany()
     * 
     * // Get first 10 Reldispositivoperfildispositivos
     * const reldispositivoperfildispositivos = await prisma.reldispositivoperfildispositivo.findMany({ take: 10 })
     * 
     * // Only select the `IDRelDisPerfil`
     * const reldispositivoperfildispositivoWithIDRelDisPerfilOnly = await prisma.reldispositivoperfildispositivo.findMany({ select: { IDRelDisPerfil: true } })
     * 
    **/
    findMany<T extends reldispositivoperfildispositivoFindManyArgs>(
      args?: SelectSubset<T, reldispositivoperfildispositivoFindManyArgs>
    ): PrismaPromise<Array<reldispositivoperfildispositivoGetPayload<T>>>

    /**
     * Create a Reldispositivoperfildispositivo.
     * @param {reldispositivoperfildispositivoCreateArgs} args - Arguments to create a Reldispositivoperfildispositivo.
     * @example
     * // Create one Reldispositivoperfildispositivo
     * const Reldispositivoperfildispositivo = await prisma.reldispositivoperfildispositivo.create({
     *   data: {
     *     // ... data to create a Reldispositivoperfildispositivo
     *   }
     * })
     * 
    **/
    create<T extends reldispositivoperfildispositivoCreateArgs>(
      args: SelectSubset<T, reldispositivoperfildispositivoCreateArgs>
    ): Prisma__reldispositivoperfildispositivoClient<reldispositivoperfildispositivoGetPayload<T>>

    /**
     * Create many Reldispositivoperfildispositivos.
     *     @param {reldispositivoperfildispositivoCreateManyArgs} args - Arguments to create many Reldispositivoperfildispositivos.
     *     @example
     *     // Create many Reldispositivoperfildispositivos
     *     const reldispositivoperfildispositivo = await prisma.reldispositivoperfildispositivo.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends reldispositivoperfildispositivoCreateManyArgs>(
      args?: SelectSubset<T, reldispositivoperfildispositivoCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Reldispositivoperfildispositivo.
     * @param {reldispositivoperfildispositivoDeleteArgs} args - Arguments to delete one Reldispositivoperfildispositivo.
     * @example
     * // Delete one Reldispositivoperfildispositivo
     * const Reldispositivoperfildispositivo = await prisma.reldispositivoperfildispositivo.delete({
     *   where: {
     *     // ... filter to delete one Reldispositivoperfildispositivo
     *   }
     * })
     * 
    **/
    delete<T extends reldispositivoperfildispositivoDeleteArgs>(
      args: SelectSubset<T, reldispositivoperfildispositivoDeleteArgs>
    ): Prisma__reldispositivoperfildispositivoClient<reldispositivoperfildispositivoGetPayload<T>>

    /**
     * Update one Reldispositivoperfildispositivo.
     * @param {reldispositivoperfildispositivoUpdateArgs} args - Arguments to update one Reldispositivoperfildispositivo.
     * @example
     * // Update one Reldispositivoperfildispositivo
     * const reldispositivoperfildispositivo = await prisma.reldispositivoperfildispositivo.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends reldispositivoperfildispositivoUpdateArgs>(
      args: SelectSubset<T, reldispositivoperfildispositivoUpdateArgs>
    ): Prisma__reldispositivoperfildispositivoClient<reldispositivoperfildispositivoGetPayload<T>>

    /**
     * Delete zero or more Reldispositivoperfildispositivos.
     * @param {reldispositivoperfildispositivoDeleteManyArgs} args - Arguments to filter Reldispositivoperfildispositivos to delete.
     * @example
     * // Delete a few Reldispositivoperfildispositivos
     * const { count } = await prisma.reldispositivoperfildispositivo.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends reldispositivoperfildispositivoDeleteManyArgs>(
      args?: SelectSubset<T, reldispositivoperfildispositivoDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Reldispositivoperfildispositivos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reldispositivoperfildispositivoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Reldispositivoperfildispositivos
     * const reldispositivoperfildispositivo = await prisma.reldispositivoperfildispositivo.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends reldispositivoperfildispositivoUpdateManyArgs>(
      args: SelectSubset<T, reldispositivoperfildispositivoUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Reldispositivoperfildispositivo.
     * @param {reldispositivoperfildispositivoUpsertArgs} args - Arguments to update or create a Reldispositivoperfildispositivo.
     * @example
     * // Update or create a Reldispositivoperfildispositivo
     * const reldispositivoperfildispositivo = await prisma.reldispositivoperfildispositivo.upsert({
     *   create: {
     *     // ... data to create a Reldispositivoperfildispositivo
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Reldispositivoperfildispositivo we want to update
     *   }
     * })
    **/
    upsert<T extends reldispositivoperfildispositivoUpsertArgs>(
      args: SelectSubset<T, reldispositivoperfildispositivoUpsertArgs>
    ): Prisma__reldispositivoperfildispositivoClient<reldispositivoperfildispositivoGetPayload<T>>

    /**
     * Count the number of Reldispositivoperfildispositivos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reldispositivoperfildispositivoCountArgs} args - Arguments to filter Reldispositivoperfildispositivos to count.
     * @example
     * // Count the number of Reldispositivoperfildispositivos
     * const count = await prisma.reldispositivoperfildispositivo.count({
     *   where: {
     *     // ... the filter for the Reldispositivoperfildispositivos we want to count
     *   }
     * })
    **/
    count<T extends reldispositivoperfildispositivoCountArgs>(
      args?: Subset<T, reldispositivoperfildispositivoCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReldispositivoperfildispositivoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Reldispositivoperfildispositivo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReldispositivoperfildispositivoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReldispositivoperfildispositivoAggregateArgs>(args: Subset<T, ReldispositivoperfildispositivoAggregateArgs>): PrismaPromise<GetReldispositivoperfildispositivoAggregateType<T>>

    /**
     * Group by Reldispositivoperfildispositivo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReldispositivoperfildispositivoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReldispositivoperfildispositivoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReldispositivoperfildispositivoGroupByArgs['orderBy'] }
        : { orderBy?: ReldispositivoperfildispositivoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReldispositivoperfildispositivoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReldispositivoperfildispositivoGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for reldispositivoperfildispositivo.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__reldispositivoperfildispositivoClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * reldispositivoperfildispositivo base type for findUnique actions
   */
  export type reldispositivoperfildispositivoFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the reldispositivoperfildispositivo
     * 
    **/
    select?: reldispositivoperfildispositivoSelect | null
    /**
     * Filter, which reldispositivoperfildispositivo to fetch.
     * 
    **/
    where: reldispositivoperfildispositivoWhereUniqueInput
  }

  /**
   * reldispositivoperfildispositivo: findUnique
   */
  export interface reldispositivoperfildispositivoFindUniqueArgs extends reldispositivoperfildispositivoFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * reldispositivoperfildispositivo findUniqueOrThrow
   */
  export type reldispositivoperfildispositivoFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the reldispositivoperfildispositivo
     * 
    **/
    select?: reldispositivoperfildispositivoSelect | null
    /**
     * Filter, which reldispositivoperfildispositivo to fetch.
     * 
    **/
    where: reldispositivoperfildispositivoWhereUniqueInput
  }


  /**
   * reldispositivoperfildispositivo base type for findFirst actions
   */
  export type reldispositivoperfildispositivoFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the reldispositivoperfildispositivo
     * 
    **/
    select?: reldispositivoperfildispositivoSelect | null
    /**
     * Filter, which reldispositivoperfildispositivo to fetch.
     * 
    **/
    where?: reldispositivoperfildispositivoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of reldispositivoperfildispositivos to fetch.
     * 
    **/
    orderBy?: Enumerable<reldispositivoperfildispositivoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for reldispositivoperfildispositivos.
     * 
    **/
    cursor?: reldispositivoperfildispositivoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` reldispositivoperfildispositivos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` reldispositivoperfildispositivos.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of reldispositivoperfildispositivos.
     * 
    **/
    distinct?: Enumerable<ReldispositivoperfildispositivoScalarFieldEnum>
  }

  /**
   * reldispositivoperfildispositivo: findFirst
   */
  export interface reldispositivoperfildispositivoFindFirstArgs extends reldispositivoperfildispositivoFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * reldispositivoperfildispositivo findFirstOrThrow
   */
  export type reldispositivoperfildispositivoFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the reldispositivoperfildispositivo
     * 
    **/
    select?: reldispositivoperfildispositivoSelect | null
    /**
     * Filter, which reldispositivoperfildispositivo to fetch.
     * 
    **/
    where?: reldispositivoperfildispositivoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of reldispositivoperfildispositivos to fetch.
     * 
    **/
    orderBy?: Enumerable<reldispositivoperfildispositivoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for reldispositivoperfildispositivos.
     * 
    **/
    cursor?: reldispositivoperfildispositivoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` reldispositivoperfildispositivos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` reldispositivoperfildispositivos.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of reldispositivoperfildispositivos.
     * 
    **/
    distinct?: Enumerable<ReldispositivoperfildispositivoScalarFieldEnum>
  }


  /**
   * reldispositivoperfildispositivo findMany
   */
  export type reldispositivoperfildispositivoFindManyArgs = {
    /**
     * Select specific fields to fetch from the reldispositivoperfildispositivo
     * 
    **/
    select?: reldispositivoperfildispositivoSelect | null
    /**
     * Filter, which reldispositivoperfildispositivos to fetch.
     * 
    **/
    where?: reldispositivoperfildispositivoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of reldispositivoperfildispositivos to fetch.
     * 
    **/
    orderBy?: Enumerable<reldispositivoperfildispositivoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing reldispositivoperfildispositivos.
     * 
    **/
    cursor?: reldispositivoperfildispositivoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` reldispositivoperfildispositivos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` reldispositivoperfildispositivos.
     * 
    **/
    skip?: number
    distinct?: Enumerable<ReldispositivoperfildispositivoScalarFieldEnum>
  }


  /**
   * reldispositivoperfildispositivo create
   */
  export type reldispositivoperfildispositivoCreateArgs = {
    /**
     * Select specific fields to fetch from the reldispositivoperfildispositivo
     * 
    **/
    select?: reldispositivoperfildispositivoSelect | null
    /**
     * The data needed to create a reldispositivoperfildispositivo.
     * 
    **/
    data: XOR<reldispositivoperfildispositivoCreateInput, reldispositivoperfildispositivoUncheckedCreateInput>
  }


  /**
   * reldispositivoperfildispositivo createMany
   */
  export type reldispositivoperfildispositivoCreateManyArgs = {
    /**
     * The data used to create many reldispositivoperfildispositivos.
     * 
    **/
    data: Enumerable<reldispositivoperfildispositivoCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * reldispositivoperfildispositivo update
   */
  export type reldispositivoperfildispositivoUpdateArgs = {
    /**
     * Select specific fields to fetch from the reldispositivoperfildispositivo
     * 
    **/
    select?: reldispositivoperfildispositivoSelect | null
    /**
     * The data needed to update a reldispositivoperfildispositivo.
     * 
    **/
    data: XOR<reldispositivoperfildispositivoUpdateInput, reldispositivoperfildispositivoUncheckedUpdateInput>
    /**
     * Choose, which reldispositivoperfildispositivo to update.
     * 
    **/
    where: reldispositivoperfildispositivoWhereUniqueInput
  }


  /**
   * reldispositivoperfildispositivo updateMany
   */
  export type reldispositivoperfildispositivoUpdateManyArgs = {
    /**
     * The data used to update reldispositivoperfildispositivos.
     * 
    **/
    data: XOR<reldispositivoperfildispositivoUpdateManyMutationInput, reldispositivoperfildispositivoUncheckedUpdateManyInput>
    /**
     * Filter which reldispositivoperfildispositivos to update
     * 
    **/
    where?: reldispositivoperfildispositivoWhereInput
  }


  /**
   * reldispositivoperfildispositivo upsert
   */
  export type reldispositivoperfildispositivoUpsertArgs = {
    /**
     * Select specific fields to fetch from the reldispositivoperfildispositivo
     * 
    **/
    select?: reldispositivoperfildispositivoSelect | null
    /**
     * The filter to search for the reldispositivoperfildispositivo to update in case it exists.
     * 
    **/
    where: reldispositivoperfildispositivoWhereUniqueInput
    /**
     * In case the reldispositivoperfildispositivo found by the `where` argument doesn't exist, create a new reldispositivoperfildispositivo with this data.
     * 
    **/
    create: XOR<reldispositivoperfildispositivoCreateInput, reldispositivoperfildispositivoUncheckedCreateInput>
    /**
     * In case the reldispositivoperfildispositivo was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<reldispositivoperfildispositivoUpdateInput, reldispositivoperfildispositivoUncheckedUpdateInput>
  }


  /**
   * reldispositivoperfildispositivo delete
   */
  export type reldispositivoperfildispositivoDeleteArgs = {
    /**
     * Select specific fields to fetch from the reldispositivoperfildispositivo
     * 
    **/
    select?: reldispositivoperfildispositivoSelect | null
    /**
     * Filter which reldispositivoperfildispositivo to delete.
     * 
    **/
    where: reldispositivoperfildispositivoWhereUniqueInput
  }


  /**
   * reldispositivoperfildispositivo deleteMany
   */
  export type reldispositivoperfildispositivoDeleteManyArgs = {
    /**
     * Filter which reldispositivoperfildispositivos to delete
     * 
    **/
    where?: reldispositivoperfildispositivoWhereInput
  }


  /**
   * reldispositivoperfildispositivo without action
   */
  export type reldispositivoperfildispositivoArgs = {
    /**
     * Select specific fields to fetch from the reldispositivoperfildispositivo
     * 
    **/
    select?: reldispositivoperfildispositivoSelect | null
  }



  /**
   * Model reldispositivoplantillaanalogica
   */


  export type AggregateReldispositivoplantillaanalogica = {
    _count: ReldispositivoplantillaanalogicaCountAggregateOutputType | null
    _avg: ReldispositivoplantillaanalogicaAvgAggregateOutputType | null
    _sum: ReldispositivoplantillaanalogicaSumAggregateOutputType | null
    _min: ReldispositivoplantillaanalogicaMinAggregateOutputType | null
    _max: ReldispositivoplantillaanalogicaMaxAggregateOutputType | null
  }

  export type ReldispositivoplantillaanalogicaAvgAggregateOutputType = {
    IDRelDisPlantillaAnaloga: number | null
    IDPlantillaAnalogica: number | null
    IDDispositivo: number | null
  }

  export type ReldispositivoplantillaanalogicaSumAggregateOutputType = {
    IDRelDisPlantillaAnaloga: number | null
    IDPlantillaAnalogica: number | null
    IDDispositivo: number | null
  }

  export type ReldispositivoplantillaanalogicaMinAggregateOutputType = {
    IDRelDisPlantillaAnaloga: number | null
    IDPlantillaAnalogica: number | null
    IDDispositivo: number | null
    Formula: string | null
    Version: string | null
  }

  export type ReldispositivoplantillaanalogicaMaxAggregateOutputType = {
    IDRelDisPlantillaAnaloga: number | null
    IDPlantillaAnalogica: number | null
    IDDispositivo: number | null
    Formula: string | null
    Version: string | null
  }

  export type ReldispositivoplantillaanalogicaCountAggregateOutputType = {
    IDRelDisPlantillaAnaloga: number
    IDPlantillaAnalogica: number
    IDDispositivo: number
    Formula: number
    Version: number
    _all: number
  }


  export type ReldispositivoplantillaanalogicaAvgAggregateInputType = {
    IDRelDisPlantillaAnaloga?: true
    IDPlantillaAnalogica?: true
    IDDispositivo?: true
  }

  export type ReldispositivoplantillaanalogicaSumAggregateInputType = {
    IDRelDisPlantillaAnaloga?: true
    IDPlantillaAnalogica?: true
    IDDispositivo?: true
  }

  export type ReldispositivoplantillaanalogicaMinAggregateInputType = {
    IDRelDisPlantillaAnaloga?: true
    IDPlantillaAnalogica?: true
    IDDispositivo?: true
    Formula?: true
    Version?: true
  }

  export type ReldispositivoplantillaanalogicaMaxAggregateInputType = {
    IDRelDisPlantillaAnaloga?: true
    IDPlantillaAnalogica?: true
    IDDispositivo?: true
    Formula?: true
    Version?: true
  }

  export type ReldispositivoplantillaanalogicaCountAggregateInputType = {
    IDRelDisPlantillaAnaloga?: true
    IDPlantillaAnalogica?: true
    IDDispositivo?: true
    Formula?: true
    Version?: true
    _all?: true
  }

  export type ReldispositivoplantillaanalogicaAggregateArgs = {
    /**
     * Filter which reldispositivoplantillaanalogica to aggregate.
     * 
    **/
    where?: reldispositivoplantillaanalogicaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of reldispositivoplantillaanalogicas to fetch.
     * 
    **/
    orderBy?: Enumerable<reldispositivoplantillaanalogicaOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: reldispositivoplantillaanalogicaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` reldispositivoplantillaanalogicas from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` reldispositivoplantillaanalogicas.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned reldispositivoplantillaanalogicas
    **/
    _count?: true | ReldispositivoplantillaanalogicaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ReldispositivoplantillaanalogicaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ReldispositivoplantillaanalogicaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReldispositivoplantillaanalogicaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReldispositivoplantillaanalogicaMaxAggregateInputType
  }

  export type GetReldispositivoplantillaanalogicaAggregateType<T extends ReldispositivoplantillaanalogicaAggregateArgs> = {
        [P in keyof T & keyof AggregateReldispositivoplantillaanalogica]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReldispositivoplantillaanalogica[P]>
      : GetScalarType<T[P], AggregateReldispositivoplantillaanalogica[P]>
  }




  export type ReldispositivoplantillaanalogicaGroupByArgs = {
    where?: reldispositivoplantillaanalogicaWhereInput
    orderBy?: Enumerable<reldispositivoplantillaanalogicaOrderByWithAggregationInput>
    by: Array<ReldispositivoplantillaanalogicaScalarFieldEnum>
    having?: reldispositivoplantillaanalogicaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReldispositivoplantillaanalogicaCountAggregateInputType | true
    _avg?: ReldispositivoplantillaanalogicaAvgAggregateInputType
    _sum?: ReldispositivoplantillaanalogicaSumAggregateInputType
    _min?: ReldispositivoplantillaanalogicaMinAggregateInputType
    _max?: ReldispositivoplantillaanalogicaMaxAggregateInputType
  }


  export type ReldispositivoplantillaanalogicaGroupByOutputType = {
    IDRelDisPlantillaAnaloga: number
    IDPlantillaAnalogica: number
    IDDispositivo: number
    Formula: string | null
    Version: string | null
    _count: ReldispositivoplantillaanalogicaCountAggregateOutputType | null
    _avg: ReldispositivoplantillaanalogicaAvgAggregateOutputType | null
    _sum: ReldispositivoplantillaanalogicaSumAggregateOutputType | null
    _min: ReldispositivoplantillaanalogicaMinAggregateOutputType | null
    _max: ReldispositivoplantillaanalogicaMaxAggregateOutputType | null
  }

  type GetReldispositivoplantillaanalogicaGroupByPayload<T extends ReldispositivoplantillaanalogicaGroupByArgs> = PrismaPromise<
    Array<
      PickArray<ReldispositivoplantillaanalogicaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReldispositivoplantillaanalogicaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReldispositivoplantillaanalogicaGroupByOutputType[P]>
            : GetScalarType<T[P], ReldispositivoplantillaanalogicaGroupByOutputType[P]>
        }
      >
    >


  export type reldispositivoplantillaanalogicaSelect = {
    IDRelDisPlantillaAnaloga?: boolean
    IDPlantillaAnalogica?: boolean
    IDDispositivo?: boolean
    Formula?: boolean
    Version?: boolean
  }


  export type reldispositivoplantillaanalogicaGetPayload<S extends boolean | null | undefined | reldispositivoplantillaanalogicaArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? reldispositivoplantillaanalogica :
    S extends undefined ? never :
    S extends { include: any } & (reldispositivoplantillaanalogicaArgs | reldispositivoplantillaanalogicaFindManyArgs)
    ? reldispositivoplantillaanalogica 
    : S extends { select: any } & (reldispositivoplantillaanalogicaArgs | reldispositivoplantillaanalogicaFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof reldispositivoplantillaanalogica ? reldispositivoplantillaanalogica[P] : never
  } 
      : reldispositivoplantillaanalogica


  type reldispositivoplantillaanalogicaCountArgs = Merge<
    Omit<reldispositivoplantillaanalogicaFindManyArgs, 'select' | 'include'> & {
      select?: ReldispositivoplantillaanalogicaCountAggregateInputType | true
    }
  >

  export interface reldispositivoplantillaanalogicaDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Reldispositivoplantillaanalogica that matches the filter.
     * @param {reldispositivoplantillaanalogicaFindUniqueArgs} args - Arguments to find a Reldispositivoplantillaanalogica
     * @example
     * // Get one Reldispositivoplantillaanalogica
     * const reldispositivoplantillaanalogica = await prisma.reldispositivoplantillaanalogica.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends reldispositivoplantillaanalogicaFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, reldispositivoplantillaanalogicaFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'reldispositivoplantillaanalogica'> extends True ? Prisma__reldispositivoplantillaanalogicaClient<reldispositivoplantillaanalogicaGetPayload<T>> : Prisma__reldispositivoplantillaanalogicaClient<reldispositivoplantillaanalogicaGetPayload<T> | null, null>

    /**
     * Find one Reldispositivoplantillaanalogica that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {reldispositivoplantillaanalogicaFindUniqueOrThrowArgs} args - Arguments to find a Reldispositivoplantillaanalogica
     * @example
     * // Get one Reldispositivoplantillaanalogica
     * const reldispositivoplantillaanalogica = await prisma.reldispositivoplantillaanalogica.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends reldispositivoplantillaanalogicaFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, reldispositivoplantillaanalogicaFindUniqueOrThrowArgs>
    ): Prisma__reldispositivoplantillaanalogicaClient<reldispositivoplantillaanalogicaGetPayload<T>>

    /**
     * Find the first Reldispositivoplantillaanalogica that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reldispositivoplantillaanalogicaFindFirstArgs} args - Arguments to find a Reldispositivoplantillaanalogica
     * @example
     * // Get one Reldispositivoplantillaanalogica
     * const reldispositivoplantillaanalogica = await prisma.reldispositivoplantillaanalogica.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends reldispositivoplantillaanalogicaFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, reldispositivoplantillaanalogicaFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'reldispositivoplantillaanalogica'> extends True ? Prisma__reldispositivoplantillaanalogicaClient<reldispositivoplantillaanalogicaGetPayload<T>> : Prisma__reldispositivoplantillaanalogicaClient<reldispositivoplantillaanalogicaGetPayload<T> | null, null>

    /**
     * Find the first Reldispositivoplantillaanalogica that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reldispositivoplantillaanalogicaFindFirstOrThrowArgs} args - Arguments to find a Reldispositivoplantillaanalogica
     * @example
     * // Get one Reldispositivoplantillaanalogica
     * const reldispositivoplantillaanalogica = await prisma.reldispositivoplantillaanalogica.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends reldispositivoplantillaanalogicaFindFirstOrThrowArgs>(
      args?: SelectSubset<T, reldispositivoplantillaanalogicaFindFirstOrThrowArgs>
    ): Prisma__reldispositivoplantillaanalogicaClient<reldispositivoplantillaanalogicaGetPayload<T>>

    /**
     * Find zero or more Reldispositivoplantillaanalogicas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reldispositivoplantillaanalogicaFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Reldispositivoplantillaanalogicas
     * const reldispositivoplantillaanalogicas = await prisma.reldispositivoplantillaanalogica.findMany()
     * 
     * // Get first 10 Reldispositivoplantillaanalogicas
     * const reldispositivoplantillaanalogicas = await prisma.reldispositivoplantillaanalogica.findMany({ take: 10 })
     * 
     * // Only select the `IDRelDisPlantillaAnaloga`
     * const reldispositivoplantillaanalogicaWithIDRelDisPlantillaAnalogaOnly = await prisma.reldispositivoplantillaanalogica.findMany({ select: { IDRelDisPlantillaAnaloga: true } })
     * 
    **/
    findMany<T extends reldispositivoplantillaanalogicaFindManyArgs>(
      args?: SelectSubset<T, reldispositivoplantillaanalogicaFindManyArgs>
    ): PrismaPromise<Array<reldispositivoplantillaanalogicaGetPayload<T>>>

    /**
     * Create a Reldispositivoplantillaanalogica.
     * @param {reldispositivoplantillaanalogicaCreateArgs} args - Arguments to create a Reldispositivoplantillaanalogica.
     * @example
     * // Create one Reldispositivoplantillaanalogica
     * const Reldispositivoplantillaanalogica = await prisma.reldispositivoplantillaanalogica.create({
     *   data: {
     *     // ... data to create a Reldispositivoplantillaanalogica
     *   }
     * })
     * 
    **/
    create<T extends reldispositivoplantillaanalogicaCreateArgs>(
      args: SelectSubset<T, reldispositivoplantillaanalogicaCreateArgs>
    ): Prisma__reldispositivoplantillaanalogicaClient<reldispositivoplantillaanalogicaGetPayload<T>>

    /**
     * Create many Reldispositivoplantillaanalogicas.
     *     @param {reldispositivoplantillaanalogicaCreateManyArgs} args - Arguments to create many Reldispositivoplantillaanalogicas.
     *     @example
     *     // Create many Reldispositivoplantillaanalogicas
     *     const reldispositivoplantillaanalogica = await prisma.reldispositivoplantillaanalogica.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends reldispositivoplantillaanalogicaCreateManyArgs>(
      args?: SelectSubset<T, reldispositivoplantillaanalogicaCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Reldispositivoplantillaanalogica.
     * @param {reldispositivoplantillaanalogicaDeleteArgs} args - Arguments to delete one Reldispositivoplantillaanalogica.
     * @example
     * // Delete one Reldispositivoplantillaanalogica
     * const Reldispositivoplantillaanalogica = await prisma.reldispositivoplantillaanalogica.delete({
     *   where: {
     *     // ... filter to delete one Reldispositivoplantillaanalogica
     *   }
     * })
     * 
    **/
    delete<T extends reldispositivoplantillaanalogicaDeleteArgs>(
      args: SelectSubset<T, reldispositivoplantillaanalogicaDeleteArgs>
    ): Prisma__reldispositivoplantillaanalogicaClient<reldispositivoplantillaanalogicaGetPayload<T>>

    /**
     * Update one Reldispositivoplantillaanalogica.
     * @param {reldispositivoplantillaanalogicaUpdateArgs} args - Arguments to update one Reldispositivoplantillaanalogica.
     * @example
     * // Update one Reldispositivoplantillaanalogica
     * const reldispositivoplantillaanalogica = await prisma.reldispositivoplantillaanalogica.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends reldispositivoplantillaanalogicaUpdateArgs>(
      args: SelectSubset<T, reldispositivoplantillaanalogicaUpdateArgs>
    ): Prisma__reldispositivoplantillaanalogicaClient<reldispositivoplantillaanalogicaGetPayload<T>>

    /**
     * Delete zero or more Reldispositivoplantillaanalogicas.
     * @param {reldispositivoplantillaanalogicaDeleteManyArgs} args - Arguments to filter Reldispositivoplantillaanalogicas to delete.
     * @example
     * // Delete a few Reldispositivoplantillaanalogicas
     * const { count } = await prisma.reldispositivoplantillaanalogica.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends reldispositivoplantillaanalogicaDeleteManyArgs>(
      args?: SelectSubset<T, reldispositivoplantillaanalogicaDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Reldispositivoplantillaanalogicas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reldispositivoplantillaanalogicaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Reldispositivoplantillaanalogicas
     * const reldispositivoplantillaanalogica = await prisma.reldispositivoplantillaanalogica.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends reldispositivoplantillaanalogicaUpdateManyArgs>(
      args: SelectSubset<T, reldispositivoplantillaanalogicaUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Reldispositivoplantillaanalogica.
     * @param {reldispositivoplantillaanalogicaUpsertArgs} args - Arguments to update or create a Reldispositivoplantillaanalogica.
     * @example
     * // Update or create a Reldispositivoplantillaanalogica
     * const reldispositivoplantillaanalogica = await prisma.reldispositivoplantillaanalogica.upsert({
     *   create: {
     *     // ... data to create a Reldispositivoplantillaanalogica
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Reldispositivoplantillaanalogica we want to update
     *   }
     * })
    **/
    upsert<T extends reldispositivoplantillaanalogicaUpsertArgs>(
      args: SelectSubset<T, reldispositivoplantillaanalogicaUpsertArgs>
    ): Prisma__reldispositivoplantillaanalogicaClient<reldispositivoplantillaanalogicaGetPayload<T>>

    /**
     * Count the number of Reldispositivoplantillaanalogicas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reldispositivoplantillaanalogicaCountArgs} args - Arguments to filter Reldispositivoplantillaanalogicas to count.
     * @example
     * // Count the number of Reldispositivoplantillaanalogicas
     * const count = await prisma.reldispositivoplantillaanalogica.count({
     *   where: {
     *     // ... the filter for the Reldispositivoplantillaanalogicas we want to count
     *   }
     * })
    **/
    count<T extends reldispositivoplantillaanalogicaCountArgs>(
      args?: Subset<T, reldispositivoplantillaanalogicaCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReldispositivoplantillaanalogicaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Reldispositivoplantillaanalogica.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReldispositivoplantillaanalogicaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReldispositivoplantillaanalogicaAggregateArgs>(args: Subset<T, ReldispositivoplantillaanalogicaAggregateArgs>): PrismaPromise<GetReldispositivoplantillaanalogicaAggregateType<T>>

    /**
     * Group by Reldispositivoplantillaanalogica.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReldispositivoplantillaanalogicaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReldispositivoplantillaanalogicaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReldispositivoplantillaanalogicaGroupByArgs['orderBy'] }
        : { orderBy?: ReldispositivoplantillaanalogicaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReldispositivoplantillaanalogicaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReldispositivoplantillaanalogicaGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for reldispositivoplantillaanalogica.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__reldispositivoplantillaanalogicaClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * reldispositivoplantillaanalogica base type for findUnique actions
   */
  export type reldispositivoplantillaanalogicaFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the reldispositivoplantillaanalogica
     * 
    **/
    select?: reldispositivoplantillaanalogicaSelect | null
    /**
     * Filter, which reldispositivoplantillaanalogica to fetch.
     * 
    **/
    where: reldispositivoplantillaanalogicaWhereUniqueInput
  }

  /**
   * reldispositivoplantillaanalogica: findUnique
   */
  export interface reldispositivoplantillaanalogicaFindUniqueArgs extends reldispositivoplantillaanalogicaFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * reldispositivoplantillaanalogica findUniqueOrThrow
   */
  export type reldispositivoplantillaanalogicaFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the reldispositivoplantillaanalogica
     * 
    **/
    select?: reldispositivoplantillaanalogicaSelect | null
    /**
     * Filter, which reldispositivoplantillaanalogica to fetch.
     * 
    **/
    where: reldispositivoplantillaanalogicaWhereUniqueInput
  }


  /**
   * reldispositivoplantillaanalogica base type for findFirst actions
   */
  export type reldispositivoplantillaanalogicaFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the reldispositivoplantillaanalogica
     * 
    **/
    select?: reldispositivoplantillaanalogicaSelect | null
    /**
     * Filter, which reldispositivoplantillaanalogica to fetch.
     * 
    **/
    where?: reldispositivoplantillaanalogicaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of reldispositivoplantillaanalogicas to fetch.
     * 
    **/
    orderBy?: Enumerable<reldispositivoplantillaanalogicaOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for reldispositivoplantillaanalogicas.
     * 
    **/
    cursor?: reldispositivoplantillaanalogicaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` reldispositivoplantillaanalogicas from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` reldispositivoplantillaanalogicas.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of reldispositivoplantillaanalogicas.
     * 
    **/
    distinct?: Enumerable<ReldispositivoplantillaanalogicaScalarFieldEnum>
  }

  /**
   * reldispositivoplantillaanalogica: findFirst
   */
  export interface reldispositivoplantillaanalogicaFindFirstArgs extends reldispositivoplantillaanalogicaFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * reldispositivoplantillaanalogica findFirstOrThrow
   */
  export type reldispositivoplantillaanalogicaFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the reldispositivoplantillaanalogica
     * 
    **/
    select?: reldispositivoplantillaanalogicaSelect | null
    /**
     * Filter, which reldispositivoplantillaanalogica to fetch.
     * 
    **/
    where?: reldispositivoplantillaanalogicaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of reldispositivoplantillaanalogicas to fetch.
     * 
    **/
    orderBy?: Enumerable<reldispositivoplantillaanalogicaOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for reldispositivoplantillaanalogicas.
     * 
    **/
    cursor?: reldispositivoplantillaanalogicaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` reldispositivoplantillaanalogicas from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` reldispositivoplantillaanalogicas.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of reldispositivoplantillaanalogicas.
     * 
    **/
    distinct?: Enumerable<ReldispositivoplantillaanalogicaScalarFieldEnum>
  }


  /**
   * reldispositivoplantillaanalogica findMany
   */
  export type reldispositivoplantillaanalogicaFindManyArgs = {
    /**
     * Select specific fields to fetch from the reldispositivoplantillaanalogica
     * 
    **/
    select?: reldispositivoplantillaanalogicaSelect | null
    /**
     * Filter, which reldispositivoplantillaanalogicas to fetch.
     * 
    **/
    where?: reldispositivoplantillaanalogicaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of reldispositivoplantillaanalogicas to fetch.
     * 
    **/
    orderBy?: Enumerable<reldispositivoplantillaanalogicaOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing reldispositivoplantillaanalogicas.
     * 
    **/
    cursor?: reldispositivoplantillaanalogicaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` reldispositivoplantillaanalogicas from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` reldispositivoplantillaanalogicas.
     * 
    **/
    skip?: number
    distinct?: Enumerable<ReldispositivoplantillaanalogicaScalarFieldEnum>
  }


  /**
   * reldispositivoplantillaanalogica create
   */
  export type reldispositivoplantillaanalogicaCreateArgs = {
    /**
     * Select specific fields to fetch from the reldispositivoplantillaanalogica
     * 
    **/
    select?: reldispositivoplantillaanalogicaSelect | null
    /**
     * The data needed to create a reldispositivoplantillaanalogica.
     * 
    **/
    data: XOR<reldispositivoplantillaanalogicaCreateInput, reldispositivoplantillaanalogicaUncheckedCreateInput>
  }


  /**
   * reldispositivoplantillaanalogica createMany
   */
  export type reldispositivoplantillaanalogicaCreateManyArgs = {
    /**
     * The data used to create many reldispositivoplantillaanalogicas.
     * 
    **/
    data: Enumerable<reldispositivoplantillaanalogicaCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * reldispositivoplantillaanalogica update
   */
  export type reldispositivoplantillaanalogicaUpdateArgs = {
    /**
     * Select specific fields to fetch from the reldispositivoplantillaanalogica
     * 
    **/
    select?: reldispositivoplantillaanalogicaSelect | null
    /**
     * The data needed to update a reldispositivoplantillaanalogica.
     * 
    **/
    data: XOR<reldispositivoplantillaanalogicaUpdateInput, reldispositivoplantillaanalogicaUncheckedUpdateInput>
    /**
     * Choose, which reldispositivoplantillaanalogica to update.
     * 
    **/
    where: reldispositivoplantillaanalogicaWhereUniqueInput
  }


  /**
   * reldispositivoplantillaanalogica updateMany
   */
  export type reldispositivoplantillaanalogicaUpdateManyArgs = {
    /**
     * The data used to update reldispositivoplantillaanalogicas.
     * 
    **/
    data: XOR<reldispositivoplantillaanalogicaUpdateManyMutationInput, reldispositivoplantillaanalogicaUncheckedUpdateManyInput>
    /**
     * Filter which reldispositivoplantillaanalogicas to update
     * 
    **/
    where?: reldispositivoplantillaanalogicaWhereInput
  }


  /**
   * reldispositivoplantillaanalogica upsert
   */
  export type reldispositivoplantillaanalogicaUpsertArgs = {
    /**
     * Select specific fields to fetch from the reldispositivoplantillaanalogica
     * 
    **/
    select?: reldispositivoplantillaanalogicaSelect | null
    /**
     * The filter to search for the reldispositivoplantillaanalogica to update in case it exists.
     * 
    **/
    where: reldispositivoplantillaanalogicaWhereUniqueInput
    /**
     * In case the reldispositivoplantillaanalogica found by the `where` argument doesn't exist, create a new reldispositivoplantillaanalogica with this data.
     * 
    **/
    create: XOR<reldispositivoplantillaanalogicaCreateInput, reldispositivoplantillaanalogicaUncheckedCreateInput>
    /**
     * In case the reldispositivoplantillaanalogica was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<reldispositivoplantillaanalogicaUpdateInput, reldispositivoplantillaanalogicaUncheckedUpdateInput>
  }


  /**
   * reldispositivoplantillaanalogica delete
   */
  export type reldispositivoplantillaanalogicaDeleteArgs = {
    /**
     * Select specific fields to fetch from the reldispositivoplantillaanalogica
     * 
    **/
    select?: reldispositivoplantillaanalogicaSelect | null
    /**
     * Filter which reldispositivoplantillaanalogica to delete.
     * 
    **/
    where: reldispositivoplantillaanalogicaWhereUniqueInput
  }


  /**
   * reldispositivoplantillaanalogica deleteMany
   */
  export type reldispositivoplantillaanalogicaDeleteManyArgs = {
    /**
     * Filter which reldispositivoplantillaanalogicas to delete
     * 
    **/
    where?: reldispositivoplantillaanalogicaWhereInput
  }


  /**
   * reldispositivoplantillaanalogica without action
   */
  export type reldispositivoplantillaanalogicaArgs = {
    /**
     * Select specific fields to fetch from the reldispositivoplantillaanalogica
     * 
    **/
    select?: reldispositivoplantillaanalogicaSelect | null
  }



  /**
   * Model reldispositivopuerta
   */


  export type AggregateReldispositivopuerta = {
    _count: ReldispositivopuertaCountAggregateOutputType | null
    _avg: ReldispositivopuertaAvgAggregateOutputType | null
    _sum: ReldispositivopuertaSumAggregateOutputType | null
    _min: ReldispositivopuertaMinAggregateOutputType | null
    _max: ReldispositivopuertaMaxAggregateOutputType | null
  }

  export type ReldispositivopuertaAvgAggregateOutputType = {
    IDRelDisPuerta: number | null
    IDDispositivo: number | null
    IDPuerta: number | null
    IDTipoDispositivo: number | null
  }

  export type ReldispositivopuertaSumAggregateOutputType = {
    IDRelDisPuerta: number | null
    IDDispositivo: number | null
    IDPuerta: number | null
    IDTipoDispositivo: number | null
  }

  export type ReldispositivopuertaMinAggregateOutputType = {
    IDRelDisPuerta: number | null
    IDDispositivo: number | null
    IDPuerta: number | null
    IDTipoDispositivo: number | null
  }

  export type ReldispositivopuertaMaxAggregateOutputType = {
    IDRelDisPuerta: number | null
    IDDispositivo: number | null
    IDPuerta: number | null
    IDTipoDispositivo: number | null
  }

  export type ReldispositivopuertaCountAggregateOutputType = {
    IDRelDisPuerta: number
    IDDispositivo: number
    IDPuerta: number
    IDTipoDispositivo: number
    _all: number
  }


  export type ReldispositivopuertaAvgAggregateInputType = {
    IDRelDisPuerta?: true
    IDDispositivo?: true
    IDPuerta?: true
    IDTipoDispositivo?: true
  }

  export type ReldispositivopuertaSumAggregateInputType = {
    IDRelDisPuerta?: true
    IDDispositivo?: true
    IDPuerta?: true
    IDTipoDispositivo?: true
  }

  export type ReldispositivopuertaMinAggregateInputType = {
    IDRelDisPuerta?: true
    IDDispositivo?: true
    IDPuerta?: true
    IDTipoDispositivo?: true
  }

  export type ReldispositivopuertaMaxAggregateInputType = {
    IDRelDisPuerta?: true
    IDDispositivo?: true
    IDPuerta?: true
    IDTipoDispositivo?: true
  }

  export type ReldispositivopuertaCountAggregateInputType = {
    IDRelDisPuerta?: true
    IDDispositivo?: true
    IDPuerta?: true
    IDTipoDispositivo?: true
    _all?: true
  }

  export type ReldispositivopuertaAggregateArgs = {
    /**
     * Filter which reldispositivopuerta to aggregate.
     * 
    **/
    where?: reldispositivopuertaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of reldispositivopuertas to fetch.
     * 
    **/
    orderBy?: Enumerable<reldispositivopuertaOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: reldispositivopuertaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` reldispositivopuertas from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` reldispositivopuertas.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned reldispositivopuertas
    **/
    _count?: true | ReldispositivopuertaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ReldispositivopuertaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ReldispositivopuertaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReldispositivopuertaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReldispositivopuertaMaxAggregateInputType
  }

  export type GetReldispositivopuertaAggregateType<T extends ReldispositivopuertaAggregateArgs> = {
        [P in keyof T & keyof AggregateReldispositivopuerta]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReldispositivopuerta[P]>
      : GetScalarType<T[P], AggregateReldispositivopuerta[P]>
  }




  export type ReldispositivopuertaGroupByArgs = {
    where?: reldispositivopuertaWhereInput
    orderBy?: Enumerable<reldispositivopuertaOrderByWithAggregationInput>
    by: Array<ReldispositivopuertaScalarFieldEnum>
    having?: reldispositivopuertaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReldispositivopuertaCountAggregateInputType | true
    _avg?: ReldispositivopuertaAvgAggregateInputType
    _sum?: ReldispositivopuertaSumAggregateInputType
    _min?: ReldispositivopuertaMinAggregateInputType
    _max?: ReldispositivopuertaMaxAggregateInputType
  }


  export type ReldispositivopuertaGroupByOutputType = {
    IDRelDisPuerta: number
    IDDispositivo: number
    IDPuerta: number
    IDTipoDispositivo: number
    _count: ReldispositivopuertaCountAggregateOutputType | null
    _avg: ReldispositivopuertaAvgAggregateOutputType | null
    _sum: ReldispositivopuertaSumAggregateOutputType | null
    _min: ReldispositivopuertaMinAggregateOutputType | null
    _max: ReldispositivopuertaMaxAggregateOutputType | null
  }

  type GetReldispositivopuertaGroupByPayload<T extends ReldispositivopuertaGroupByArgs> = PrismaPromise<
    Array<
      PickArray<ReldispositivopuertaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReldispositivopuertaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReldispositivopuertaGroupByOutputType[P]>
            : GetScalarType<T[P], ReldispositivopuertaGroupByOutputType[P]>
        }
      >
    >


  export type reldispositivopuertaSelect = {
    IDRelDisPuerta?: boolean
    IDDispositivo?: boolean
    IDPuerta?: boolean
    IDTipoDispositivo?: boolean
  }


  export type reldispositivopuertaGetPayload<S extends boolean | null | undefined | reldispositivopuertaArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? reldispositivopuerta :
    S extends undefined ? never :
    S extends { include: any } & (reldispositivopuertaArgs | reldispositivopuertaFindManyArgs)
    ? reldispositivopuerta 
    : S extends { select: any } & (reldispositivopuertaArgs | reldispositivopuertaFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof reldispositivopuerta ? reldispositivopuerta[P] : never
  } 
      : reldispositivopuerta


  type reldispositivopuertaCountArgs = Merge<
    Omit<reldispositivopuertaFindManyArgs, 'select' | 'include'> & {
      select?: ReldispositivopuertaCountAggregateInputType | true
    }
  >

  export interface reldispositivopuertaDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Reldispositivopuerta that matches the filter.
     * @param {reldispositivopuertaFindUniqueArgs} args - Arguments to find a Reldispositivopuerta
     * @example
     * // Get one Reldispositivopuerta
     * const reldispositivopuerta = await prisma.reldispositivopuerta.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends reldispositivopuertaFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, reldispositivopuertaFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'reldispositivopuerta'> extends True ? Prisma__reldispositivopuertaClient<reldispositivopuertaGetPayload<T>> : Prisma__reldispositivopuertaClient<reldispositivopuertaGetPayload<T> | null, null>

    /**
     * Find one Reldispositivopuerta that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {reldispositivopuertaFindUniqueOrThrowArgs} args - Arguments to find a Reldispositivopuerta
     * @example
     * // Get one Reldispositivopuerta
     * const reldispositivopuerta = await prisma.reldispositivopuerta.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends reldispositivopuertaFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, reldispositivopuertaFindUniqueOrThrowArgs>
    ): Prisma__reldispositivopuertaClient<reldispositivopuertaGetPayload<T>>

    /**
     * Find the first Reldispositivopuerta that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reldispositivopuertaFindFirstArgs} args - Arguments to find a Reldispositivopuerta
     * @example
     * // Get one Reldispositivopuerta
     * const reldispositivopuerta = await prisma.reldispositivopuerta.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends reldispositivopuertaFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, reldispositivopuertaFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'reldispositivopuerta'> extends True ? Prisma__reldispositivopuertaClient<reldispositivopuertaGetPayload<T>> : Prisma__reldispositivopuertaClient<reldispositivopuertaGetPayload<T> | null, null>

    /**
     * Find the first Reldispositivopuerta that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reldispositivopuertaFindFirstOrThrowArgs} args - Arguments to find a Reldispositivopuerta
     * @example
     * // Get one Reldispositivopuerta
     * const reldispositivopuerta = await prisma.reldispositivopuerta.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends reldispositivopuertaFindFirstOrThrowArgs>(
      args?: SelectSubset<T, reldispositivopuertaFindFirstOrThrowArgs>
    ): Prisma__reldispositivopuertaClient<reldispositivopuertaGetPayload<T>>

    /**
     * Find zero or more Reldispositivopuertas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reldispositivopuertaFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Reldispositivopuertas
     * const reldispositivopuertas = await prisma.reldispositivopuerta.findMany()
     * 
     * // Get first 10 Reldispositivopuertas
     * const reldispositivopuertas = await prisma.reldispositivopuerta.findMany({ take: 10 })
     * 
     * // Only select the `IDRelDisPuerta`
     * const reldispositivopuertaWithIDRelDisPuertaOnly = await prisma.reldispositivopuerta.findMany({ select: { IDRelDisPuerta: true } })
     * 
    **/
    findMany<T extends reldispositivopuertaFindManyArgs>(
      args?: SelectSubset<T, reldispositivopuertaFindManyArgs>
    ): PrismaPromise<Array<reldispositivopuertaGetPayload<T>>>

    /**
     * Create a Reldispositivopuerta.
     * @param {reldispositivopuertaCreateArgs} args - Arguments to create a Reldispositivopuerta.
     * @example
     * // Create one Reldispositivopuerta
     * const Reldispositivopuerta = await prisma.reldispositivopuerta.create({
     *   data: {
     *     // ... data to create a Reldispositivopuerta
     *   }
     * })
     * 
    **/
    create<T extends reldispositivopuertaCreateArgs>(
      args: SelectSubset<T, reldispositivopuertaCreateArgs>
    ): Prisma__reldispositivopuertaClient<reldispositivopuertaGetPayload<T>>

    /**
     * Create many Reldispositivopuertas.
     *     @param {reldispositivopuertaCreateManyArgs} args - Arguments to create many Reldispositivopuertas.
     *     @example
     *     // Create many Reldispositivopuertas
     *     const reldispositivopuerta = await prisma.reldispositivopuerta.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends reldispositivopuertaCreateManyArgs>(
      args?: SelectSubset<T, reldispositivopuertaCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Reldispositivopuerta.
     * @param {reldispositivopuertaDeleteArgs} args - Arguments to delete one Reldispositivopuerta.
     * @example
     * // Delete one Reldispositivopuerta
     * const Reldispositivopuerta = await prisma.reldispositivopuerta.delete({
     *   where: {
     *     // ... filter to delete one Reldispositivopuerta
     *   }
     * })
     * 
    **/
    delete<T extends reldispositivopuertaDeleteArgs>(
      args: SelectSubset<T, reldispositivopuertaDeleteArgs>
    ): Prisma__reldispositivopuertaClient<reldispositivopuertaGetPayload<T>>

    /**
     * Update one Reldispositivopuerta.
     * @param {reldispositivopuertaUpdateArgs} args - Arguments to update one Reldispositivopuerta.
     * @example
     * // Update one Reldispositivopuerta
     * const reldispositivopuerta = await prisma.reldispositivopuerta.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends reldispositivopuertaUpdateArgs>(
      args: SelectSubset<T, reldispositivopuertaUpdateArgs>
    ): Prisma__reldispositivopuertaClient<reldispositivopuertaGetPayload<T>>

    /**
     * Delete zero or more Reldispositivopuertas.
     * @param {reldispositivopuertaDeleteManyArgs} args - Arguments to filter Reldispositivopuertas to delete.
     * @example
     * // Delete a few Reldispositivopuertas
     * const { count } = await prisma.reldispositivopuerta.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends reldispositivopuertaDeleteManyArgs>(
      args?: SelectSubset<T, reldispositivopuertaDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Reldispositivopuertas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reldispositivopuertaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Reldispositivopuertas
     * const reldispositivopuerta = await prisma.reldispositivopuerta.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends reldispositivopuertaUpdateManyArgs>(
      args: SelectSubset<T, reldispositivopuertaUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Reldispositivopuerta.
     * @param {reldispositivopuertaUpsertArgs} args - Arguments to update or create a Reldispositivopuerta.
     * @example
     * // Update or create a Reldispositivopuerta
     * const reldispositivopuerta = await prisma.reldispositivopuerta.upsert({
     *   create: {
     *     // ... data to create a Reldispositivopuerta
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Reldispositivopuerta we want to update
     *   }
     * })
    **/
    upsert<T extends reldispositivopuertaUpsertArgs>(
      args: SelectSubset<T, reldispositivopuertaUpsertArgs>
    ): Prisma__reldispositivopuertaClient<reldispositivopuertaGetPayload<T>>

    /**
     * Count the number of Reldispositivopuertas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reldispositivopuertaCountArgs} args - Arguments to filter Reldispositivopuertas to count.
     * @example
     * // Count the number of Reldispositivopuertas
     * const count = await prisma.reldispositivopuerta.count({
     *   where: {
     *     // ... the filter for the Reldispositivopuertas we want to count
     *   }
     * })
    **/
    count<T extends reldispositivopuertaCountArgs>(
      args?: Subset<T, reldispositivopuertaCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReldispositivopuertaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Reldispositivopuerta.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReldispositivopuertaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReldispositivopuertaAggregateArgs>(args: Subset<T, ReldispositivopuertaAggregateArgs>): PrismaPromise<GetReldispositivopuertaAggregateType<T>>

    /**
     * Group by Reldispositivopuerta.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReldispositivopuertaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReldispositivopuertaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReldispositivopuertaGroupByArgs['orderBy'] }
        : { orderBy?: ReldispositivopuertaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReldispositivopuertaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReldispositivopuertaGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for reldispositivopuerta.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__reldispositivopuertaClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * reldispositivopuerta base type for findUnique actions
   */
  export type reldispositivopuertaFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the reldispositivopuerta
     * 
    **/
    select?: reldispositivopuertaSelect | null
    /**
     * Filter, which reldispositivopuerta to fetch.
     * 
    **/
    where: reldispositivopuertaWhereUniqueInput
  }

  /**
   * reldispositivopuerta: findUnique
   */
  export interface reldispositivopuertaFindUniqueArgs extends reldispositivopuertaFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * reldispositivopuerta findUniqueOrThrow
   */
  export type reldispositivopuertaFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the reldispositivopuerta
     * 
    **/
    select?: reldispositivopuertaSelect | null
    /**
     * Filter, which reldispositivopuerta to fetch.
     * 
    **/
    where: reldispositivopuertaWhereUniqueInput
  }


  /**
   * reldispositivopuerta base type for findFirst actions
   */
  export type reldispositivopuertaFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the reldispositivopuerta
     * 
    **/
    select?: reldispositivopuertaSelect | null
    /**
     * Filter, which reldispositivopuerta to fetch.
     * 
    **/
    where?: reldispositivopuertaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of reldispositivopuertas to fetch.
     * 
    **/
    orderBy?: Enumerable<reldispositivopuertaOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for reldispositivopuertas.
     * 
    **/
    cursor?: reldispositivopuertaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` reldispositivopuertas from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` reldispositivopuertas.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of reldispositivopuertas.
     * 
    **/
    distinct?: Enumerable<ReldispositivopuertaScalarFieldEnum>
  }

  /**
   * reldispositivopuerta: findFirst
   */
  export interface reldispositivopuertaFindFirstArgs extends reldispositivopuertaFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * reldispositivopuerta findFirstOrThrow
   */
  export type reldispositivopuertaFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the reldispositivopuerta
     * 
    **/
    select?: reldispositivopuertaSelect | null
    /**
     * Filter, which reldispositivopuerta to fetch.
     * 
    **/
    where?: reldispositivopuertaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of reldispositivopuertas to fetch.
     * 
    **/
    orderBy?: Enumerable<reldispositivopuertaOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for reldispositivopuertas.
     * 
    **/
    cursor?: reldispositivopuertaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` reldispositivopuertas from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` reldispositivopuertas.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of reldispositivopuertas.
     * 
    **/
    distinct?: Enumerable<ReldispositivopuertaScalarFieldEnum>
  }


  /**
   * reldispositivopuerta findMany
   */
  export type reldispositivopuertaFindManyArgs = {
    /**
     * Select specific fields to fetch from the reldispositivopuerta
     * 
    **/
    select?: reldispositivopuertaSelect | null
    /**
     * Filter, which reldispositivopuertas to fetch.
     * 
    **/
    where?: reldispositivopuertaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of reldispositivopuertas to fetch.
     * 
    **/
    orderBy?: Enumerable<reldispositivopuertaOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing reldispositivopuertas.
     * 
    **/
    cursor?: reldispositivopuertaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` reldispositivopuertas from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` reldispositivopuertas.
     * 
    **/
    skip?: number
    distinct?: Enumerable<ReldispositivopuertaScalarFieldEnum>
  }


  /**
   * reldispositivopuerta create
   */
  export type reldispositivopuertaCreateArgs = {
    /**
     * Select specific fields to fetch from the reldispositivopuerta
     * 
    **/
    select?: reldispositivopuertaSelect | null
    /**
     * The data needed to create a reldispositivopuerta.
     * 
    **/
    data: XOR<reldispositivopuertaCreateInput, reldispositivopuertaUncheckedCreateInput>
  }


  /**
   * reldispositivopuerta createMany
   */
  export type reldispositivopuertaCreateManyArgs = {
    /**
     * The data used to create many reldispositivopuertas.
     * 
    **/
    data: Enumerable<reldispositivopuertaCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * reldispositivopuerta update
   */
  export type reldispositivopuertaUpdateArgs = {
    /**
     * Select specific fields to fetch from the reldispositivopuerta
     * 
    **/
    select?: reldispositivopuertaSelect | null
    /**
     * The data needed to update a reldispositivopuerta.
     * 
    **/
    data: XOR<reldispositivopuertaUpdateInput, reldispositivopuertaUncheckedUpdateInput>
    /**
     * Choose, which reldispositivopuerta to update.
     * 
    **/
    where: reldispositivopuertaWhereUniqueInput
  }


  /**
   * reldispositivopuerta updateMany
   */
  export type reldispositivopuertaUpdateManyArgs = {
    /**
     * The data used to update reldispositivopuertas.
     * 
    **/
    data: XOR<reldispositivopuertaUpdateManyMutationInput, reldispositivopuertaUncheckedUpdateManyInput>
    /**
     * Filter which reldispositivopuertas to update
     * 
    **/
    where?: reldispositivopuertaWhereInput
  }


  /**
   * reldispositivopuerta upsert
   */
  export type reldispositivopuertaUpsertArgs = {
    /**
     * Select specific fields to fetch from the reldispositivopuerta
     * 
    **/
    select?: reldispositivopuertaSelect | null
    /**
     * The filter to search for the reldispositivopuerta to update in case it exists.
     * 
    **/
    where: reldispositivopuertaWhereUniqueInput
    /**
     * In case the reldispositivopuerta found by the `where` argument doesn't exist, create a new reldispositivopuerta with this data.
     * 
    **/
    create: XOR<reldispositivopuertaCreateInput, reldispositivopuertaUncheckedCreateInput>
    /**
     * In case the reldispositivopuerta was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<reldispositivopuertaUpdateInput, reldispositivopuertaUncheckedUpdateInput>
  }


  /**
   * reldispositivopuerta delete
   */
  export type reldispositivopuertaDeleteArgs = {
    /**
     * Select specific fields to fetch from the reldispositivopuerta
     * 
    **/
    select?: reldispositivopuertaSelect | null
    /**
     * Filter which reldispositivopuerta to delete.
     * 
    **/
    where: reldispositivopuertaWhereUniqueInput
  }


  /**
   * reldispositivopuerta deleteMany
   */
  export type reldispositivopuertaDeleteManyArgs = {
    /**
     * Filter which reldispositivopuertas to delete
     * 
    **/
    where?: reldispositivopuertaWhereInput
  }


  /**
   * reldispositivopuerta without action
   */
  export type reldispositivopuertaArgs = {
    /**
     * Select specific fields to fetch from the reldispositivopuerta
     * 
    **/
    select?: reldispositivopuertaSelect | null
  }



  /**
   * Model reldispositivosubsistema
   */


  export type AggregateReldispositivosubsistema = {
    _count: ReldispositivosubsistemaCountAggregateOutputType | null
    _avg: ReldispositivosubsistemaAvgAggregateOutputType | null
    _sum: ReldispositivosubsistemaSumAggregateOutputType | null
    _min: ReldispositivosubsistemaMinAggregateOutputType | null
    _max: ReldispositivosubsistemaMaxAggregateOutputType | null
  }

  export type ReldispositivosubsistemaAvgAggregateOutputType = {
    IDRelDisSubsistema: number | null
    IDSubsistema: number | null
    IDDispositivo: number | null
  }

  export type ReldispositivosubsistemaSumAggregateOutputType = {
    IDRelDisSubsistema: number | null
    IDSubsistema: number | null
    IDDispositivo: number | null
  }

  export type ReldispositivosubsistemaMinAggregateOutputType = {
    IDRelDisSubsistema: number | null
    IDSubsistema: number | null
    IDDispositivo: number | null
  }

  export type ReldispositivosubsistemaMaxAggregateOutputType = {
    IDRelDisSubsistema: number | null
    IDSubsistema: number | null
    IDDispositivo: number | null
  }

  export type ReldispositivosubsistemaCountAggregateOutputType = {
    IDRelDisSubsistema: number
    IDSubsistema: number
    IDDispositivo: number
    _all: number
  }


  export type ReldispositivosubsistemaAvgAggregateInputType = {
    IDRelDisSubsistema?: true
    IDSubsistema?: true
    IDDispositivo?: true
  }

  export type ReldispositivosubsistemaSumAggregateInputType = {
    IDRelDisSubsistema?: true
    IDSubsistema?: true
    IDDispositivo?: true
  }

  export type ReldispositivosubsistemaMinAggregateInputType = {
    IDRelDisSubsistema?: true
    IDSubsistema?: true
    IDDispositivo?: true
  }

  export type ReldispositivosubsistemaMaxAggregateInputType = {
    IDRelDisSubsistema?: true
    IDSubsistema?: true
    IDDispositivo?: true
  }

  export type ReldispositivosubsistemaCountAggregateInputType = {
    IDRelDisSubsistema?: true
    IDSubsistema?: true
    IDDispositivo?: true
    _all?: true
  }

  export type ReldispositivosubsistemaAggregateArgs = {
    /**
     * Filter which reldispositivosubsistema to aggregate.
     * 
    **/
    where?: reldispositivosubsistemaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of reldispositivosubsistemas to fetch.
     * 
    **/
    orderBy?: Enumerable<reldispositivosubsistemaOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: reldispositivosubsistemaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` reldispositivosubsistemas from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` reldispositivosubsistemas.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned reldispositivosubsistemas
    **/
    _count?: true | ReldispositivosubsistemaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ReldispositivosubsistemaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ReldispositivosubsistemaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReldispositivosubsistemaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReldispositivosubsistemaMaxAggregateInputType
  }

  export type GetReldispositivosubsistemaAggregateType<T extends ReldispositivosubsistemaAggregateArgs> = {
        [P in keyof T & keyof AggregateReldispositivosubsistema]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReldispositivosubsistema[P]>
      : GetScalarType<T[P], AggregateReldispositivosubsistema[P]>
  }




  export type ReldispositivosubsistemaGroupByArgs = {
    where?: reldispositivosubsistemaWhereInput
    orderBy?: Enumerable<reldispositivosubsistemaOrderByWithAggregationInput>
    by: Array<ReldispositivosubsistemaScalarFieldEnum>
    having?: reldispositivosubsistemaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReldispositivosubsistemaCountAggregateInputType | true
    _avg?: ReldispositivosubsistemaAvgAggregateInputType
    _sum?: ReldispositivosubsistemaSumAggregateInputType
    _min?: ReldispositivosubsistemaMinAggregateInputType
    _max?: ReldispositivosubsistemaMaxAggregateInputType
  }


  export type ReldispositivosubsistemaGroupByOutputType = {
    IDRelDisSubsistema: number
    IDSubsistema: number | null
    IDDispositivo: number | null
    _count: ReldispositivosubsistemaCountAggregateOutputType | null
    _avg: ReldispositivosubsistemaAvgAggregateOutputType | null
    _sum: ReldispositivosubsistemaSumAggregateOutputType | null
    _min: ReldispositivosubsistemaMinAggregateOutputType | null
    _max: ReldispositivosubsistemaMaxAggregateOutputType | null
  }

  type GetReldispositivosubsistemaGroupByPayload<T extends ReldispositivosubsistemaGroupByArgs> = PrismaPromise<
    Array<
      PickArray<ReldispositivosubsistemaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReldispositivosubsistemaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReldispositivosubsistemaGroupByOutputType[P]>
            : GetScalarType<T[P], ReldispositivosubsistemaGroupByOutputType[P]>
        }
      >
    >


  export type reldispositivosubsistemaSelect = {
    IDRelDisSubsistema?: boolean
    IDSubsistema?: boolean
    IDDispositivo?: boolean
  }


  export type reldispositivosubsistemaGetPayload<S extends boolean | null | undefined | reldispositivosubsistemaArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? reldispositivosubsistema :
    S extends undefined ? never :
    S extends { include: any } & (reldispositivosubsistemaArgs | reldispositivosubsistemaFindManyArgs)
    ? reldispositivosubsistema 
    : S extends { select: any } & (reldispositivosubsistemaArgs | reldispositivosubsistemaFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof reldispositivosubsistema ? reldispositivosubsistema[P] : never
  } 
      : reldispositivosubsistema


  type reldispositivosubsistemaCountArgs = Merge<
    Omit<reldispositivosubsistemaFindManyArgs, 'select' | 'include'> & {
      select?: ReldispositivosubsistemaCountAggregateInputType | true
    }
  >

  export interface reldispositivosubsistemaDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Reldispositivosubsistema that matches the filter.
     * @param {reldispositivosubsistemaFindUniqueArgs} args - Arguments to find a Reldispositivosubsistema
     * @example
     * // Get one Reldispositivosubsistema
     * const reldispositivosubsistema = await prisma.reldispositivosubsistema.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends reldispositivosubsistemaFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, reldispositivosubsistemaFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'reldispositivosubsistema'> extends True ? Prisma__reldispositivosubsistemaClient<reldispositivosubsistemaGetPayload<T>> : Prisma__reldispositivosubsistemaClient<reldispositivosubsistemaGetPayload<T> | null, null>

    /**
     * Find one Reldispositivosubsistema that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {reldispositivosubsistemaFindUniqueOrThrowArgs} args - Arguments to find a Reldispositivosubsistema
     * @example
     * // Get one Reldispositivosubsistema
     * const reldispositivosubsistema = await prisma.reldispositivosubsistema.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends reldispositivosubsistemaFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, reldispositivosubsistemaFindUniqueOrThrowArgs>
    ): Prisma__reldispositivosubsistemaClient<reldispositivosubsistemaGetPayload<T>>

    /**
     * Find the first Reldispositivosubsistema that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reldispositivosubsistemaFindFirstArgs} args - Arguments to find a Reldispositivosubsistema
     * @example
     * // Get one Reldispositivosubsistema
     * const reldispositivosubsistema = await prisma.reldispositivosubsistema.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends reldispositivosubsistemaFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, reldispositivosubsistemaFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'reldispositivosubsistema'> extends True ? Prisma__reldispositivosubsistemaClient<reldispositivosubsistemaGetPayload<T>> : Prisma__reldispositivosubsistemaClient<reldispositivosubsistemaGetPayload<T> | null, null>

    /**
     * Find the first Reldispositivosubsistema that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reldispositivosubsistemaFindFirstOrThrowArgs} args - Arguments to find a Reldispositivosubsistema
     * @example
     * // Get one Reldispositivosubsistema
     * const reldispositivosubsistema = await prisma.reldispositivosubsistema.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends reldispositivosubsistemaFindFirstOrThrowArgs>(
      args?: SelectSubset<T, reldispositivosubsistemaFindFirstOrThrowArgs>
    ): Prisma__reldispositivosubsistemaClient<reldispositivosubsistemaGetPayload<T>>

    /**
     * Find zero or more Reldispositivosubsistemas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reldispositivosubsistemaFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Reldispositivosubsistemas
     * const reldispositivosubsistemas = await prisma.reldispositivosubsistema.findMany()
     * 
     * // Get first 10 Reldispositivosubsistemas
     * const reldispositivosubsistemas = await prisma.reldispositivosubsistema.findMany({ take: 10 })
     * 
     * // Only select the `IDRelDisSubsistema`
     * const reldispositivosubsistemaWithIDRelDisSubsistemaOnly = await prisma.reldispositivosubsistema.findMany({ select: { IDRelDisSubsistema: true } })
     * 
    **/
    findMany<T extends reldispositivosubsistemaFindManyArgs>(
      args?: SelectSubset<T, reldispositivosubsistemaFindManyArgs>
    ): PrismaPromise<Array<reldispositivosubsistemaGetPayload<T>>>

    /**
     * Create a Reldispositivosubsistema.
     * @param {reldispositivosubsistemaCreateArgs} args - Arguments to create a Reldispositivosubsistema.
     * @example
     * // Create one Reldispositivosubsistema
     * const Reldispositivosubsistema = await prisma.reldispositivosubsistema.create({
     *   data: {
     *     // ... data to create a Reldispositivosubsistema
     *   }
     * })
     * 
    **/
    create<T extends reldispositivosubsistemaCreateArgs>(
      args: SelectSubset<T, reldispositivosubsistemaCreateArgs>
    ): Prisma__reldispositivosubsistemaClient<reldispositivosubsistemaGetPayload<T>>

    /**
     * Create many Reldispositivosubsistemas.
     *     @param {reldispositivosubsistemaCreateManyArgs} args - Arguments to create many Reldispositivosubsistemas.
     *     @example
     *     // Create many Reldispositivosubsistemas
     *     const reldispositivosubsistema = await prisma.reldispositivosubsistema.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends reldispositivosubsistemaCreateManyArgs>(
      args?: SelectSubset<T, reldispositivosubsistemaCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Reldispositivosubsistema.
     * @param {reldispositivosubsistemaDeleteArgs} args - Arguments to delete one Reldispositivosubsistema.
     * @example
     * // Delete one Reldispositivosubsistema
     * const Reldispositivosubsistema = await prisma.reldispositivosubsistema.delete({
     *   where: {
     *     // ... filter to delete one Reldispositivosubsistema
     *   }
     * })
     * 
    **/
    delete<T extends reldispositivosubsistemaDeleteArgs>(
      args: SelectSubset<T, reldispositivosubsistemaDeleteArgs>
    ): Prisma__reldispositivosubsistemaClient<reldispositivosubsistemaGetPayload<T>>

    /**
     * Update one Reldispositivosubsistema.
     * @param {reldispositivosubsistemaUpdateArgs} args - Arguments to update one Reldispositivosubsistema.
     * @example
     * // Update one Reldispositivosubsistema
     * const reldispositivosubsistema = await prisma.reldispositivosubsistema.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends reldispositivosubsistemaUpdateArgs>(
      args: SelectSubset<T, reldispositivosubsistemaUpdateArgs>
    ): Prisma__reldispositivosubsistemaClient<reldispositivosubsistemaGetPayload<T>>

    /**
     * Delete zero or more Reldispositivosubsistemas.
     * @param {reldispositivosubsistemaDeleteManyArgs} args - Arguments to filter Reldispositivosubsistemas to delete.
     * @example
     * // Delete a few Reldispositivosubsistemas
     * const { count } = await prisma.reldispositivosubsistema.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends reldispositivosubsistemaDeleteManyArgs>(
      args?: SelectSubset<T, reldispositivosubsistemaDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Reldispositivosubsistemas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reldispositivosubsistemaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Reldispositivosubsistemas
     * const reldispositivosubsistema = await prisma.reldispositivosubsistema.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends reldispositivosubsistemaUpdateManyArgs>(
      args: SelectSubset<T, reldispositivosubsistemaUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Reldispositivosubsistema.
     * @param {reldispositivosubsistemaUpsertArgs} args - Arguments to update or create a Reldispositivosubsistema.
     * @example
     * // Update or create a Reldispositivosubsistema
     * const reldispositivosubsistema = await prisma.reldispositivosubsistema.upsert({
     *   create: {
     *     // ... data to create a Reldispositivosubsistema
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Reldispositivosubsistema we want to update
     *   }
     * })
    **/
    upsert<T extends reldispositivosubsistemaUpsertArgs>(
      args: SelectSubset<T, reldispositivosubsistemaUpsertArgs>
    ): Prisma__reldispositivosubsistemaClient<reldispositivosubsistemaGetPayload<T>>

    /**
     * Count the number of Reldispositivosubsistemas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reldispositivosubsistemaCountArgs} args - Arguments to filter Reldispositivosubsistemas to count.
     * @example
     * // Count the number of Reldispositivosubsistemas
     * const count = await prisma.reldispositivosubsistema.count({
     *   where: {
     *     // ... the filter for the Reldispositivosubsistemas we want to count
     *   }
     * })
    **/
    count<T extends reldispositivosubsistemaCountArgs>(
      args?: Subset<T, reldispositivosubsistemaCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReldispositivosubsistemaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Reldispositivosubsistema.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReldispositivosubsistemaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReldispositivosubsistemaAggregateArgs>(args: Subset<T, ReldispositivosubsistemaAggregateArgs>): PrismaPromise<GetReldispositivosubsistemaAggregateType<T>>

    /**
     * Group by Reldispositivosubsistema.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReldispositivosubsistemaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReldispositivosubsistemaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReldispositivosubsistemaGroupByArgs['orderBy'] }
        : { orderBy?: ReldispositivosubsistemaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReldispositivosubsistemaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReldispositivosubsistemaGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for reldispositivosubsistema.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__reldispositivosubsistemaClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * reldispositivosubsistema base type for findUnique actions
   */
  export type reldispositivosubsistemaFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the reldispositivosubsistema
     * 
    **/
    select?: reldispositivosubsistemaSelect | null
    /**
     * Filter, which reldispositivosubsistema to fetch.
     * 
    **/
    where: reldispositivosubsistemaWhereUniqueInput
  }

  /**
   * reldispositivosubsistema: findUnique
   */
  export interface reldispositivosubsistemaFindUniqueArgs extends reldispositivosubsistemaFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * reldispositivosubsistema findUniqueOrThrow
   */
  export type reldispositivosubsistemaFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the reldispositivosubsistema
     * 
    **/
    select?: reldispositivosubsistemaSelect | null
    /**
     * Filter, which reldispositivosubsistema to fetch.
     * 
    **/
    where: reldispositivosubsistemaWhereUniqueInput
  }


  /**
   * reldispositivosubsistema base type for findFirst actions
   */
  export type reldispositivosubsistemaFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the reldispositivosubsistema
     * 
    **/
    select?: reldispositivosubsistemaSelect | null
    /**
     * Filter, which reldispositivosubsistema to fetch.
     * 
    **/
    where?: reldispositivosubsistemaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of reldispositivosubsistemas to fetch.
     * 
    **/
    orderBy?: Enumerable<reldispositivosubsistemaOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for reldispositivosubsistemas.
     * 
    **/
    cursor?: reldispositivosubsistemaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` reldispositivosubsistemas from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` reldispositivosubsistemas.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of reldispositivosubsistemas.
     * 
    **/
    distinct?: Enumerable<ReldispositivosubsistemaScalarFieldEnum>
  }

  /**
   * reldispositivosubsistema: findFirst
   */
  export interface reldispositivosubsistemaFindFirstArgs extends reldispositivosubsistemaFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * reldispositivosubsistema findFirstOrThrow
   */
  export type reldispositivosubsistemaFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the reldispositivosubsistema
     * 
    **/
    select?: reldispositivosubsistemaSelect | null
    /**
     * Filter, which reldispositivosubsistema to fetch.
     * 
    **/
    where?: reldispositivosubsistemaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of reldispositivosubsistemas to fetch.
     * 
    **/
    orderBy?: Enumerable<reldispositivosubsistemaOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for reldispositivosubsistemas.
     * 
    **/
    cursor?: reldispositivosubsistemaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` reldispositivosubsistemas from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` reldispositivosubsistemas.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of reldispositivosubsistemas.
     * 
    **/
    distinct?: Enumerable<ReldispositivosubsistemaScalarFieldEnum>
  }


  /**
   * reldispositivosubsistema findMany
   */
  export type reldispositivosubsistemaFindManyArgs = {
    /**
     * Select specific fields to fetch from the reldispositivosubsistema
     * 
    **/
    select?: reldispositivosubsistemaSelect | null
    /**
     * Filter, which reldispositivosubsistemas to fetch.
     * 
    **/
    where?: reldispositivosubsistemaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of reldispositivosubsistemas to fetch.
     * 
    **/
    orderBy?: Enumerable<reldispositivosubsistemaOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing reldispositivosubsistemas.
     * 
    **/
    cursor?: reldispositivosubsistemaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` reldispositivosubsistemas from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` reldispositivosubsistemas.
     * 
    **/
    skip?: number
    distinct?: Enumerable<ReldispositivosubsistemaScalarFieldEnum>
  }


  /**
   * reldispositivosubsistema create
   */
  export type reldispositivosubsistemaCreateArgs = {
    /**
     * Select specific fields to fetch from the reldispositivosubsistema
     * 
    **/
    select?: reldispositivosubsistemaSelect | null
    /**
     * The data needed to create a reldispositivosubsistema.
     * 
    **/
    data: XOR<reldispositivosubsistemaCreateInput, reldispositivosubsistemaUncheckedCreateInput>
  }


  /**
   * reldispositivosubsistema createMany
   */
  export type reldispositivosubsistemaCreateManyArgs = {
    /**
     * The data used to create many reldispositivosubsistemas.
     * 
    **/
    data: Enumerable<reldispositivosubsistemaCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * reldispositivosubsistema update
   */
  export type reldispositivosubsistemaUpdateArgs = {
    /**
     * Select specific fields to fetch from the reldispositivosubsistema
     * 
    **/
    select?: reldispositivosubsistemaSelect | null
    /**
     * The data needed to update a reldispositivosubsistema.
     * 
    **/
    data: XOR<reldispositivosubsistemaUpdateInput, reldispositivosubsistemaUncheckedUpdateInput>
    /**
     * Choose, which reldispositivosubsistema to update.
     * 
    **/
    where: reldispositivosubsistemaWhereUniqueInput
  }


  /**
   * reldispositivosubsistema updateMany
   */
  export type reldispositivosubsistemaUpdateManyArgs = {
    /**
     * The data used to update reldispositivosubsistemas.
     * 
    **/
    data: XOR<reldispositivosubsistemaUpdateManyMutationInput, reldispositivosubsistemaUncheckedUpdateManyInput>
    /**
     * Filter which reldispositivosubsistemas to update
     * 
    **/
    where?: reldispositivosubsistemaWhereInput
  }


  /**
   * reldispositivosubsistema upsert
   */
  export type reldispositivosubsistemaUpsertArgs = {
    /**
     * Select specific fields to fetch from the reldispositivosubsistema
     * 
    **/
    select?: reldispositivosubsistemaSelect | null
    /**
     * The filter to search for the reldispositivosubsistema to update in case it exists.
     * 
    **/
    where: reldispositivosubsistemaWhereUniqueInput
    /**
     * In case the reldispositivosubsistema found by the `where` argument doesn't exist, create a new reldispositivosubsistema with this data.
     * 
    **/
    create: XOR<reldispositivosubsistemaCreateInput, reldispositivosubsistemaUncheckedCreateInput>
    /**
     * In case the reldispositivosubsistema was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<reldispositivosubsistemaUpdateInput, reldispositivosubsistemaUncheckedUpdateInput>
  }


  /**
   * reldispositivosubsistema delete
   */
  export type reldispositivosubsistemaDeleteArgs = {
    /**
     * Select specific fields to fetch from the reldispositivosubsistema
     * 
    **/
    select?: reldispositivosubsistemaSelect | null
    /**
     * Filter which reldispositivosubsistema to delete.
     * 
    **/
    where: reldispositivosubsistemaWhereUniqueInput
  }


  /**
   * reldispositivosubsistema deleteMany
   */
  export type reldispositivosubsistemaDeleteManyArgs = {
    /**
     * Filter which reldispositivosubsistemas to delete
     * 
    **/
    where?: reldispositivosubsistemaWhereInput
  }


  /**
   * reldispositivosubsistema without action
   */
  export type reldispositivosubsistemaArgs = {
    /**
     * Select specific fields to fetch from the reldispositivosubsistema
     * 
    **/
    select?: reldispositivosubsistemaSelect | null
  }



  /**
   * Model reldispositivotipoevento
   */


  export type AggregateReldispositivotipoevento = {
    _count: ReldispositivotipoeventoCountAggregateOutputType | null
    _avg: ReldispositivotipoeventoAvgAggregateOutputType | null
    _sum: ReldispositivotipoeventoSumAggregateOutputType | null
    _min: ReldispositivotipoeventoMinAggregateOutputType | null
    _max: ReldispositivotipoeventoMaxAggregateOutputType | null
  }

  export type ReldispositivotipoeventoAvgAggregateOutputType = {
    IDRelDisTipoEvento: number | null
    IDDispositivo: number | null
    ClaseEvento: number | null
  }

  export type ReldispositivotipoeventoSumAggregateOutputType = {
    IDRelDisTipoEvento: number | null
    IDDispositivo: number | null
    ClaseEvento: number | null
  }

  export type ReldispositivotipoeventoMinAggregateOutputType = {
    IDRelDisTipoEvento: number | null
    IDDispositivo: number | null
    ClaseEvento: number | null
  }

  export type ReldispositivotipoeventoMaxAggregateOutputType = {
    IDRelDisTipoEvento: number | null
    IDDispositivo: number | null
    ClaseEvento: number | null
  }

  export type ReldispositivotipoeventoCountAggregateOutputType = {
    IDRelDisTipoEvento: number
    IDDispositivo: number
    ClaseEvento: number
    _all: number
  }


  export type ReldispositivotipoeventoAvgAggregateInputType = {
    IDRelDisTipoEvento?: true
    IDDispositivo?: true
    ClaseEvento?: true
  }

  export type ReldispositivotipoeventoSumAggregateInputType = {
    IDRelDisTipoEvento?: true
    IDDispositivo?: true
    ClaseEvento?: true
  }

  export type ReldispositivotipoeventoMinAggregateInputType = {
    IDRelDisTipoEvento?: true
    IDDispositivo?: true
    ClaseEvento?: true
  }

  export type ReldispositivotipoeventoMaxAggregateInputType = {
    IDRelDisTipoEvento?: true
    IDDispositivo?: true
    ClaseEvento?: true
  }

  export type ReldispositivotipoeventoCountAggregateInputType = {
    IDRelDisTipoEvento?: true
    IDDispositivo?: true
    ClaseEvento?: true
    _all?: true
  }

  export type ReldispositivotipoeventoAggregateArgs = {
    /**
     * Filter which reldispositivotipoevento to aggregate.
     * 
    **/
    where?: reldispositivotipoeventoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of reldispositivotipoeventos to fetch.
     * 
    **/
    orderBy?: Enumerable<reldispositivotipoeventoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: reldispositivotipoeventoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` reldispositivotipoeventos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` reldispositivotipoeventos.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned reldispositivotipoeventos
    **/
    _count?: true | ReldispositivotipoeventoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ReldispositivotipoeventoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ReldispositivotipoeventoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReldispositivotipoeventoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReldispositivotipoeventoMaxAggregateInputType
  }

  export type GetReldispositivotipoeventoAggregateType<T extends ReldispositivotipoeventoAggregateArgs> = {
        [P in keyof T & keyof AggregateReldispositivotipoevento]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReldispositivotipoevento[P]>
      : GetScalarType<T[P], AggregateReldispositivotipoevento[P]>
  }




  export type ReldispositivotipoeventoGroupByArgs = {
    where?: reldispositivotipoeventoWhereInput
    orderBy?: Enumerable<reldispositivotipoeventoOrderByWithAggregationInput>
    by: Array<ReldispositivotipoeventoScalarFieldEnum>
    having?: reldispositivotipoeventoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReldispositivotipoeventoCountAggregateInputType | true
    _avg?: ReldispositivotipoeventoAvgAggregateInputType
    _sum?: ReldispositivotipoeventoSumAggregateInputType
    _min?: ReldispositivotipoeventoMinAggregateInputType
    _max?: ReldispositivotipoeventoMaxAggregateInputType
  }


  export type ReldispositivotipoeventoGroupByOutputType = {
    IDRelDisTipoEvento: number
    IDDispositivo: number
    ClaseEvento: number
    _count: ReldispositivotipoeventoCountAggregateOutputType | null
    _avg: ReldispositivotipoeventoAvgAggregateOutputType | null
    _sum: ReldispositivotipoeventoSumAggregateOutputType | null
    _min: ReldispositivotipoeventoMinAggregateOutputType | null
    _max: ReldispositivotipoeventoMaxAggregateOutputType | null
  }

  type GetReldispositivotipoeventoGroupByPayload<T extends ReldispositivotipoeventoGroupByArgs> = PrismaPromise<
    Array<
      PickArray<ReldispositivotipoeventoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReldispositivotipoeventoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReldispositivotipoeventoGroupByOutputType[P]>
            : GetScalarType<T[P], ReldispositivotipoeventoGroupByOutputType[P]>
        }
      >
    >


  export type reldispositivotipoeventoSelect = {
    IDRelDisTipoEvento?: boolean
    IDDispositivo?: boolean
    ClaseEvento?: boolean
  }


  export type reldispositivotipoeventoGetPayload<S extends boolean | null | undefined | reldispositivotipoeventoArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? reldispositivotipoevento :
    S extends undefined ? never :
    S extends { include: any } & (reldispositivotipoeventoArgs | reldispositivotipoeventoFindManyArgs)
    ? reldispositivotipoevento 
    : S extends { select: any } & (reldispositivotipoeventoArgs | reldispositivotipoeventoFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof reldispositivotipoevento ? reldispositivotipoevento[P] : never
  } 
      : reldispositivotipoevento


  type reldispositivotipoeventoCountArgs = Merge<
    Omit<reldispositivotipoeventoFindManyArgs, 'select' | 'include'> & {
      select?: ReldispositivotipoeventoCountAggregateInputType | true
    }
  >

  export interface reldispositivotipoeventoDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Reldispositivotipoevento that matches the filter.
     * @param {reldispositivotipoeventoFindUniqueArgs} args - Arguments to find a Reldispositivotipoevento
     * @example
     * // Get one Reldispositivotipoevento
     * const reldispositivotipoevento = await prisma.reldispositivotipoevento.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends reldispositivotipoeventoFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, reldispositivotipoeventoFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'reldispositivotipoevento'> extends True ? Prisma__reldispositivotipoeventoClient<reldispositivotipoeventoGetPayload<T>> : Prisma__reldispositivotipoeventoClient<reldispositivotipoeventoGetPayload<T> | null, null>

    /**
     * Find one Reldispositivotipoevento that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {reldispositivotipoeventoFindUniqueOrThrowArgs} args - Arguments to find a Reldispositivotipoevento
     * @example
     * // Get one Reldispositivotipoevento
     * const reldispositivotipoevento = await prisma.reldispositivotipoevento.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends reldispositivotipoeventoFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, reldispositivotipoeventoFindUniqueOrThrowArgs>
    ): Prisma__reldispositivotipoeventoClient<reldispositivotipoeventoGetPayload<T>>

    /**
     * Find the first Reldispositivotipoevento that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reldispositivotipoeventoFindFirstArgs} args - Arguments to find a Reldispositivotipoevento
     * @example
     * // Get one Reldispositivotipoevento
     * const reldispositivotipoevento = await prisma.reldispositivotipoevento.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends reldispositivotipoeventoFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, reldispositivotipoeventoFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'reldispositivotipoevento'> extends True ? Prisma__reldispositivotipoeventoClient<reldispositivotipoeventoGetPayload<T>> : Prisma__reldispositivotipoeventoClient<reldispositivotipoeventoGetPayload<T> | null, null>

    /**
     * Find the first Reldispositivotipoevento that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reldispositivotipoeventoFindFirstOrThrowArgs} args - Arguments to find a Reldispositivotipoevento
     * @example
     * // Get one Reldispositivotipoevento
     * const reldispositivotipoevento = await prisma.reldispositivotipoevento.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends reldispositivotipoeventoFindFirstOrThrowArgs>(
      args?: SelectSubset<T, reldispositivotipoeventoFindFirstOrThrowArgs>
    ): Prisma__reldispositivotipoeventoClient<reldispositivotipoeventoGetPayload<T>>

    /**
     * Find zero or more Reldispositivotipoeventos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reldispositivotipoeventoFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Reldispositivotipoeventos
     * const reldispositivotipoeventos = await prisma.reldispositivotipoevento.findMany()
     * 
     * // Get first 10 Reldispositivotipoeventos
     * const reldispositivotipoeventos = await prisma.reldispositivotipoevento.findMany({ take: 10 })
     * 
     * // Only select the `IDRelDisTipoEvento`
     * const reldispositivotipoeventoWithIDRelDisTipoEventoOnly = await prisma.reldispositivotipoevento.findMany({ select: { IDRelDisTipoEvento: true } })
     * 
    **/
    findMany<T extends reldispositivotipoeventoFindManyArgs>(
      args?: SelectSubset<T, reldispositivotipoeventoFindManyArgs>
    ): PrismaPromise<Array<reldispositivotipoeventoGetPayload<T>>>

    /**
     * Create a Reldispositivotipoevento.
     * @param {reldispositivotipoeventoCreateArgs} args - Arguments to create a Reldispositivotipoevento.
     * @example
     * // Create one Reldispositivotipoevento
     * const Reldispositivotipoevento = await prisma.reldispositivotipoevento.create({
     *   data: {
     *     // ... data to create a Reldispositivotipoevento
     *   }
     * })
     * 
    **/
    create<T extends reldispositivotipoeventoCreateArgs>(
      args: SelectSubset<T, reldispositivotipoeventoCreateArgs>
    ): Prisma__reldispositivotipoeventoClient<reldispositivotipoeventoGetPayload<T>>

    /**
     * Create many Reldispositivotipoeventos.
     *     @param {reldispositivotipoeventoCreateManyArgs} args - Arguments to create many Reldispositivotipoeventos.
     *     @example
     *     // Create many Reldispositivotipoeventos
     *     const reldispositivotipoevento = await prisma.reldispositivotipoevento.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends reldispositivotipoeventoCreateManyArgs>(
      args?: SelectSubset<T, reldispositivotipoeventoCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Reldispositivotipoevento.
     * @param {reldispositivotipoeventoDeleteArgs} args - Arguments to delete one Reldispositivotipoevento.
     * @example
     * // Delete one Reldispositivotipoevento
     * const Reldispositivotipoevento = await prisma.reldispositivotipoevento.delete({
     *   where: {
     *     // ... filter to delete one Reldispositivotipoevento
     *   }
     * })
     * 
    **/
    delete<T extends reldispositivotipoeventoDeleteArgs>(
      args: SelectSubset<T, reldispositivotipoeventoDeleteArgs>
    ): Prisma__reldispositivotipoeventoClient<reldispositivotipoeventoGetPayload<T>>

    /**
     * Update one Reldispositivotipoevento.
     * @param {reldispositivotipoeventoUpdateArgs} args - Arguments to update one Reldispositivotipoevento.
     * @example
     * // Update one Reldispositivotipoevento
     * const reldispositivotipoevento = await prisma.reldispositivotipoevento.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends reldispositivotipoeventoUpdateArgs>(
      args: SelectSubset<T, reldispositivotipoeventoUpdateArgs>
    ): Prisma__reldispositivotipoeventoClient<reldispositivotipoeventoGetPayload<T>>

    /**
     * Delete zero or more Reldispositivotipoeventos.
     * @param {reldispositivotipoeventoDeleteManyArgs} args - Arguments to filter Reldispositivotipoeventos to delete.
     * @example
     * // Delete a few Reldispositivotipoeventos
     * const { count } = await prisma.reldispositivotipoevento.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends reldispositivotipoeventoDeleteManyArgs>(
      args?: SelectSubset<T, reldispositivotipoeventoDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Reldispositivotipoeventos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reldispositivotipoeventoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Reldispositivotipoeventos
     * const reldispositivotipoevento = await prisma.reldispositivotipoevento.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends reldispositivotipoeventoUpdateManyArgs>(
      args: SelectSubset<T, reldispositivotipoeventoUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Reldispositivotipoevento.
     * @param {reldispositivotipoeventoUpsertArgs} args - Arguments to update or create a Reldispositivotipoevento.
     * @example
     * // Update or create a Reldispositivotipoevento
     * const reldispositivotipoevento = await prisma.reldispositivotipoevento.upsert({
     *   create: {
     *     // ... data to create a Reldispositivotipoevento
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Reldispositivotipoevento we want to update
     *   }
     * })
    **/
    upsert<T extends reldispositivotipoeventoUpsertArgs>(
      args: SelectSubset<T, reldispositivotipoeventoUpsertArgs>
    ): Prisma__reldispositivotipoeventoClient<reldispositivotipoeventoGetPayload<T>>

    /**
     * Count the number of Reldispositivotipoeventos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reldispositivotipoeventoCountArgs} args - Arguments to filter Reldispositivotipoeventos to count.
     * @example
     * // Count the number of Reldispositivotipoeventos
     * const count = await prisma.reldispositivotipoevento.count({
     *   where: {
     *     // ... the filter for the Reldispositivotipoeventos we want to count
     *   }
     * })
    **/
    count<T extends reldispositivotipoeventoCountArgs>(
      args?: Subset<T, reldispositivotipoeventoCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReldispositivotipoeventoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Reldispositivotipoevento.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReldispositivotipoeventoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReldispositivotipoeventoAggregateArgs>(args: Subset<T, ReldispositivotipoeventoAggregateArgs>): PrismaPromise<GetReldispositivotipoeventoAggregateType<T>>

    /**
     * Group by Reldispositivotipoevento.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReldispositivotipoeventoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReldispositivotipoeventoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReldispositivotipoeventoGroupByArgs['orderBy'] }
        : { orderBy?: ReldispositivotipoeventoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReldispositivotipoeventoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReldispositivotipoeventoGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for reldispositivotipoevento.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__reldispositivotipoeventoClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * reldispositivotipoevento base type for findUnique actions
   */
  export type reldispositivotipoeventoFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the reldispositivotipoevento
     * 
    **/
    select?: reldispositivotipoeventoSelect | null
    /**
     * Filter, which reldispositivotipoevento to fetch.
     * 
    **/
    where: reldispositivotipoeventoWhereUniqueInput
  }

  /**
   * reldispositivotipoevento: findUnique
   */
  export interface reldispositivotipoeventoFindUniqueArgs extends reldispositivotipoeventoFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * reldispositivotipoevento findUniqueOrThrow
   */
  export type reldispositivotipoeventoFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the reldispositivotipoevento
     * 
    **/
    select?: reldispositivotipoeventoSelect | null
    /**
     * Filter, which reldispositivotipoevento to fetch.
     * 
    **/
    where: reldispositivotipoeventoWhereUniqueInput
  }


  /**
   * reldispositivotipoevento base type for findFirst actions
   */
  export type reldispositivotipoeventoFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the reldispositivotipoevento
     * 
    **/
    select?: reldispositivotipoeventoSelect | null
    /**
     * Filter, which reldispositivotipoevento to fetch.
     * 
    **/
    where?: reldispositivotipoeventoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of reldispositivotipoeventos to fetch.
     * 
    **/
    orderBy?: Enumerable<reldispositivotipoeventoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for reldispositivotipoeventos.
     * 
    **/
    cursor?: reldispositivotipoeventoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` reldispositivotipoeventos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` reldispositivotipoeventos.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of reldispositivotipoeventos.
     * 
    **/
    distinct?: Enumerable<ReldispositivotipoeventoScalarFieldEnum>
  }

  /**
   * reldispositivotipoevento: findFirst
   */
  export interface reldispositivotipoeventoFindFirstArgs extends reldispositivotipoeventoFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * reldispositivotipoevento findFirstOrThrow
   */
  export type reldispositivotipoeventoFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the reldispositivotipoevento
     * 
    **/
    select?: reldispositivotipoeventoSelect | null
    /**
     * Filter, which reldispositivotipoevento to fetch.
     * 
    **/
    where?: reldispositivotipoeventoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of reldispositivotipoeventos to fetch.
     * 
    **/
    orderBy?: Enumerable<reldispositivotipoeventoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for reldispositivotipoeventos.
     * 
    **/
    cursor?: reldispositivotipoeventoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` reldispositivotipoeventos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` reldispositivotipoeventos.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of reldispositivotipoeventos.
     * 
    **/
    distinct?: Enumerable<ReldispositivotipoeventoScalarFieldEnum>
  }


  /**
   * reldispositivotipoevento findMany
   */
  export type reldispositivotipoeventoFindManyArgs = {
    /**
     * Select specific fields to fetch from the reldispositivotipoevento
     * 
    **/
    select?: reldispositivotipoeventoSelect | null
    /**
     * Filter, which reldispositivotipoeventos to fetch.
     * 
    **/
    where?: reldispositivotipoeventoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of reldispositivotipoeventos to fetch.
     * 
    **/
    orderBy?: Enumerable<reldispositivotipoeventoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing reldispositivotipoeventos.
     * 
    **/
    cursor?: reldispositivotipoeventoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` reldispositivotipoeventos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` reldispositivotipoeventos.
     * 
    **/
    skip?: number
    distinct?: Enumerable<ReldispositivotipoeventoScalarFieldEnum>
  }


  /**
   * reldispositivotipoevento create
   */
  export type reldispositivotipoeventoCreateArgs = {
    /**
     * Select specific fields to fetch from the reldispositivotipoevento
     * 
    **/
    select?: reldispositivotipoeventoSelect | null
    /**
     * The data needed to create a reldispositivotipoevento.
     * 
    **/
    data: XOR<reldispositivotipoeventoCreateInput, reldispositivotipoeventoUncheckedCreateInput>
  }


  /**
   * reldispositivotipoevento createMany
   */
  export type reldispositivotipoeventoCreateManyArgs = {
    /**
     * The data used to create many reldispositivotipoeventos.
     * 
    **/
    data: Enumerable<reldispositivotipoeventoCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * reldispositivotipoevento update
   */
  export type reldispositivotipoeventoUpdateArgs = {
    /**
     * Select specific fields to fetch from the reldispositivotipoevento
     * 
    **/
    select?: reldispositivotipoeventoSelect | null
    /**
     * The data needed to update a reldispositivotipoevento.
     * 
    **/
    data: XOR<reldispositivotipoeventoUpdateInput, reldispositivotipoeventoUncheckedUpdateInput>
    /**
     * Choose, which reldispositivotipoevento to update.
     * 
    **/
    where: reldispositivotipoeventoWhereUniqueInput
  }


  /**
   * reldispositivotipoevento updateMany
   */
  export type reldispositivotipoeventoUpdateManyArgs = {
    /**
     * The data used to update reldispositivotipoeventos.
     * 
    **/
    data: XOR<reldispositivotipoeventoUpdateManyMutationInput, reldispositivotipoeventoUncheckedUpdateManyInput>
    /**
     * Filter which reldispositivotipoeventos to update
     * 
    **/
    where?: reldispositivotipoeventoWhereInput
  }


  /**
   * reldispositivotipoevento upsert
   */
  export type reldispositivotipoeventoUpsertArgs = {
    /**
     * Select specific fields to fetch from the reldispositivotipoevento
     * 
    **/
    select?: reldispositivotipoeventoSelect | null
    /**
     * The filter to search for the reldispositivotipoevento to update in case it exists.
     * 
    **/
    where: reldispositivotipoeventoWhereUniqueInput
    /**
     * In case the reldispositivotipoevento found by the `where` argument doesn't exist, create a new reldispositivotipoevento with this data.
     * 
    **/
    create: XOR<reldispositivotipoeventoCreateInput, reldispositivotipoeventoUncheckedCreateInput>
    /**
     * In case the reldispositivotipoevento was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<reldispositivotipoeventoUpdateInput, reldispositivotipoeventoUncheckedUpdateInput>
  }


  /**
   * reldispositivotipoevento delete
   */
  export type reldispositivotipoeventoDeleteArgs = {
    /**
     * Select specific fields to fetch from the reldispositivotipoevento
     * 
    **/
    select?: reldispositivotipoeventoSelect | null
    /**
     * Filter which reldispositivotipoevento to delete.
     * 
    **/
    where: reldispositivotipoeventoWhereUniqueInput
  }


  /**
   * reldispositivotipoevento deleteMany
   */
  export type reldispositivotipoeventoDeleteManyArgs = {
    /**
     * Filter which reldispositivotipoeventos to delete
     * 
    **/
    where?: reldispositivotipoeventoWhereInput
  }


  /**
   * reldispositivotipoevento without action
   */
  export type reldispositivotipoeventoArgs = {
    /**
     * Select specific fields to fetch from the reldispositivotipoevento
     * 
    **/
    select?: reldispositivotipoeventoSelect | null
  }



  /**
   * Model reldispositivozona
   */


  export type AggregateReldispositivozona = {
    _count: ReldispositivozonaCountAggregateOutputType | null
    _avg: ReldispositivozonaAvgAggregateOutputType | null
    _sum: ReldispositivozonaSumAggregateOutputType | null
    _min: ReldispositivozonaMinAggregateOutputType | null
    _max: ReldispositivozonaMaxAggregateOutputType | null
  }

  export type ReldispositivozonaAvgAggregateOutputType = {
    IDRelDisZona: number | null
    IDDispositivo: number | null
    IDZona: number | null
  }

  export type ReldispositivozonaSumAggregateOutputType = {
    IDRelDisZona: number | null
    IDDispositivo: number | null
    IDZona: number | null
  }

  export type ReldispositivozonaMinAggregateOutputType = {
    IDRelDisZona: number | null
    IDDispositivo: number | null
    IDZona: number | null
  }

  export type ReldispositivozonaMaxAggregateOutputType = {
    IDRelDisZona: number | null
    IDDispositivo: number | null
    IDZona: number | null
  }

  export type ReldispositivozonaCountAggregateOutputType = {
    IDRelDisZona: number
    IDDispositivo: number
    IDZona: number
    _all: number
  }


  export type ReldispositivozonaAvgAggregateInputType = {
    IDRelDisZona?: true
    IDDispositivo?: true
    IDZona?: true
  }

  export type ReldispositivozonaSumAggregateInputType = {
    IDRelDisZona?: true
    IDDispositivo?: true
    IDZona?: true
  }

  export type ReldispositivozonaMinAggregateInputType = {
    IDRelDisZona?: true
    IDDispositivo?: true
    IDZona?: true
  }

  export type ReldispositivozonaMaxAggregateInputType = {
    IDRelDisZona?: true
    IDDispositivo?: true
    IDZona?: true
  }

  export type ReldispositivozonaCountAggregateInputType = {
    IDRelDisZona?: true
    IDDispositivo?: true
    IDZona?: true
    _all?: true
  }

  export type ReldispositivozonaAggregateArgs = {
    /**
     * Filter which reldispositivozona to aggregate.
     * 
    **/
    where?: reldispositivozonaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of reldispositivozonas to fetch.
     * 
    **/
    orderBy?: Enumerable<reldispositivozonaOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: reldispositivozonaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` reldispositivozonas from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` reldispositivozonas.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned reldispositivozonas
    **/
    _count?: true | ReldispositivozonaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ReldispositivozonaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ReldispositivozonaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReldispositivozonaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReldispositivozonaMaxAggregateInputType
  }

  export type GetReldispositivozonaAggregateType<T extends ReldispositivozonaAggregateArgs> = {
        [P in keyof T & keyof AggregateReldispositivozona]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReldispositivozona[P]>
      : GetScalarType<T[P], AggregateReldispositivozona[P]>
  }




  export type ReldispositivozonaGroupByArgs = {
    where?: reldispositivozonaWhereInput
    orderBy?: Enumerable<reldispositivozonaOrderByWithAggregationInput>
    by: Array<ReldispositivozonaScalarFieldEnum>
    having?: reldispositivozonaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReldispositivozonaCountAggregateInputType | true
    _avg?: ReldispositivozonaAvgAggregateInputType
    _sum?: ReldispositivozonaSumAggregateInputType
    _min?: ReldispositivozonaMinAggregateInputType
    _max?: ReldispositivozonaMaxAggregateInputType
  }


  export type ReldispositivozonaGroupByOutputType = {
    IDRelDisZona: number
    IDDispositivo: number | null
    IDZona: number | null
    _count: ReldispositivozonaCountAggregateOutputType | null
    _avg: ReldispositivozonaAvgAggregateOutputType | null
    _sum: ReldispositivozonaSumAggregateOutputType | null
    _min: ReldispositivozonaMinAggregateOutputType | null
    _max: ReldispositivozonaMaxAggregateOutputType | null
  }

  type GetReldispositivozonaGroupByPayload<T extends ReldispositivozonaGroupByArgs> = PrismaPromise<
    Array<
      PickArray<ReldispositivozonaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReldispositivozonaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReldispositivozonaGroupByOutputType[P]>
            : GetScalarType<T[P], ReldispositivozonaGroupByOutputType[P]>
        }
      >
    >


  export type reldispositivozonaSelect = {
    IDRelDisZona?: boolean
    IDDispositivo?: boolean
    IDZona?: boolean
  }


  export type reldispositivozonaGetPayload<S extends boolean | null | undefined | reldispositivozonaArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? reldispositivozona :
    S extends undefined ? never :
    S extends { include: any } & (reldispositivozonaArgs | reldispositivozonaFindManyArgs)
    ? reldispositivozona 
    : S extends { select: any } & (reldispositivozonaArgs | reldispositivozonaFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof reldispositivozona ? reldispositivozona[P] : never
  } 
      : reldispositivozona


  type reldispositivozonaCountArgs = Merge<
    Omit<reldispositivozonaFindManyArgs, 'select' | 'include'> & {
      select?: ReldispositivozonaCountAggregateInputType | true
    }
  >

  export interface reldispositivozonaDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Reldispositivozona that matches the filter.
     * @param {reldispositivozonaFindUniqueArgs} args - Arguments to find a Reldispositivozona
     * @example
     * // Get one Reldispositivozona
     * const reldispositivozona = await prisma.reldispositivozona.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends reldispositivozonaFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, reldispositivozonaFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'reldispositivozona'> extends True ? Prisma__reldispositivozonaClient<reldispositivozonaGetPayload<T>> : Prisma__reldispositivozonaClient<reldispositivozonaGetPayload<T> | null, null>

    /**
     * Find one Reldispositivozona that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {reldispositivozonaFindUniqueOrThrowArgs} args - Arguments to find a Reldispositivozona
     * @example
     * // Get one Reldispositivozona
     * const reldispositivozona = await prisma.reldispositivozona.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends reldispositivozonaFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, reldispositivozonaFindUniqueOrThrowArgs>
    ): Prisma__reldispositivozonaClient<reldispositivozonaGetPayload<T>>

    /**
     * Find the first Reldispositivozona that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reldispositivozonaFindFirstArgs} args - Arguments to find a Reldispositivozona
     * @example
     * // Get one Reldispositivozona
     * const reldispositivozona = await prisma.reldispositivozona.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends reldispositivozonaFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, reldispositivozonaFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'reldispositivozona'> extends True ? Prisma__reldispositivozonaClient<reldispositivozonaGetPayload<T>> : Prisma__reldispositivozonaClient<reldispositivozonaGetPayload<T> | null, null>

    /**
     * Find the first Reldispositivozona that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reldispositivozonaFindFirstOrThrowArgs} args - Arguments to find a Reldispositivozona
     * @example
     * // Get one Reldispositivozona
     * const reldispositivozona = await prisma.reldispositivozona.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends reldispositivozonaFindFirstOrThrowArgs>(
      args?: SelectSubset<T, reldispositivozonaFindFirstOrThrowArgs>
    ): Prisma__reldispositivozonaClient<reldispositivozonaGetPayload<T>>

    /**
     * Find zero or more Reldispositivozonas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reldispositivozonaFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Reldispositivozonas
     * const reldispositivozonas = await prisma.reldispositivozona.findMany()
     * 
     * // Get first 10 Reldispositivozonas
     * const reldispositivozonas = await prisma.reldispositivozona.findMany({ take: 10 })
     * 
     * // Only select the `IDRelDisZona`
     * const reldispositivozonaWithIDRelDisZonaOnly = await prisma.reldispositivozona.findMany({ select: { IDRelDisZona: true } })
     * 
    **/
    findMany<T extends reldispositivozonaFindManyArgs>(
      args?: SelectSubset<T, reldispositivozonaFindManyArgs>
    ): PrismaPromise<Array<reldispositivozonaGetPayload<T>>>

    /**
     * Create a Reldispositivozona.
     * @param {reldispositivozonaCreateArgs} args - Arguments to create a Reldispositivozona.
     * @example
     * // Create one Reldispositivozona
     * const Reldispositivozona = await prisma.reldispositivozona.create({
     *   data: {
     *     // ... data to create a Reldispositivozona
     *   }
     * })
     * 
    **/
    create<T extends reldispositivozonaCreateArgs>(
      args: SelectSubset<T, reldispositivozonaCreateArgs>
    ): Prisma__reldispositivozonaClient<reldispositivozonaGetPayload<T>>

    /**
     * Create many Reldispositivozonas.
     *     @param {reldispositivozonaCreateManyArgs} args - Arguments to create many Reldispositivozonas.
     *     @example
     *     // Create many Reldispositivozonas
     *     const reldispositivozona = await prisma.reldispositivozona.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends reldispositivozonaCreateManyArgs>(
      args?: SelectSubset<T, reldispositivozonaCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Reldispositivozona.
     * @param {reldispositivozonaDeleteArgs} args - Arguments to delete one Reldispositivozona.
     * @example
     * // Delete one Reldispositivozona
     * const Reldispositivozona = await prisma.reldispositivozona.delete({
     *   where: {
     *     // ... filter to delete one Reldispositivozona
     *   }
     * })
     * 
    **/
    delete<T extends reldispositivozonaDeleteArgs>(
      args: SelectSubset<T, reldispositivozonaDeleteArgs>
    ): Prisma__reldispositivozonaClient<reldispositivozonaGetPayload<T>>

    /**
     * Update one Reldispositivozona.
     * @param {reldispositivozonaUpdateArgs} args - Arguments to update one Reldispositivozona.
     * @example
     * // Update one Reldispositivozona
     * const reldispositivozona = await prisma.reldispositivozona.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends reldispositivozonaUpdateArgs>(
      args: SelectSubset<T, reldispositivozonaUpdateArgs>
    ): Prisma__reldispositivozonaClient<reldispositivozonaGetPayload<T>>

    /**
     * Delete zero or more Reldispositivozonas.
     * @param {reldispositivozonaDeleteManyArgs} args - Arguments to filter Reldispositivozonas to delete.
     * @example
     * // Delete a few Reldispositivozonas
     * const { count } = await prisma.reldispositivozona.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends reldispositivozonaDeleteManyArgs>(
      args?: SelectSubset<T, reldispositivozonaDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Reldispositivozonas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reldispositivozonaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Reldispositivozonas
     * const reldispositivozona = await prisma.reldispositivozona.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends reldispositivozonaUpdateManyArgs>(
      args: SelectSubset<T, reldispositivozonaUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Reldispositivozona.
     * @param {reldispositivozonaUpsertArgs} args - Arguments to update or create a Reldispositivozona.
     * @example
     * // Update or create a Reldispositivozona
     * const reldispositivozona = await prisma.reldispositivozona.upsert({
     *   create: {
     *     // ... data to create a Reldispositivozona
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Reldispositivozona we want to update
     *   }
     * })
    **/
    upsert<T extends reldispositivozonaUpsertArgs>(
      args: SelectSubset<T, reldispositivozonaUpsertArgs>
    ): Prisma__reldispositivozonaClient<reldispositivozonaGetPayload<T>>

    /**
     * Count the number of Reldispositivozonas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reldispositivozonaCountArgs} args - Arguments to filter Reldispositivozonas to count.
     * @example
     * // Count the number of Reldispositivozonas
     * const count = await prisma.reldispositivozona.count({
     *   where: {
     *     // ... the filter for the Reldispositivozonas we want to count
     *   }
     * })
    **/
    count<T extends reldispositivozonaCountArgs>(
      args?: Subset<T, reldispositivozonaCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReldispositivozonaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Reldispositivozona.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReldispositivozonaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReldispositivozonaAggregateArgs>(args: Subset<T, ReldispositivozonaAggregateArgs>): PrismaPromise<GetReldispositivozonaAggregateType<T>>

    /**
     * Group by Reldispositivozona.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReldispositivozonaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReldispositivozonaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReldispositivozonaGroupByArgs['orderBy'] }
        : { orderBy?: ReldispositivozonaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReldispositivozonaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReldispositivozonaGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for reldispositivozona.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__reldispositivozonaClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * reldispositivozona base type for findUnique actions
   */
  export type reldispositivozonaFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the reldispositivozona
     * 
    **/
    select?: reldispositivozonaSelect | null
    /**
     * Filter, which reldispositivozona to fetch.
     * 
    **/
    where: reldispositivozonaWhereUniqueInput
  }

  /**
   * reldispositivozona: findUnique
   */
  export interface reldispositivozonaFindUniqueArgs extends reldispositivozonaFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * reldispositivozona findUniqueOrThrow
   */
  export type reldispositivozonaFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the reldispositivozona
     * 
    **/
    select?: reldispositivozonaSelect | null
    /**
     * Filter, which reldispositivozona to fetch.
     * 
    **/
    where: reldispositivozonaWhereUniqueInput
  }


  /**
   * reldispositivozona base type for findFirst actions
   */
  export type reldispositivozonaFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the reldispositivozona
     * 
    **/
    select?: reldispositivozonaSelect | null
    /**
     * Filter, which reldispositivozona to fetch.
     * 
    **/
    where?: reldispositivozonaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of reldispositivozonas to fetch.
     * 
    **/
    orderBy?: Enumerable<reldispositivozonaOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for reldispositivozonas.
     * 
    **/
    cursor?: reldispositivozonaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` reldispositivozonas from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` reldispositivozonas.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of reldispositivozonas.
     * 
    **/
    distinct?: Enumerable<ReldispositivozonaScalarFieldEnum>
  }

  /**
   * reldispositivozona: findFirst
   */
  export interface reldispositivozonaFindFirstArgs extends reldispositivozonaFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * reldispositivozona findFirstOrThrow
   */
  export type reldispositivozonaFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the reldispositivozona
     * 
    **/
    select?: reldispositivozonaSelect | null
    /**
     * Filter, which reldispositivozona to fetch.
     * 
    **/
    where?: reldispositivozonaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of reldispositivozonas to fetch.
     * 
    **/
    orderBy?: Enumerable<reldispositivozonaOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for reldispositivozonas.
     * 
    **/
    cursor?: reldispositivozonaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` reldispositivozonas from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` reldispositivozonas.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of reldispositivozonas.
     * 
    **/
    distinct?: Enumerable<ReldispositivozonaScalarFieldEnum>
  }


  /**
   * reldispositivozona findMany
   */
  export type reldispositivozonaFindManyArgs = {
    /**
     * Select specific fields to fetch from the reldispositivozona
     * 
    **/
    select?: reldispositivozonaSelect | null
    /**
     * Filter, which reldispositivozonas to fetch.
     * 
    **/
    where?: reldispositivozonaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of reldispositivozonas to fetch.
     * 
    **/
    orderBy?: Enumerable<reldispositivozonaOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing reldispositivozonas.
     * 
    **/
    cursor?: reldispositivozonaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` reldispositivozonas from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` reldispositivozonas.
     * 
    **/
    skip?: number
    distinct?: Enumerable<ReldispositivozonaScalarFieldEnum>
  }


  /**
   * reldispositivozona create
   */
  export type reldispositivozonaCreateArgs = {
    /**
     * Select specific fields to fetch from the reldispositivozona
     * 
    **/
    select?: reldispositivozonaSelect | null
    /**
     * The data needed to create a reldispositivozona.
     * 
    **/
    data: XOR<reldispositivozonaCreateInput, reldispositivozonaUncheckedCreateInput>
  }


  /**
   * reldispositivozona createMany
   */
  export type reldispositivozonaCreateManyArgs = {
    /**
     * The data used to create many reldispositivozonas.
     * 
    **/
    data: Enumerable<reldispositivozonaCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * reldispositivozona update
   */
  export type reldispositivozonaUpdateArgs = {
    /**
     * Select specific fields to fetch from the reldispositivozona
     * 
    **/
    select?: reldispositivozonaSelect | null
    /**
     * The data needed to update a reldispositivozona.
     * 
    **/
    data: XOR<reldispositivozonaUpdateInput, reldispositivozonaUncheckedUpdateInput>
    /**
     * Choose, which reldispositivozona to update.
     * 
    **/
    where: reldispositivozonaWhereUniqueInput
  }


  /**
   * reldispositivozona updateMany
   */
  export type reldispositivozonaUpdateManyArgs = {
    /**
     * The data used to update reldispositivozonas.
     * 
    **/
    data: XOR<reldispositivozonaUpdateManyMutationInput, reldispositivozonaUncheckedUpdateManyInput>
    /**
     * Filter which reldispositivozonas to update
     * 
    **/
    where?: reldispositivozonaWhereInput
  }


  /**
   * reldispositivozona upsert
   */
  export type reldispositivozonaUpsertArgs = {
    /**
     * Select specific fields to fetch from the reldispositivozona
     * 
    **/
    select?: reldispositivozonaSelect | null
    /**
     * The filter to search for the reldispositivozona to update in case it exists.
     * 
    **/
    where: reldispositivozonaWhereUniqueInput
    /**
     * In case the reldispositivozona found by the `where` argument doesn't exist, create a new reldispositivozona with this data.
     * 
    **/
    create: XOR<reldispositivozonaCreateInput, reldispositivozonaUncheckedCreateInput>
    /**
     * In case the reldispositivozona was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<reldispositivozonaUpdateInput, reldispositivozonaUncheckedUpdateInput>
  }


  /**
   * reldispositivozona delete
   */
  export type reldispositivozonaDeleteArgs = {
    /**
     * Select specific fields to fetch from the reldispositivozona
     * 
    **/
    select?: reldispositivozonaSelect | null
    /**
     * Filter which reldispositivozona to delete.
     * 
    **/
    where: reldispositivozonaWhereUniqueInput
  }


  /**
   * reldispositivozona deleteMany
   */
  export type reldispositivozonaDeleteManyArgs = {
    /**
     * Filter which reldispositivozonas to delete
     * 
    **/
    where?: reldispositivozonaWhereInput
  }


  /**
   * reldispositivozona without action
   */
  export type reldispositivozonaArgs = {
    /**
     * Select specific fields to fetch from the reldispositivozona
     * 
    **/
    select?: reldispositivozonaSelect | null
  }



  /**
   * Model reltipocontroladormetodo
   */


  export type AggregateReltipocontroladormetodo = {
    _count: ReltipocontroladormetodoCountAggregateOutputType | null
    _avg: ReltipocontroladormetodoAvgAggregateOutputType | null
    _sum: ReltipocontroladormetodoSumAggregateOutputType | null
    _min: ReltipocontroladormetodoMinAggregateOutputType | null
    _max: ReltipocontroladormetodoMaxAggregateOutputType | null
  }

  export type ReltipocontroladormetodoAvgAggregateOutputType = {
    IDTipoControlador: number | null
    IDMetodo: number | null
    RelTipoControladorMetodo: number | null
  }

  export type ReltipocontroladormetodoSumAggregateOutputType = {
    IDTipoControlador: number | null
    IDMetodo: number | null
    RelTipoControladorMetodo: number | null
  }

  export type ReltipocontroladormetodoMinAggregateOutputType = {
    IDTipoControlador: number | null
    IDMetodo: number | null
    RelTipoControladorMetodo: number | null
  }

  export type ReltipocontroladormetodoMaxAggregateOutputType = {
    IDTipoControlador: number | null
    IDMetodo: number | null
    RelTipoControladorMetodo: number | null
  }

  export type ReltipocontroladormetodoCountAggregateOutputType = {
    IDTipoControlador: number
    IDMetodo: number
    RelTipoControladorMetodo: number
    _all: number
  }


  export type ReltipocontroladormetodoAvgAggregateInputType = {
    IDTipoControlador?: true
    IDMetodo?: true
    RelTipoControladorMetodo?: true
  }

  export type ReltipocontroladormetodoSumAggregateInputType = {
    IDTipoControlador?: true
    IDMetodo?: true
    RelTipoControladorMetodo?: true
  }

  export type ReltipocontroladormetodoMinAggregateInputType = {
    IDTipoControlador?: true
    IDMetodo?: true
    RelTipoControladorMetodo?: true
  }

  export type ReltipocontroladormetodoMaxAggregateInputType = {
    IDTipoControlador?: true
    IDMetodo?: true
    RelTipoControladorMetodo?: true
  }

  export type ReltipocontroladormetodoCountAggregateInputType = {
    IDTipoControlador?: true
    IDMetodo?: true
    RelTipoControladorMetodo?: true
    _all?: true
  }

  export type ReltipocontroladormetodoAggregateArgs = {
    /**
     * Filter which reltipocontroladormetodo to aggregate.
     * 
    **/
    where?: reltipocontroladormetodoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of reltipocontroladormetodos to fetch.
     * 
    **/
    orderBy?: Enumerable<reltipocontroladormetodoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: reltipocontroladormetodoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` reltipocontroladormetodos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` reltipocontroladormetodos.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned reltipocontroladormetodos
    **/
    _count?: true | ReltipocontroladormetodoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ReltipocontroladormetodoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ReltipocontroladormetodoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReltipocontroladormetodoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReltipocontroladormetodoMaxAggregateInputType
  }

  export type GetReltipocontroladormetodoAggregateType<T extends ReltipocontroladormetodoAggregateArgs> = {
        [P in keyof T & keyof AggregateReltipocontroladormetodo]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReltipocontroladormetodo[P]>
      : GetScalarType<T[P], AggregateReltipocontroladormetodo[P]>
  }




  export type ReltipocontroladormetodoGroupByArgs = {
    where?: reltipocontroladormetodoWhereInput
    orderBy?: Enumerable<reltipocontroladormetodoOrderByWithAggregationInput>
    by: Array<ReltipocontroladormetodoScalarFieldEnum>
    having?: reltipocontroladormetodoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReltipocontroladormetodoCountAggregateInputType | true
    _avg?: ReltipocontroladormetodoAvgAggregateInputType
    _sum?: ReltipocontroladormetodoSumAggregateInputType
    _min?: ReltipocontroladormetodoMinAggregateInputType
    _max?: ReltipocontroladormetodoMaxAggregateInputType
  }


  export type ReltipocontroladormetodoGroupByOutputType = {
    IDTipoControlador: number
    IDMetodo: number | null
    RelTipoControladorMetodo: number | null
    _count: ReltipocontroladormetodoCountAggregateOutputType | null
    _avg: ReltipocontroladormetodoAvgAggregateOutputType | null
    _sum: ReltipocontroladormetodoSumAggregateOutputType | null
    _min: ReltipocontroladormetodoMinAggregateOutputType | null
    _max: ReltipocontroladormetodoMaxAggregateOutputType | null
  }

  type GetReltipocontroladormetodoGroupByPayload<T extends ReltipocontroladormetodoGroupByArgs> = PrismaPromise<
    Array<
      PickArray<ReltipocontroladormetodoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReltipocontroladormetodoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReltipocontroladormetodoGroupByOutputType[P]>
            : GetScalarType<T[P], ReltipocontroladormetodoGroupByOutputType[P]>
        }
      >
    >


  export type reltipocontroladormetodoSelect = {
    IDTipoControlador?: boolean
    IDMetodo?: boolean
    RelTipoControladorMetodo?: boolean
  }


  export type reltipocontroladormetodoGetPayload<S extends boolean | null | undefined | reltipocontroladormetodoArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? reltipocontroladormetodo :
    S extends undefined ? never :
    S extends { include: any } & (reltipocontroladormetodoArgs | reltipocontroladormetodoFindManyArgs)
    ? reltipocontroladormetodo 
    : S extends { select: any } & (reltipocontroladormetodoArgs | reltipocontroladormetodoFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof reltipocontroladormetodo ? reltipocontroladormetodo[P] : never
  } 
      : reltipocontroladormetodo


  type reltipocontroladormetodoCountArgs = Merge<
    Omit<reltipocontroladormetodoFindManyArgs, 'select' | 'include'> & {
      select?: ReltipocontroladormetodoCountAggregateInputType | true
    }
  >

  export interface reltipocontroladormetodoDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Reltipocontroladormetodo that matches the filter.
     * @param {reltipocontroladormetodoFindUniqueArgs} args - Arguments to find a Reltipocontroladormetodo
     * @example
     * // Get one Reltipocontroladormetodo
     * const reltipocontroladormetodo = await prisma.reltipocontroladormetodo.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends reltipocontroladormetodoFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, reltipocontroladormetodoFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'reltipocontroladormetodo'> extends True ? Prisma__reltipocontroladormetodoClient<reltipocontroladormetodoGetPayload<T>> : Prisma__reltipocontroladormetodoClient<reltipocontroladormetodoGetPayload<T> | null, null>

    /**
     * Find one Reltipocontroladormetodo that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {reltipocontroladormetodoFindUniqueOrThrowArgs} args - Arguments to find a Reltipocontroladormetodo
     * @example
     * // Get one Reltipocontroladormetodo
     * const reltipocontroladormetodo = await prisma.reltipocontroladormetodo.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends reltipocontroladormetodoFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, reltipocontroladormetodoFindUniqueOrThrowArgs>
    ): Prisma__reltipocontroladormetodoClient<reltipocontroladormetodoGetPayload<T>>

    /**
     * Find the first Reltipocontroladormetodo that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reltipocontroladormetodoFindFirstArgs} args - Arguments to find a Reltipocontroladormetodo
     * @example
     * // Get one Reltipocontroladormetodo
     * const reltipocontroladormetodo = await prisma.reltipocontroladormetodo.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends reltipocontroladormetodoFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, reltipocontroladormetodoFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'reltipocontroladormetodo'> extends True ? Prisma__reltipocontroladormetodoClient<reltipocontroladormetodoGetPayload<T>> : Prisma__reltipocontroladormetodoClient<reltipocontroladormetodoGetPayload<T> | null, null>

    /**
     * Find the first Reltipocontroladormetodo that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reltipocontroladormetodoFindFirstOrThrowArgs} args - Arguments to find a Reltipocontroladormetodo
     * @example
     * // Get one Reltipocontroladormetodo
     * const reltipocontroladormetodo = await prisma.reltipocontroladormetodo.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends reltipocontroladormetodoFindFirstOrThrowArgs>(
      args?: SelectSubset<T, reltipocontroladormetodoFindFirstOrThrowArgs>
    ): Prisma__reltipocontroladormetodoClient<reltipocontroladormetodoGetPayload<T>>

    /**
     * Find zero or more Reltipocontroladormetodos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reltipocontroladormetodoFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Reltipocontroladormetodos
     * const reltipocontroladormetodos = await prisma.reltipocontroladormetodo.findMany()
     * 
     * // Get first 10 Reltipocontroladormetodos
     * const reltipocontroladormetodos = await prisma.reltipocontroladormetodo.findMany({ take: 10 })
     * 
     * // Only select the `IDTipoControlador`
     * const reltipocontroladormetodoWithIDTipoControladorOnly = await prisma.reltipocontroladormetodo.findMany({ select: { IDTipoControlador: true } })
     * 
    **/
    findMany<T extends reltipocontroladormetodoFindManyArgs>(
      args?: SelectSubset<T, reltipocontroladormetodoFindManyArgs>
    ): PrismaPromise<Array<reltipocontroladormetodoGetPayload<T>>>

    /**
     * Create a Reltipocontroladormetodo.
     * @param {reltipocontroladormetodoCreateArgs} args - Arguments to create a Reltipocontroladormetodo.
     * @example
     * // Create one Reltipocontroladormetodo
     * const Reltipocontroladormetodo = await prisma.reltipocontroladormetodo.create({
     *   data: {
     *     // ... data to create a Reltipocontroladormetodo
     *   }
     * })
     * 
    **/
    create<T extends reltipocontroladormetodoCreateArgs>(
      args: SelectSubset<T, reltipocontroladormetodoCreateArgs>
    ): Prisma__reltipocontroladormetodoClient<reltipocontroladormetodoGetPayload<T>>

    /**
     * Create many Reltipocontroladormetodos.
     *     @param {reltipocontroladormetodoCreateManyArgs} args - Arguments to create many Reltipocontroladormetodos.
     *     @example
     *     // Create many Reltipocontroladormetodos
     *     const reltipocontroladormetodo = await prisma.reltipocontroladormetodo.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends reltipocontroladormetodoCreateManyArgs>(
      args?: SelectSubset<T, reltipocontroladormetodoCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Reltipocontroladormetodo.
     * @param {reltipocontroladormetodoDeleteArgs} args - Arguments to delete one Reltipocontroladormetodo.
     * @example
     * // Delete one Reltipocontroladormetodo
     * const Reltipocontroladormetodo = await prisma.reltipocontroladormetodo.delete({
     *   where: {
     *     // ... filter to delete one Reltipocontroladormetodo
     *   }
     * })
     * 
    **/
    delete<T extends reltipocontroladormetodoDeleteArgs>(
      args: SelectSubset<T, reltipocontroladormetodoDeleteArgs>
    ): Prisma__reltipocontroladormetodoClient<reltipocontroladormetodoGetPayload<T>>

    /**
     * Update one Reltipocontroladormetodo.
     * @param {reltipocontroladormetodoUpdateArgs} args - Arguments to update one Reltipocontroladormetodo.
     * @example
     * // Update one Reltipocontroladormetodo
     * const reltipocontroladormetodo = await prisma.reltipocontroladormetodo.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends reltipocontroladormetodoUpdateArgs>(
      args: SelectSubset<T, reltipocontroladormetodoUpdateArgs>
    ): Prisma__reltipocontroladormetodoClient<reltipocontroladormetodoGetPayload<T>>

    /**
     * Delete zero or more Reltipocontroladormetodos.
     * @param {reltipocontroladormetodoDeleteManyArgs} args - Arguments to filter Reltipocontroladormetodos to delete.
     * @example
     * // Delete a few Reltipocontroladormetodos
     * const { count } = await prisma.reltipocontroladormetodo.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends reltipocontroladormetodoDeleteManyArgs>(
      args?: SelectSubset<T, reltipocontroladormetodoDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Reltipocontroladormetodos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reltipocontroladormetodoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Reltipocontroladormetodos
     * const reltipocontroladormetodo = await prisma.reltipocontroladormetodo.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends reltipocontroladormetodoUpdateManyArgs>(
      args: SelectSubset<T, reltipocontroladormetodoUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Reltipocontroladormetodo.
     * @param {reltipocontroladormetodoUpsertArgs} args - Arguments to update or create a Reltipocontroladormetodo.
     * @example
     * // Update or create a Reltipocontroladormetodo
     * const reltipocontroladormetodo = await prisma.reltipocontroladormetodo.upsert({
     *   create: {
     *     // ... data to create a Reltipocontroladormetodo
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Reltipocontroladormetodo we want to update
     *   }
     * })
    **/
    upsert<T extends reltipocontroladormetodoUpsertArgs>(
      args: SelectSubset<T, reltipocontroladormetodoUpsertArgs>
    ): Prisma__reltipocontroladormetodoClient<reltipocontroladormetodoGetPayload<T>>

    /**
     * Count the number of Reltipocontroladormetodos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reltipocontroladormetodoCountArgs} args - Arguments to filter Reltipocontroladormetodos to count.
     * @example
     * // Count the number of Reltipocontroladormetodos
     * const count = await prisma.reltipocontroladormetodo.count({
     *   where: {
     *     // ... the filter for the Reltipocontroladormetodos we want to count
     *   }
     * })
    **/
    count<T extends reltipocontroladormetodoCountArgs>(
      args?: Subset<T, reltipocontroladormetodoCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReltipocontroladormetodoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Reltipocontroladormetodo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReltipocontroladormetodoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReltipocontroladormetodoAggregateArgs>(args: Subset<T, ReltipocontroladormetodoAggregateArgs>): PrismaPromise<GetReltipocontroladormetodoAggregateType<T>>

    /**
     * Group by Reltipocontroladormetodo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReltipocontroladormetodoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReltipocontroladormetodoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReltipocontroladormetodoGroupByArgs['orderBy'] }
        : { orderBy?: ReltipocontroladormetodoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReltipocontroladormetodoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReltipocontroladormetodoGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for reltipocontroladormetodo.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__reltipocontroladormetodoClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * reltipocontroladormetodo base type for findUnique actions
   */
  export type reltipocontroladormetodoFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the reltipocontroladormetodo
     * 
    **/
    select?: reltipocontroladormetodoSelect | null
    /**
     * Filter, which reltipocontroladormetodo to fetch.
     * 
    **/
    where: reltipocontroladormetodoWhereUniqueInput
  }

  /**
   * reltipocontroladormetodo: findUnique
   */
  export interface reltipocontroladormetodoFindUniqueArgs extends reltipocontroladormetodoFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * reltipocontroladormetodo findUniqueOrThrow
   */
  export type reltipocontroladormetodoFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the reltipocontroladormetodo
     * 
    **/
    select?: reltipocontroladormetodoSelect | null
    /**
     * Filter, which reltipocontroladormetodo to fetch.
     * 
    **/
    where: reltipocontroladormetodoWhereUniqueInput
  }


  /**
   * reltipocontroladormetodo base type for findFirst actions
   */
  export type reltipocontroladormetodoFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the reltipocontroladormetodo
     * 
    **/
    select?: reltipocontroladormetodoSelect | null
    /**
     * Filter, which reltipocontroladormetodo to fetch.
     * 
    **/
    where?: reltipocontroladormetodoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of reltipocontroladormetodos to fetch.
     * 
    **/
    orderBy?: Enumerable<reltipocontroladormetodoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for reltipocontroladormetodos.
     * 
    **/
    cursor?: reltipocontroladormetodoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` reltipocontroladormetodos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` reltipocontroladormetodos.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of reltipocontroladormetodos.
     * 
    **/
    distinct?: Enumerable<ReltipocontroladormetodoScalarFieldEnum>
  }

  /**
   * reltipocontroladormetodo: findFirst
   */
  export interface reltipocontroladormetodoFindFirstArgs extends reltipocontroladormetodoFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * reltipocontroladormetodo findFirstOrThrow
   */
  export type reltipocontroladormetodoFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the reltipocontroladormetodo
     * 
    **/
    select?: reltipocontroladormetodoSelect | null
    /**
     * Filter, which reltipocontroladormetodo to fetch.
     * 
    **/
    where?: reltipocontroladormetodoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of reltipocontroladormetodos to fetch.
     * 
    **/
    orderBy?: Enumerable<reltipocontroladormetodoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for reltipocontroladormetodos.
     * 
    **/
    cursor?: reltipocontroladormetodoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` reltipocontroladormetodos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` reltipocontroladormetodos.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of reltipocontroladormetodos.
     * 
    **/
    distinct?: Enumerable<ReltipocontroladormetodoScalarFieldEnum>
  }


  /**
   * reltipocontroladormetodo findMany
   */
  export type reltipocontroladormetodoFindManyArgs = {
    /**
     * Select specific fields to fetch from the reltipocontroladormetodo
     * 
    **/
    select?: reltipocontroladormetodoSelect | null
    /**
     * Filter, which reltipocontroladormetodos to fetch.
     * 
    **/
    where?: reltipocontroladormetodoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of reltipocontroladormetodos to fetch.
     * 
    **/
    orderBy?: Enumerable<reltipocontroladormetodoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing reltipocontroladormetodos.
     * 
    **/
    cursor?: reltipocontroladormetodoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` reltipocontroladormetodos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` reltipocontroladormetodos.
     * 
    **/
    skip?: number
    distinct?: Enumerable<ReltipocontroladormetodoScalarFieldEnum>
  }


  /**
   * reltipocontroladormetodo create
   */
  export type reltipocontroladormetodoCreateArgs = {
    /**
     * Select specific fields to fetch from the reltipocontroladormetodo
     * 
    **/
    select?: reltipocontroladormetodoSelect | null
    /**
     * The data needed to create a reltipocontroladormetodo.
     * 
    **/
    data: XOR<reltipocontroladormetodoCreateInput, reltipocontroladormetodoUncheckedCreateInput>
  }


  /**
   * reltipocontroladormetodo createMany
   */
  export type reltipocontroladormetodoCreateManyArgs = {
    /**
     * The data used to create many reltipocontroladormetodos.
     * 
    **/
    data: Enumerable<reltipocontroladormetodoCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * reltipocontroladormetodo update
   */
  export type reltipocontroladormetodoUpdateArgs = {
    /**
     * Select specific fields to fetch from the reltipocontroladormetodo
     * 
    **/
    select?: reltipocontroladormetodoSelect | null
    /**
     * The data needed to update a reltipocontroladormetodo.
     * 
    **/
    data: XOR<reltipocontroladormetodoUpdateInput, reltipocontroladormetodoUncheckedUpdateInput>
    /**
     * Choose, which reltipocontroladormetodo to update.
     * 
    **/
    where: reltipocontroladormetodoWhereUniqueInput
  }


  /**
   * reltipocontroladormetodo updateMany
   */
  export type reltipocontroladormetodoUpdateManyArgs = {
    /**
     * The data used to update reltipocontroladormetodos.
     * 
    **/
    data: XOR<reltipocontroladormetodoUpdateManyMutationInput, reltipocontroladormetodoUncheckedUpdateManyInput>
    /**
     * Filter which reltipocontroladormetodos to update
     * 
    **/
    where?: reltipocontroladormetodoWhereInput
  }


  /**
   * reltipocontroladormetodo upsert
   */
  export type reltipocontroladormetodoUpsertArgs = {
    /**
     * Select specific fields to fetch from the reltipocontroladormetodo
     * 
    **/
    select?: reltipocontroladormetodoSelect | null
    /**
     * The filter to search for the reltipocontroladormetodo to update in case it exists.
     * 
    **/
    where: reltipocontroladormetodoWhereUniqueInput
    /**
     * In case the reltipocontroladormetodo found by the `where` argument doesn't exist, create a new reltipocontroladormetodo with this data.
     * 
    **/
    create: XOR<reltipocontroladormetodoCreateInput, reltipocontroladormetodoUncheckedCreateInput>
    /**
     * In case the reltipocontroladormetodo was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<reltipocontroladormetodoUpdateInput, reltipocontroladormetodoUncheckedUpdateInput>
  }


  /**
   * reltipocontroladormetodo delete
   */
  export type reltipocontroladormetodoDeleteArgs = {
    /**
     * Select specific fields to fetch from the reltipocontroladormetodo
     * 
    **/
    select?: reltipocontroladormetodoSelect | null
    /**
     * Filter which reltipocontroladormetodo to delete.
     * 
    **/
    where: reltipocontroladormetodoWhereUniqueInput
  }


  /**
   * reltipocontroladormetodo deleteMany
   */
  export type reltipocontroladormetodoDeleteManyArgs = {
    /**
     * Filter which reltipocontroladormetodos to delete
     * 
    **/
    where?: reltipocontroladormetodoWhereInput
  }


  /**
   * reltipocontroladormetodo without action
   */
  export type reltipocontroladormetodoArgs = {
    /**
     * Select specific fields to fetch from the reltipocontroladormetodo
     * 
    **/
    select?: reltipocontroladormetodoSelect | null
  }



  /**
   * Model reltipodispositivoperfildispositivo
   */


  export type AggregateReltipodispositivoperfildispositivo = {
    _count: ReltipodispositivoperfildispositivoCountAggregateOutputType | null
    _avg: ReltipodispositivoperfildispositivoAvgAggregateOutputType | null
    _sum: ReltipodispositivoperfildispositivoSumAggregateOutputType | null
    _min: ReltipodispositivoperfildispositivoMinAggregateOutputType | null
    _max: ReltipodispositivoperfildispositivoMaxAggregateOutputType | null
  }

  export type ReltipodispositivoperfildispositivoAvgAggregateOutputType = {
    IDRelTipoDispPerfil: number | null
    IDTipoDispositivo: number | null
    IDPerfilDispositivo: number | null
  }

  export type ReltipodispositivoperfildispositivoSumAggregateOutputType = {
    IDRelTipoDispPerfil: number | null
    IDTipoDispositivo: number | null
    IDPerfilDispositivo: number | null
  }

  export type ReltipodispositivoperfildispositivoMinAggregateOutputType = {
    IDRelTipoDispPerfil: number | null
    IDTipoDispositivo: number | null
    IDPerfilDispositivo: number | null
  }

  export type ReltipodispositivoperfildispositivoMaxAggregateOutputType = {
    IDRelTipoDispPerfil: number | null
    IDTipoDispositivo: number | null
    IDPerfilDispositivo: number | null
  }

  export type ReltipodispositivoperfildispositivoCountAggregateOutputType = {
    IDRelTipoDispPerfil: number
    IDTipoDispositivo: number
    IDPerfilDispositivo: number
    _all: number
  }


  export type ReltipodispositivoperfildispositivoAvgAggregateInputType = {
    IDRelTipoDispPerfil?: true
    IDTipoDispositivo?: true
    IDPerfilDispositivo?: true
  }

  export type ReltipodispositivoperfildispositivoSumAggregateInputType = {
    IDRelTipoDispPerfil?: true
    IDTipoDispositivo?: true
    IDPerfilDispositivo?: true
  }

  export type ReltipodispositivoperfildispositivoMinAggregateInputType = {
    IDRelTipoDispPerfil?: true
    IDTipoDispositivo?: true
    IDPerfilDispositivo?: true
  }

  export type ReltipodispositivoperfildispositivoMaxAggregateInputType = {
    IDRelTipoDispPerfil?: true
    IDTipoDispositivo?: true
    IDPerfilDispositivo?: true
  }

  export type ReltipodispositivoperfildispositivoCountAggregateInputType = {
    IDRelTipoDispPerfil?: true
    IDTipoDispositivo?: true
    IDPerfilDispositivo?: true
    _all?: true
  }

  export type ReltipodispositivoperfildispositivoAggregateArgs = {
    /**
     * Filter which reltipodispositivoperfildispositivo to aggregate.
     * 
    **/
    where?: reltipodispositivoperfildispositivoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of reltipodispositivoperfildispositivos to fetch.
     * 
    **/
    orderBy?: Enumerable<reltipodispositivoperfildispositivoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: reltipodispositivoperfildispositivoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` reltipodispositivoperfildispositivos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` reltipodispositivoperfildispositivos.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned reltipodispositivoperfildispositivos
    **/
    _count?: true | ReltipodispositivoperfildispositivoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ReltipodispositivoperfildispositivoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ReltipodispositivoperfildispositivoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReltipodispositivoperfildispositivoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReltipodispositivoperfildispositivoMaxAggregateInputType
  }

  export type GetReltipodispositivoperfildispositivoAggregateType<T extends ReltipodispositivoperfildispositivoAggregateArgs> = {
        [P in keyof T & keyof AggregateReltipodispositivoperfildispositivo]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReltipodispositivoperfildispositivo[P]>
      : GetScalarType<T[P], AggregateReltipodispositivoperfildispositivo[P]>
  }




  export type ReltipodispositivoperfildispositivoGroupByArgs = {
    where?: reltipodispositivoperfildispositivoWhereInput
    orderBy?: Enumerable<reltipodispositivoperfildispositivoOrderByWithAggregationInput>
    by: Array<ReltipodispositivoperfildispositivoScalarFieldEnum>
    having?: reltipodispositivoperfildispositivoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReltipodispositivoperfildispositivoCountAggregateInputType | true
    _avg?: ReltipodispositivoperfildispositivoAvgAggregateInputType
    _sum?: ReltipodispositivoperfildispositivoSumAggregateInputType
    _min?: ReltipodispositivoperfildispositivoMinAggregateInputType
    _max?: ReltipodispositivoperfildispositivoMaxAggregateInputType
  }


  export type ReltipodispositivoperfildispositivoGroupByOutputType = {
    IDRelTipoDispPerfil: number
    IDTipoDispositivo: number
    IDPerfilDispositivo: number
    _count: ReltipodispositivoperfildispositivoCountAggregateOutputType | null
    _avg: ReltipodispositivoperfildispositivoAvgAggregateOutputType | null
    _sum: ReltipodispositivoperfildispositivoSumAggregateOutputType | null
    _min: ReltipodispositivoperfildispositivoMinAggregateOutputType | null
    _max: ReltipodispositivoperfildispositivoMaxAggregateOutputType | null
  }

  type GetReltipodispositivoperfildispositivoGroupByPayload<T extends ReltipodispositivoperfildispositivoGroupByArgs> = PrismaPromise<
    Array<
      PickArray<ReltipodispositivoperfildispositivoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReltipodispositivoperfildispositivoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReltipodispositivoperfildispositivoGroupByOutputType[P]>
            : GetScalarType<T[P], ReltipodispositivoperfildispositivoGroupByOutputType[P]>
        }
      >
    >


  export type reltipodispositivoperfildispositivoSelect = {
    IDRelTipoDispPerfil?: boolean
    IDTipoDispositivo?: boolean
    IDPerfilDispositivo?: boolean
  }


  export type reltipodispositivoperfildispositivoGetPayload<S extends boolean | null | undefined | reltipodispositivoperfildispositivoArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? reltipodispositivoperfildispositivo :
    S extends undefined ? never :
    S extends { include: any } & (reltipodispositivoperfildispositivoArgs | reltipodispositivoperfildispositivoFindManyArgs)
    ? reltipodispositivoperfildispositivo 
    : S extends { select: any } & (reltipodispositivoperfildispositivoArgs | reltipodispositivoperfildispositivoFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof reltipodispositivoperfildispositivo ? reltipodispositivoperfildispositivo[P] : never
  } 
      : reltipodispositivoperfildispositivo


  type reltipodispositivoperfildispositivoCountArgs = Merge<
    Omit<reltipodispositivoperfildispositivoFindManyArgs, 'select' | 'include'> & {
      select?: ReltipodispositivoperfildispositivoCountAggregateInputType | true
    }
  >

  export interface reltipodispositivoperfildispositivoDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Reltipodispositivoperfildispositivo that matches the filter.
     * @param {reltipodispositivoperfildispositivoFindUniqueArgs} args - Arguments to find a Reltipodispositivoperfildispositivo
     * @example
     * // Get one Reltipodispositivoperfildispositivo
     * const reltipodispositivoperfildispositivo = await prisma.reltipodispositivoperfildispositivo.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends reltipodispositivoperfildispositivoFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, reltipodispositivoperfildispositivoFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'reltipodispositivoperfildispositivo'> extends True ? Prisma__reltipodispositivoperfildispositivoClient<reltipodispositivoperfildispositivoGetPayload<T>> : Prisma__reltipodispositivoperfildispositivoClient<reltipodispositivoperfildispositivoGetPayload<T> | null, null>

    /**
     * Find one Reltipodispositivoperfildispositivo that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {reltipodispositivoperfildispositivoFindUniqueOrThrowArgs} args - Arguments to find a Reltipodispositivoperfildispositivo
     * @example
     * // Get one Reltipodispositivoperfildispositivo
     * const reltipodispositivoperfildispositivo = await prisma.reltipodispositivoperfildispositivo.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends reltipodispositivoperfildispositivoFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, reltipodispositivoperfildispositivoFindUniqueOrThrowArgs>
    ): Prisma__reltipodispositivoperfildispositivoClient<reltipodispositivoperfildispositivoGetPayload<T>>

    /**
     * Find the first Reltipodispositivoperfildispositivo that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reltipodispositivoperfildispositivoFindFirstArgs} args - Arguments to find a Reltipodispositivoperfildispositivo
     * @example
     * // Get one Reltipodispositivoperfildispositivo
     * const reltipodispositivoperfildispositivo = await prisma.reltipodispositivoperfildispositivo.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends reltipodispositivoperfildispositivoFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, reltipodispositivoperfildispositivoFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'reltipodispositivoperfildispositivo'> extends True ? Prisma__reltipodispositivoperfildispositivoClient<reltipodispositivoperfildispositivoGetPayload<T>> : Prisma__reltipodispositivoperfildispositivoClient<reltipodispositivoperfildispositivoGetPayload<T> | null, null>

    /**
     * Find the first Reltipodispositivoperfildispositivo that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reltipodispositivoperfildispositivoFindFirstOrThrowArgs} args - Arguments to find a Reltipodispositivoperfildispositivo
     * @example
     * // Get one Reltipodispositivoperfildispositivo
     * const reltipodispositivoperfildispositivo = await prisma.reltipodispositivoperfildispositivo.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends reltipodispositivoperfildispositivoFindFirstOrThrowArgs>(
      args?: SelectSubset<T, reltipodispositivoperfildispositivoFindFirstOrThrowArgs>
    ): Prisma__reltipodispositivoperfildispositivoClient<reltipodispositivoperfildispositivoGetPayload<T>>

    /**
     * Find zero or more Reltipodispositivoperfildispositivos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reltipodispositivoperfildispositivoFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Reltipodispositivoperfildispositivos
     * const reltipodispositivoperfildispositivos = await prisma.reltipodispositivoperfildispositivo.findMany()
     * 
     * // Get first 10 Reltipodispositivoperfildispositivos
     * const reltipodispositivoperfildispositivos = await prisma.reltipodispositivoperfildispositivo.findMany({ take: 10 })
     * 
     * // Only select the `IDRelTipoDispPerfil`
     * const reltipodispositivoperfildispositivoWithIDRelTipoDispPerfilOnly = await prisma.reltipodispositivoperfildispositivo.findMany({ select: { IDRelTipoDispPerfil: true } })
     * 
    **/
    findMany<T extends reltipodispositivoperfildispositivoFindManyArgs>(
      args?: SelectSubset<T, reltipodispositivoperfildispositivoFindManyArgs>
    ): PrismaPromise<Array<reltipodispositivoperfildispositivoGetPayload<T>>>

    /**
     * Create a Reltipodispositivoperfildispositivo.
     * @param {reltipodispositivoperfildispositivoCreateArgs} args - Arguments to create a Reltipodispositivoperfildispositivo.
     * @example
     * // Create one Reltipodispositivoperfildispositivo
     * const Reltipodispositivoperfildispositivo = await prisma.reltipodispositivoperfildispositivo.create({
     *   data: {
     *     // ... data to create a Reltipodispositivoperfildispositivo
     *   }
     * })
     * 
    **/
    create<T extends reltipodispositivoperfildispositivoCreateArgs>(
      args: SelectSubset<T, reltipodispositivoperfildispositivoCreateArgs>
    ): Prisma__reltipodispositivoperfildispositivoClient<reltipodispositivoperfildispositivoGetPayload<T>>

    /**
     * Create many Reltipodispositivoperfildispositivos.
     *     @param {reltipodispositivoperfildispositivoCreateManyArgs} args - Arguments to create many Reltipodispositivoperfildispositivos.
     *     @example
     *     // Create many Reltipodispositivoperfildispositivos
     *     const reltipodispositivoperfildispositivo = await prisma.reltipodispositivoperfildispositivo.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends reltipodispositivoperfildispositivoCreateManyArgs>(
      args?: SelectSubset<T, reltipodispositivoperfildispositivoCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Reltipodispositivoperfildispositivo.
     * @param {reltipodispositivoperfildispositivoDeleteArgs} args - Arguments to delete one Reltipodispositivoperfildispositivo.
     * @example
     * // Delete one Reltipodispositivoperfildispositivo
     * const Reltipodispositivoperfildispositivo = await prisma.reltipodispositivoperfildispositivo.delete({
     *   where: {
     *     // ... filter to delete one Reltipodispositivoperfildispositivo
     *   }
     * })
     * 
    **/
    delete<T extends reltipodispositivoperfildispositivoDeleteArgs>(
      args: SelectSubset<T, reltipodispositivoperfildispositivoDeleteArgs>
    ): Prisma__reltipodispositivoperfildispositivoClient<reltipodispositivoperfildispositivoGetPayload<T>>

    /**
     * Update one Reltipodispositivoperfildispositivo.
     * @param {reltipodispositivoperfildispositivoUpdateArgs} args - Arguments to update one Reltipodispositivoperfildispositivo.
     * @example
     * // Update one Reltipodispositivoperfildispositivo
     * const reltipodispositivoperfildispositivo = await prisma.reltipodispositivoperfildispositivo.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends reltipodispositivoperfildispositivoUpdateArgs>(
      args: SelectSubset<T, reltipodispositivoperfildispositivoUpdateArgs>
    ): Prisma__reltipodispositivoperfildispositivoClient<reltipodispositivoperfildispositivoGetPayload<T>>

    /**
     * Delete zero or more Reltipodispositivoperfildispositivos.
     * @param {reltipodispositivoperfildispositivoDeleteManyArgs} args - Arguments to filter Reltipodispositivoperfildispositivos to delete.
     * @example
     * // Delete a few Reltipodispositivoperfildispositivos
     * const { count } = await prisma.reltipodispositivoperfildispositivo.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends reltipodispositivoperfildispositivoDeleteManyArgs>(
      args?: SelectSubset<T, reltipodispositivoperfildispositivoDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Reltipodispositivoperfildispositivos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reltipodispositivoperfildispositivoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Reltipodispositivoperfildispositivos
     * const reltipodispositivoperfildispositivo = await prisma.reltipodispositivoperfildispositivo.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends reltipodispositivoperfildispositivoUpdateManyArgs>(
      args: SelectSubset<T, reltipodispositivoperfildispositivoUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Reltipodispositivoperfildispositivo.
     * @param {reltipodispositivoperfildispositivoUpsertArgs} args - Arguments to update or create a Reltipodispositivoperfildispositivo.
     * @example
     * // Update or create a Reltipodispositivoperfildispositivo
     * const reltipodispositivoperfildispositivo = await prisma.reltipodispositivoperfildispositivo.upsert({
     *   create: {
     *     // ... data to create a Reltipodispositivoperfildispositivo
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Reltipodispositivoperfildispositivo we want to update
     *   }
     * })
    **/
    upsert<T extends reltipodispositivoperfildispositivoUpsertArgs>(
      args: SelectSubset<T, reltipodispositivoperfildispositivoUpsertArgs>
    ): Prisma__reltipodispositivoperfildispositivoClient<reltipodispositivoperfildispositivoGetPayload<T>>

    /**
     * Count the number of Reltipodispositivoperfildispositivos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reltipodispositivoperfildispositivoCountArgs} args - Arguments to filter Reltipodispositivoperfildispositivos to count.
     * @example
     * // Count the number of Reltipodispositivoperfildispositivos
     * const count = await prisma.reltipodispositivoperfildispositivo.count({
     *   where: {
     *     // ... the filter for the Reltipodispositivoperfildispositivos we want to count
     *   }
     * })
    **/
    count<T extends reltipodispositivoperfildispositivoCountArgs>(
      args?: Subset<T, reltipodispositivoperfildispositivoCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReltipodispositivoperfildispositivoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Reltipodispositivoperfildispositivo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReltipodispositivoperfildispositivoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReltipodispositivoperfildispositivoAggregateArgs>(args: Subset<T, ReltipodispositivoperfildispositivoAggregateArgs>): PrismaPromise<GetReltipodispositivoperfildispositivoAggregateType<T>>

    /**
     * Group by Reltipodispositivoperfildispositivo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReltipodispositivoperfildispositivoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReltipodispositivoperfildispositivoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReltipodispositivoperfildispositivoGroupByArgs['orderBy'] }
        : { orderBy?: ReltipodispositivoperfildispositivoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReltipodispositivoperfildispositivoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReltipodispositivoperfildispositivoGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for reltipodispositivoperfildispositivo.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__reltipodispositivoperfildispositivoClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * reltipodispositivoperfildispositivo base type for findUnique actions
   */
  export type reltipodispositivoperfildispositivoFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the reltipodispositivoperfildispositivo
     * 
    **/
    select?: reltipodispositivoperfildispositivoSelect | null
    /**
     * Filter, which reltipodispositivoperfildispositivo to fetch.
     * 
    **/
    where: reltipodispositivoperfildispositivoWhereUniqueInput
  }

  /**
   * reltipodispositivoperfildispositivo: findUnique
   */
  export interface reltipodispositivoperfildispositivoFindUniqueArgs extends reltipodispositivoperfildispositivoFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * reltipodispositivoperfildispositivo findUniqueOrThrow
   */
  export type reltipodispositivoperfildispositivoFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the reltipodispositivoperfildispositivo
     * 
    **/
    select?: reltipodispositivoperfildispositivoSelect | null
    /**
     * Filter, which reltipodispositivoperfildispositivo to fetch.
     * 
    **/
    where: reltipodispositivoperfildispositivoWhereUniqueInput
  }


  /**
   * reltipodispositivoperfildispositivo base type for findFirst actions
   */
  export type reltipodispositivoperfildispositivoFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the reltipodispositivoperfildispositivo
     * 
    **/
    select?: reltipodispositivoperfildispositivoSelect | null
    /**
     * Filter, which reltipodispositivoperfildispositivo to fetch.
     * 
    **/
    where?: reltipodispositivoperfildispositivoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of reltipodispositivoperfildispositivos to fetch.
     * 
    **/
    orderBy?: Enumerable<reltipodispositivoperfildispositivoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for reltipodispositivoperfildispositivos.
     * 
    **/
    cursor?: reltipodispositivoperfildispositivoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` reltipodispositivoperfildispositivos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` reltipodispositivoperfildispositivos.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of reltipodispositivoperfildispositivos.
     * 
    **/
    distinct?: Enumerable<ReltipodispositivoperfildispositivoScalarFieldEnum>
  }

  /**
   * reltipodispositivoperfildispositivo: findFirst
   */
  export interface reltipodispositivoperfildispositivoFindFirstArgs extends reltipodispositivoperfildispositivoFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * reltipodispositivoperfildispositivo findFirstOrThrow
   */
  export type reltipodispositivoperfildispositivoFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the reltipodispositivoperfildispositivo
     * 
    **/
    select?: reltipodispositivoperfildispositivoSelect | null
    /**
     * Filter, which reltipodispositivoperfildispositivo to fetch.
     * 
    **/
    where?: reltipodispositivoperfildispositivoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of reltipodispositivoperfildispositivos to fetch.
     * 
    **/
    orderBy?: Enumerable<reltipodispositivoperfildispositivoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for reltipodispositivoperfildispositivos.
     * 
    **/
    cursor?: reltipodispositivoperfildispositivoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` reltipodispositivoperfildispositivos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` reltipodispositivoperfildispositivos.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of reltipodispositivoperfildispositivos.
     * 
    **/
    distinct?: Enumerable<ReltipodispositivoperfildispositivoScalarFieldEnum>
  }


  /**
   * reltipodispositivoperfildispositivo findMany
   */
  export type reltipodispositivoperfildispositivoFindManyArgs = {
    /**
     * Select specific fields to fetch from the reltipodispositivoperfildispositivo
     * 
    **/
    select?: reltipodispositivoperfildispositivoSelect | null
    /**
     * Filter, which reltipodispositivoperfildispositivos to fetch.
     * 
    **/
    where?: reltipodispositivoperfildispositivoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of reltipodispositivoperfildispositivos to fetch.
     * 
    **/
    orderBy?: Enumerable<reltipodispositivoperfildispositivoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing reltipodispositivoperfildispositivos.
     * 
    **/
    cursor?: reltipodispositivoperfildispositivoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` reltipodispositivoperfildispositivos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` reltipodispositivoperfildispositivos.
     * 
    **/
    skip?: number
    distinct?: Enumerable<ReltipodispositivoperfildispositivoScalarFieldEnum>
  }


  /**
   * reltipodispositivoperfildispositivo create
   */
  export type reltipodispositivoperfildispositivoCreateArgs = {
    /**
     * Select specific fields to fetch from the reltipodispositivoperfildispositivo
     * 
    **/
    select?: reltipodispositivoperfildispositivoSelect | null
    /**
     * The data needed to create a reltipodispositivoperfildispositivo.
     * 
    **/
    data: XOR<reltipodispositivoperfildispositivoCreateInput, reltipodispositivoperfildispositivoUncheckedCreateInput>
  }


  /**
   * reltipodispositivoperfildispositivo createMany
   */
  export type reltipodispositivoperfildispositivoCreateManyArgs = {
    /**
     * The data used to create many reltipodispositivoperfildispositivos.
     * 
    **/
    data: Enumerable<reltipodispositivoperfildispositivoCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * reltipodispositivoperfildispositivo update
   */
  export type reltipodispositivoperfildispositivoUpdateArgs = {
    /**
     * Select specific fields to fetch from the reltipodispositivoperfildispositivo
     * 
    **/
    select?: reltipodispositivoperfildispositivoSelect | null
    /**
     * The data needed to update a reltipodispositivoperfildispositivo.
     * 
    **/
    data: XOR<reltipodispositivoperfildispositivoUpdateInput, reltipodispositivoperfildispositivoUncheckedUpdateInput>
    /**
     * Choose, which reltipodispositivoperfildispositivo to update.
     * 
    **/
    where: reltipodispositivoperfildispositivoWhereUniqueInput
  }


  /**
   * reltipodispositivoperfildispositivo updateMany
   */
  export type reltipodispositivoperfildispositivoUpdateManyArgs = {
    /**
     * The data used to update reltipodispositivoperfildispositivos.
     * 
    **/
    data: XOR<reltipodispositivoperfildispositivoUpdateManyMutationInput, reltipodispositivoperfildispositivoUncheckedUpdateManyInput>
    /**
     * Filter which reltipodispositivoperfildispositivos to update
     * 
    **/
    where?: reltipodispositivoperfildispositivoWhereInput
  }


  /**
   * reltipodispositivoperfildispositivo upsert
   */
  export type reltipodispositivoperfildispositivoUpsertArgs = {
    /**
     * Select specific fields to fetch from the reltipodispositivoperfildispositivo
     * 
    **/
    select?: reltipodispositivoperfildispositivoSelect | null
    /**
     * The filter to search for the reltipodispositivoperfildispositivo to update in case it exists.
     * 
    **/
    where: reltipodispositivoperfildispositivoWhereUniqueInput
    /**
     * In case the reltipodispositivoperfildispositivo found by the `where` argument doesn't exist, create a new reltipodispositivoperfildispositivo with this data.
     * 
    **/
    create: XOR<reltipodispositivoperfildispositivoCreateInput, reltipodispositivoperfildispositivoUncheckedCreateInput>
    /**
     * In case the reltipodispositivoperfildispositivo was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<reltipodispositivoperfildispositivoUpdateInput, reltipodispositivoperfildispositivoUncheckedUpdateInput>
  }


  /**
   * reltipodispositivoperfildispositivo delete
   */
  export type reltipodispositivoperfildispositivoDeleteArgs = {
    /**
     * Select specific fields to fetch from the reltipodispositivoperfildispositivo
     * 
    **/
    select?: reltipodispositivoperfildispositivoSelect | null
    /**
     * Filter which reltipodispositivoperfildispositivo to delete.
     * 
    **/
    where: reltipodispositivoperfildispositivoWhereUniqueInput
  }


  /**
   * reltipodispositivoperfildispositivo deleteMany
   */
  export type reltipodispositivoperfildispositivoDeleteManyArgs = {
    /**
     * Filter which reltipodispositivoperfildispositivos to delete
     * 
    **/
    where?: reltipodispositivoperfildispositivoWhereInput
  }


  /**
   * reltipodispositivoperfildispositivo without action
   */
  export type reltipodispositivoperfildispositivoArgs = {
    /**
     * Select specific fields to fetch from the reltipodispositivoperfildispositivo
     * 
    **/
    select?: reltipodispositivoperfildispositivoSelect | null
  }



  /**
   * Model reltipodispositivoperfilevento
   */


  export type AggregateReltipodispositivoperfilevento = {
    _count: ReltipodispositivoperfileventoCountAggregateOutputType | null
    _avg: ReltipodispositivoperfileventoAvgAggregateOutputType | null
    _sum: ReltipodispositivoperfileventoSumAggregateOutputType | null
    _min: ReltipodispositivoperfileventoMinAggregateOutputType | null
    _max: ReltipodispositivoperfileventoMaxAggregateOutputType | null
  }

  export type ReltipodispositivoperfileventoAvgAggregateOutputType = {
    IDRelTipoDisPerfilEvento: number | null
    IDTipoDispositivo: number | null
    IDPerfilEvento: number | null
  }

  export type ReltipodispositivoperfileventoSumAggregateOutputType = {
    IDRelTipoDisPerfilEvento: number | null
    IDTipoDispositivo: number | null
    IDPerfilEvento: number | null
  }

  export type ReltipodispositivoperfileventoMinAggregateOutputType = {
    IDRelTipoDisPerfilEvento: number | null
    IDTipoDispositivo: number | null
    IDPerfilEvento: number | null
  }

  export type ReltipodispositivoperfileventoMaxAggregateOutputType = {
    IDRelTipoDisPerfilEvento: number | null
    IDTipoDispositivo: number | null
    IDPerfilEvento: number | null
  }

  export type ReltipodispositivoperfileventoCountAggregateOutputType = {
    IDRelTipoDisPerfilEvento: number
    IDTipoDispositivo: number
    IDPerfilEvento: number
    _all: number
  }


  export type ReltipodispositivoperfileventoAvgAggregateInputType = {
    IDRelTipoDisPerfilEvento?: true
    IDTipoDispositivo?: true
    IDPerfilEvento?: true
  }

  export type ReltipodispositivoperfileventoSumAggregateInputType = {
    IDRelTipoDisPerfilEvento?: true
    IDTipoDispositivo?: true
    IDPerfilEvento?: true
  }

  export type ReltipodispositivoperfileventoMinAggregateInputType = {
    IDRelTipoDisPerfilEvento?: true
    IDTipoDispositivo?: true
    IDPerfilEvento?: true
  }

  export type ReltipodispositivoperfileventoMaxAggregateInputType = {
    IDRelTipoDisPerfilEvento?: true
    IDTipoDispositivo?: true
    IDPerfilEvento?: true
  }

  export type ReltipodispositivoperfileventoCountAggregateInputType = {
    IDRelTipoDisPerfilEvento?: true
    IDTipoDispositivo?: true
    IDPerfilEvento?: true
    _all?: true
  }

  export type ReltipodispositivoperfileventoAggregateArgs = {
    /**
     * Filter which reltipodispositivoperfilevento to aggregate.
     * 
    **/
    where?: reltipodispositivoperfileventoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of reltipodispositivoperfileventos to fetch.
     * 
    **/
    orderBy?: Enumerable<reltipodispositivoperfileventoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: reltipodispositivoperfileventoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` reltipodispositivoperfileventos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` reltipodispositivoperfileventos.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned reltipodispositivoperfileventos
    **/
    _count?: true | ReltipodispositivoperfileventoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ReltipodispositivoperfileventoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ReltipodispositivoperfileventoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReltipodispositivoperfileventoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReltipodispositivoperfileventoMaxAggregateInputType
  }

  export type GetReltipodispositivoperfileventoAggregateType<T extends ReltipodispositivoperfileventoAggregateArgs> = {
        [P in keyof T & keyof AggregateReltipodispositivoperfilevento]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReltipodispositivoperfilevento[P]>
      : GetScalarType<T[P], AggregateReltipodispositivoperfilevento[P]>
  }




  export type ReltipodispositivoperfileventoGroupByArgs = {
    where?: reltipodispositivoperfileventoWhereInput
    orderBy?: Enumerable<reltipodispositivoperfileventoOrderByWithAggregationInput>
    by: Array<ReltipodispositivoperfileventoScalarFieldEnum>
    having?: reltipodispositivoperfileventoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReltipodispositivoperfileventoCountAggregateInputType | true
    _avg?: ReltipodispositivoperfileventoAvgAggregateInputType
    _sum?: ReltipodispositivoperfileventoSumAggregateInputType
    _min?: ReltipodispositivoperfileventoMinAggregateInputType
    _max?: ReltipodispositivoperfileventoMaxAggregateInputType
  }


  export type ReltipodispositivoperfileventoGroupByOutputType = {
    IDRelTipoDisPerfilEvento: number
    IDTipoDispositivo: number
    IDPerfilEvento: number
    _count: ReltipodispositivoperfileventoCountAggregateOutputType | null
    _avg: ReltipodispositivoperfileventoAvgAggregateOutputType | null
    _sum: ReltipodispositivoperfileventoSumAggregateOutputType | null
    _min: ReltipodispositivoperfileventoMinAggregateOutputType | null
    _max: ReltipodispositivoperfileventoMaxAggregateOutputType | null
  }

  type GetReltipodispositivoperfileventoGroupByPayload<T extends ReltipodispositivoperfileventoGroupByArgs> = PrismaPromise<
    Array<
      PickArray<ReltipodispositivoperfileventoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReltipodispositivoperfileventoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReltipodispositivoperfileventoGroupByOutputType[P]>
            : GetScalarType<T[P], ReltipodispositivoperfileventoGroupByOutputType[P]>
        }
      >
    >


  export type reltipodispositivoperfileventoSelect = {
    IDRelTipoDisPerfilEvento?: boolean
    IDTipoDispositivo?: boolean
    IDPerfilEvento?: boolean
  }


  export type reltipodispositivoperfileventoGetPayload<S extends boolean | null | undefined | reltipodispositivoperfileventoArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? reltipodispositivoperfilevento :
    S extends undefined ? never :
    S extends { include: any } & (reltipodispositivoperfileventoArgs | reltipodispositivoperfileventoFindManyArgs)
    ? reltipodispositivoperfilevento 
    : S extends { select: any } & (reltipodispositivoperfileventoArgs | reltipodispositivoperfileventoFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof reltipodispositivoperfilevento ? reltipodispositivoperfilevento[P] : never
  } 
      : reltipodispositivoperfilevento


  type reltipodispositivoperfileventoCountArgs = Merge<
    Omit<reltipodispositivoperfileventoFindManyArgs, 'select' | 'include'> & {
      select?: ReltipodispositivoperfileventoCountAggregateInputType | true
    }
  >

  export interface reltipodispositivoperfileventoDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Reltipodispositivoperfilevento that matches the filter.
     * @param {reltipodispositivoperfileventoFindUniqueArgs} args - Arguments to find a Reltipodispositivoperfilevento
     * @example
     * // Get one Reltipodispositivoperfilevento
     * const reltipodispositivoperfilevento = await prisma.reltipodispositivoperfilevento.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends reltipodispositivoperfileventoFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, reltipodispositivoperfileventoFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'reltipodispositivoperfilevento'> extends True ? Prisma__reltipodispositivoperfileventoClient<reltipodispositivoperfileventoGetPayload<T>> : Prisma__reltipodispositivoperfileventoClient<reltipodispositivoperfileventoGetPayload<T> | null, null>

    /**
     * Find one Reltipodispositivoperfilevento that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {reltipodispositivoperfileventoFindUniqueOrThrowArgs} args - Arguments to find a Reltipodispositivoperfilevento
     * @example
     * // Get one Reltipodispositivoperfilevento
     * const reltipodispositivoperfilevento = await prisma.reltipodispositivoperfilevento.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends reltipodispositivoperfileventoFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, reltipodispositivoperfileventoFindUniqueOrThrowArgs>
    ): Prisma__reltipodispositivoperfileventoClient<reltipodispositivoperfileventoGetPayload<T>>

    /**
     * Find the first Reltipodispositivoperfilevento that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reltipodispositivoperfileventoFindFirstArgs} args - Arguments to find a Reltipodispositivoperfilevento
     * @example
     * // Get one Reltipodispositivoperfilevento
     * const reltipodispositivoperfilevento = await prisma.reltipodispositivoperfilevento.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends reltipodispositivoperfileventoFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, reltipodispositivoperfileventoFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'reltipodispositivoperfilevento'> extends True ? Prisma__reltipodispositivoperfileventoClient<reltipodispositivoperfileventoGetPayload<T>> : Prisma__reltipodispositivoperfileventoClient<reltipodispositivoperfileventoGetPayload<T> | null, null>

    /**
     * Find the first Reltipodispositivoperfilevento that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reltipodispositivoperfileventoFindFirstOrThrowArgs} args - Arguments to find a Reltipodispositivoperfilevento
     * @example
     * // Get one Reltipodispositivoperfilevento
     * const reltipodispositivoperfilevento = await prisma.reltipodispositivoperfilevento.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends reltipodispositivoperfileventoFindFirstOrThrowArgs>(
      args?: SelectSubset<T, reltipodispositivoperfileventoFindFirstOrThrowArgs>
    ): Prisma__reltipodispositivoperfileventoClient<reltipodispositivoperfileventoGetPayload<T>>

    /**
     * Find zero or more Reltipodispositivoperfileventos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reltipodispositivoperfileventoFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Reltipodispositivoperfileventos
     * const reltipodispositivoperfileventos = await prisma.reltipodispositivoperfilevento.findMany()
     * 
     * // Get first 10 Reltipodispositivoperfileventos
     * const reltipodispositivoperfileventos = await prisma.reltipodispositivoperfilevento.findMany({ take: 10 })
     * 
     * // Only select the `IDRelTipoDisPerfilEvento`
     * const reltipodispositivoperfileventoWithIDRelTipoDisPerfilEventoOnly = await prisma.reltipodispositivoperfilevento.findMany({ select: { IDRelTipoDisPerfilEvento: true } })
     * 
    **/
    findMany<T extends reltipodispositivoperfileventoFindManyArgs>(
      args?: SelectSubset<T, reltipodispositivoperfileventoFindManyArgs>
    ): PrismaPromise<Array<reltipodispositivoperfileventoGetPayload<T>>>

    /**
     * Create a Reltipodispositivoperfilevento.
     * @param {reltipodispositivoperfileventoCreateArgs} args - Arguments to create a Reltipodispositivoperfilevento.
     * @example
     * // Create one Reltipodispositivoperfilevento
     * const Reltipodispositivoperfilevento = await prisma.reltipodispositivoperfilevento.create({
     *   data: {
     *     // ... data to create a Reltipodispositivoperfilevento
     *   }
     * })
     * 
    **/
    create<T extends reltipodispositivoperfileventoCreateArgs>(
      args: SelectSubset<T, reltipodispositivoperfileventoCreateArgs>
    ): Prisma__reltipodispositivoperfileventoClient<reltipodispositivoperfileventoGetPayload<T>>

    /**
     * Create many Reltipodispositivoperfileventos.
     *     @param {reltipodispositivoperfileventoCreateManyArgs} args - Arguments to create many Reltipodispositivoperfileventos.
     *     @example
     *     // Create many Reltipodispositivoperfileventos
     *     const reltipodispositivoperfilevento = await prisma.reltipodispositivoperfilevento.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends reltipodispositivoperfileventoCreateManyArgs>(
      args?: SelectSubset<T, reltipodispositivoperfileventoCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Reltipodispositivoperfilevento.
     * @param {reltipodispositivoperfileventoDeleteArgs} args - Arguments to delete one Reltipodispositivoperfilevento.
     * @example
     * // Delete one Reltipodispositivoperfilevento
     * const Reltipodispositivoperfilevento = await prisma.reltipodispositivoperfilevento.delete({
     *   where: {
     *     // ... filter to delete one Reltipodispositivoperfilevento
     *   }
     * })
     * 
    **/
    delete<T extends reltipodispositivoperfileventoDeleteArgs>(
      args: SelectSubset<T, reltipodispositivoperfileventoDeleteArgs>
    ): Prisma__reltipodispositivoperfileventoClient<reltipodispositivoperfileventoGetPayload<T>>

    /**
     * Update one Reltipodispositivoperfilevento.
     * @param {reltipodispositivoperfileventoUpdateArgs} args - Arguments to update one Reltipodispositivoperfilevento.
     * @example
     * // Update one Reltipodispositivoperfilevento
     * const reltipodispositivoperfilevento = await prisma.reltipodispositivoperfilevento.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends reltipodispositivoperfileventoUpdateArgs>(
      args: SelectSubset<T, reltipodispositivoperfileventoUpdateArgs>
    ): Prisma__reltipodispositivoperfileventoClient<reltipodispositivoperfileventoGetPayload<T>>

    /**
     * Delete zero or more Reltipodispositivoperfileventos.
     * @param {reltipodispositivoperfileventoDeleteManyArgs} args - Arguments to filter Reltipodispositivoperfileventos to delete.
     * @example
     * // Delete a few Reltipodispositivoperfileventos
     * const { count } = await prisma.reltipodispositivoperfilevento.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends reltipodispositivoperfileventoDeleteManyArgs>(
      args?: SelectSubset<T, reltipodispositivoperfileventoDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Reltipodispositivoperfileventos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reltipodispositivoperfileventoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Reltipodispositivoperfileventos
     * const reltipodispositivoperfilevento = await prisma.reltipodispositivoperfilevento.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends reltipodispositivoperfileventoUpdateManyArgs>(
      args: SelectSubset<T, reltipodispositivoperfileventoUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Reltipodispositivoperfilevento.
     * @param {reltipodispositivoperfileventoUpsertArgs} args - Arguments to update or create a Reltipodispositivoperfilevento.
     * @example
     * // Update or create a Reltipodispositivoperfilevento
     * const reltipodispositivoperfilevento = await prisma.reltipodispositivoperfilevento.upsert({
     *   create: {
     *     // ... data to create a Reltipodispositivoperfilevento
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Reltipodispositivoperfilevento we want to update
     *   }
     * })
    **/
    upsert<T extends reltipodispositivoperfileventoUpsertArgs>(
      args: SelectSubset<T, reltipodispositivoperfileventoUpsertArgs>
    ): Prisma__reltipodispositivoperfileventoClient<reltipodispositivoperfileventoGetPayload<T>>

    /**
     * Count the number of Reltipodispositivoperfileventos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reltipodispositivoperfileventoCountArgs} args - Arguments to filter Reltipodispositivoperfileventos to count.
     * @example
     * // Count the number of Reltipodispositivoperfileventos
     * const count = await prisma.reltipodispositivoperfilevento.count({
     *   where: {
     *     // ... the filter for the Reltipodispositivoperfileventos we want to count
     *   }
     * })
    **/
    count<T extends reltipodispositivoperfileventoCountArgs>(
      args?: Subset<T, reltipodispositivoperfileventoCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReltipodispositivoperfileventoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Reltipodispositivoperfilevento.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReltipodispositivoperfileventoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReltipodispositivoperfileventoAggregateArgs>(args: Subset<T, ReltipodispositivoperfileventoAggregateArgs>): PrismaPromise<GetReltipodispositivoperfileventoAggregateType<T>>

    /**
     * Group by Reltipodispositivoperfilevento.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReltipodispositivoperfileventoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReltipodispositivoperfileventoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReltipodispositivoperfileventoGroupByArgs['orderBy'] }
        : { orderBy?: ReltipodispositivoperfileventoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReltipodispositivoperfileventoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReltipodispositivoperfileventoGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for reltipodispositivoperfilevento.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__reltipodispositivoperfileventoClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * reltipodispositivoperfilevento base type for findUnique actions
   */
  export type reltipodispositivoperfileventoFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the reltipodispositivoperfilevento
     * 
    **/
    select?: reltipodispositivoperfileventoSelect | null
    /**
     * Filter, which reltipodispositivoperfilevento to fetch.
     * 
    **/
    where: reltipodispositivoperfileventoWhereUniqueInput
  }

  /**
   * reltipodispositivoperfilevento: findUnique
   */
  export interface reltipodispositivoperfileventoFindUniqueArgs extends reltipodispositivoperfileventoFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * reltipodispositivoperfilevento findUniqueOrThrow
   */
  export type reltipodispositivoperfileventoFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the reltipodispositivoperfilevento
     * 
    **/
    select?: reltipodispositivoperfileventoSelect | null
    /**
     * Filter, which reltipodispositivoperfilevento to fetch.
     * 
    **/
    where: reltipodispositivoperfileventoWhereUniqueInput
  }


  /**
   * reltipodispositivoperfilevento base type for findFirst actions
   */
  export type reltipodispositivoperfileventoFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the reltipodispositivoperfilevento
     * 
    **/
    select?: reltipodispositivoperfileventoSelect | null
    /**
     * Filter, which reltipodispositivoperfilevento to fetch.
     * 
    **/
    where?: reltipodispositivoperfileventoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of reltipodispositivoperfileventos to fetch.
     * 
    **/
    orderBy?: Enumerable<reltipodispositivoperfileventoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for reltipodispositivoperfileventos.
     * 
    **/
    cursor?: reltipodispositivoperfileventoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` reltipodispositivoperfileventos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` reltipodispositivoperfileventos.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of reltipodispositivoperfileventos.
     * 
    **/
    distinct?: Enumerable<ReltipodispositivoperfileventoScalarFieldEnum>
  }

  /**
   * reltipodispositivoperfilevento: findFirst
   */
  export interface reltipodispositivoperfileventoFindFirstArgs extends reltipodispositivoperfileventoFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * reltipodispositivoperfilevento findFirstOrThrow
   */
  export type reltipodispositivoperfileventoFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the reltipodispositivoperfilevento
     * 
    **/
    select?: reltipodispositivoperfileventoSelect | null
    /**
     * Filter, which reltipodispositivoperfilevento to fetch.
     * 
    **/
    where?: reltipodispositivoperfileventoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of reltipodispositivoperfileventos to fetch.
     * 
    **/
    orderBy?: Enumerable<reltipodispositivoperfileventoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for reltipodispositivoperfileventos.
     * 
    **/
    cursor?: reltipodispositivoperfileventoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` reltipodispositivoperfileventos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` reltipodispositivoperfileventos.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of reltipodispositivoperfileventos.
     * 
    **/
    distinct?: Enumerable<ReltipodispositivoperfileventoScalarFieldEnum>
  }


  /**
   * reltipodispositivoperfilevento findMany
   */
  export type reltipodispositivoperfileventoFindManyArgs = {
    /**
     * Select specific fields to fetch from the reltipodispositivoperfilevento
     * 
    **/
    select?: reltipodispositivoperfileventoSelect | null
    /**
     * Filter, which reltipodispositivoperfileventos to fetch.
     * 
    **/
    where?: reltipodispositivoperfileventoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of reltipodispositivoperfileventos to fetch.
     * 
    **/
    orderBy?: Enumerable<reltipodispositivoperfileventoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing reltipodispositivoperfileventos.
     * 
    **/
    cursor?: reltipodispositivoperfileventoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` reltipodispositivoperfileventos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` reltipodispositivoperfileventos.
     * 
    **/
    skip?: number
    distinct?: Enumerable<ReltipodispositivoperfileventoScalarFieldEnum>
  }


  /**
   * reltipodispositivoperfilevento create
   */
  export type reltipodispositivoperfileventoCreateArgs = {
    /**
     * Select specific fields to fetch from the reltipodispositivoperfilevento
     * 
    **/
    select?: reltipodispositivoperfileventoSelect | null
    /**
     * The data needed to create a reltipodispositivoperfilevento.
     * 
    **/
    data: XOR<reltipodispositivoperfileventoCreateInput, reltipodispositivoperfileventoUncheckedCreateInput>
  }


  /**
   * reltipodispositivoperfilevento createMany
   */
  export type reltipodispositivoperfileventoCreateManyArgs = {
    /**
     * The data used to create many reltipodispositivoperfileventos.
     * 
    **/
    data: Enumerable<reltipodispositivoperfileventoCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * reltipodispositivoperfilevento update
   */
  export type reltipodispositivoperfileventoUpdateArgs = {
    /**
     * Select specific fields to fetch from the reltipodispositivoperfilevento
     * 
    **/
    select?: reltipodispositivoperfileventoSelect | null
    /**
     * The data needed to update a reltipodispositivoperfilevento.
     * 
    **/
    data: XOR<reltipodispositivoperfileventoUpdateInput, reltipodispositivoperfileventoUncheckedUpdateInput>
    /**
     * Choose, which reltipodispositivoperfilevento to update.
     * 
    **/
    where: reltipodispositivoperfileventoWhereUniqueInput
  }


  /**
   * reltipodispositivoperfilevento updateMany
   */
  export type reltipodispositivoperfileventoUpdateManyArgs = {
    /**
     * The data used to update reltipodispositivoperfileventos.
     * 
    **/
    data: XOR<reltipodispositivoperfileventoUpdateManyMutationInput, reltipodispositivoperfileventoUncheckedUpdateManyInput>
    /**
     * Filter which reltipodispositivoperfileventos to update
     * 
    **/
    where?: reltipodispositivoperfileventoWhereInput
  }


  /**
   * reltipodispositivoperfilevento upsert
   */
  export type reltipodispositivoperfileventoUpsertArgs = {
    /**
     * Select specific fields to fetch from the reltipodispositivoperfilevento
     * 
    **/
    select?: reltipodispositivoperfileventoSelect | null
    /**
     * The filter to search for the reltipodispositivoperfilevento to update in case it exists.
     * 
    **/
    where: reltipodispositivoperfileventoWhereUniqueInput
    /**
     * In case the reltipodispositivoperfilevento found by the `where` argument doesn't exist, create a new reltipodispositivoperfilevento with this data.
     * 
    **/
    create: XOR<reltipodispositivoperfileventoCreateInput, reltipodispositivoperfileventoUncheckedCreateInput>
    /**
     * In case the reltipodispositivoperfilevento was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<reltipodispositivoperfileventoUpdateInput, reltipodispositivoperfileventoUncheckedUpdateInput>
  }


  /**
   * reltipodispositivoperfilevento delete
   */
  export type reltipodispositivoperfileventoDeleteArgs = {
    /**
     * Select specific fields to fetch from the reltipodispositivoperfilevento
     * 
    **/
    select?: reltipodispositivoperfileventoSelect | null
    /**
     * Filter which reltipodispositivoperfilevento to delete.
     * 
    **/
    where: reltipodispositivoperfileventoWhereUniqueInput
  }


  /**
   * reltipodispositivoperfilevento deleteMany
   */
  export type reltipodispositivoperfileventoDeleteManyArgs = {
    /**
     * Filter which reltipodispositivoperfileventos to delete
     * 
    **/
    where?: reltipodispositivoperfileventoWhereInput
  }


  /**
   * reltipodispositivoperfilevento without action
   */
  export type reltipodispositivoperfileventoArgs = {
    /**
     * Select specific fields to fetch from the reltipodispositivoperfilevento
     * 
    **/
    select?: reltipodispositivoperfileventoSelect | null
  }



  /**
   * Model reltipodispositivotipotecnologia
   */


  export type AggregateReltipodispositivotipotecnologia = {
    _count: ReltipodispositivotipotecnologiaCountAggregateOutputType | null
    _avg: ReltipodispositivotipotecnologiaAvgAggregateOutputType | null
    _sum: ReltipodispositivotipotecnologiaSumAggregateOutputType | null
    _min: ReltipodispositivotipotecnologiaMinAggregateOutputType | null
    _max: ReltipodispositivotipotecnologiaMaxAggregateOutputType | null
  }

  export type ReltipodispositivotipotecnologiaAvgAggregateOutputType = {
    IDRelTipoDispTipoTec: number | null
    IDTipoDispositivo: number | null
    IDTipoTecnologia: number | null
  }

  export type ReltipodispositivotipotecnologiaSumAggregateOutputType = {
    IDRelTipoDispTipoTec: number | null
    IDTipoDispositivo: number | null
    IDTipoTecnologia: number | null
  }

  export type ReltipodispositivotipotecnologiaMinAggregateOutputType = {
    IDRelTipoDispTipoTec: number | null
    IDTipoDispositivo: number | null
    IDTipoTecnologia: number | null
  }

  export type ReltipodispositivotipotecnologiaMaxAggregateOutputType = {
    IDRelTipoDispTipoTec: number | null
    IDTipoDispositivo: number | null
    IDTipoTecnologia: number | null
  }

  export type ReltipodispositivotipotecnologiaCountAggregateOutputType = {
    IDRelTipoDispTipoTec: number
    IDTipoDispositivo: number
    IDTipoTecnologia: number
    _all: number
  }


  export type ReltipodispositivotipotecnologiaAvgAggregateInputType = {
    IDRelTipoDispTipoTec?: true
    IDTipoDispositivo?: true
    IDTipoTecnologia?: true
  }

  export type ReltipodispositivotipotecnologiaSumAggregateInputType = {
    IDRelTipoDispTipoTec?: true
    IDTipoDispositivo?: true
    IDTipoTecnologia?: true
  }

  export type ReltipodispositivotipotecnologiaMinAggregateInputType = {
    IDRelTipoDispTipoTec?: true
    IDTipoDispositivo?: true
    IDTipoTecnologia?: true
  }

  export type ReltipodispositivotipotecnologiaMaxAggregateInputType = {
    IDRelTipoDispTipoTec?: true
    IDTipoDispositivo?: true
    IDTipoTecnologia?: true
  }

  export type ReltipodispositivotipotecnologiaCountAggregateInputType = {
    IDRelTipoDispTipoTec?: true
    IDTipoDispositivo?: true
    IDTipoTecnologia?: true
    _all?: true
  }

  export type ReltipodispositivotipotecnologiaAggregateArgs = {
    /**
     * Filter which reltipodispositivotipotecnologia to aggregate.
     * 
    **/
    where?: reltipodispositivotipotecnologiaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of reltipodispositivotipotecnologias to fetch.
     * 
    **/
    orderBy?: Enumerable<reltipodispositivotipotecnologiaOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: reltipodispositivotipotecnologiaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` reltipodispositivotipotecnologias from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` reltipodispositivotipotecnologias.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned reltipodispositivotipotecnologias
    **/
    _count?: true | ReltipodispositivotipotecnologiaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ReltipodispositivotipotecnologiaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ReltipodispositivotipotecnologiaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReltipodispositivotipotecnologiaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReltipodispositivotipotecnologiaMaxAggregateInputType
  }

  export type GetReltipodispositivotipotecnologiaAggregateType<T extends ReltipodispositivotipotecnologiaAggregateArgs> = {
        [P in keyof T & keyof AggregateReltipodispositivotipotecnologia]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReltipodispositivotipotecnologia[P]>
      : GetScalarType<T[P], AggregateReltipodispositivotipotecnologia[P]>
  }




  export type ReltipodispositivotipotecnologiaGroupByArgs = {
    where?: reltipodispositivotipotecnologiaWhereInput
    orderBy?: Enumerable<reltipodispositivotipotecnologiaOrderByWithAggregationInput>
    by: Array<ReltipodispositivotipotecnologiaScalarFieldEnum>
    having?: reltipodispositivotipotecnologiaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReltipodispositivotipotecnologiaCountAggregateInputType | true
    _avg?: ReltipodispositivotipotecnologiaAvgAggregateInputType
    _sum?: ReltipodispositivotipotecnologiaSumAggregateInputType
    _min?: ReltipodispositivotipotecnologiaMinAggregateInputType
    _max?: ReltipodispositivotipotecnologiaMaxAggregateInputType
  }


  export type ReltipodispositivotipotecnologiaGroupByOutputType = {
    IDRelTipoDispTipoTec: number
    IDTipoDispositivo: number
    IDTipoTecnologia: number
    _count: ReltipodispositivotipotecnologiaCountAggregateOutputType | null
    _avg: ReltipodispositivotipotecnologiaAvgAggregateOutputType | null
    _sum: ReltipodispositivotipotecnologiaSumAggregateOutputType | null
    _min: ReltipodispositivotipotecnologiaMinAggregateOutputType | null
    _max: ReltipodispositivotipotecnologiaMaxAggregateOutputType | null
  }

  type GetReltipodispositivotipotecnologiaGroupByPayload<T extends ReltipodispositivotipotecnologiaGroupByArgs> = PrismaPromise<
    Array<
      PickArray<ReltipodispositivotipotecnologiaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReltipodispositivotipotecnologiaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReltipodispositivotipotecnologiaGroupByOutputType[P]>
            : GetScalarType<T[P], ReltipodispositivotipotecnologiaGroupByOutputType[P]>
        }
      >
    >


  export type reltipodispositivotipotecnologiaSelect = {
    IDRelTipoDispTipoTec?: boolean
    IDTipoDispositivo?: boolean
    IDTipoTecnologia?: boolean
  }


  export type reltipodispositivotipotecnologiaGetPayload<S extends boolean | null | undefined | reltipodispositivotipotecnologiaArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? reltipodispositivotipotecnologia :
    S extends undefined ? never :
    S extends { include: any } & (reltipodispositivotipotecnologiaArgs | reltipodispositivotipotecnologiaFindManyArgs)
    ? reltipodispositivotipotecnologia 
    : S extends { select: any } & (reltipodispositivotipotecnologiaArgs | reltipodispositivotipotecnologiaFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof reltipodispositivotipotecnologia ? reltipodispositivotipotecnologia[P] : never
  } 
      : reltipodispositivotipotecnologia


  type reltipodispositivotipotecnologiaCountArgs = Merge<
    Omit<reltipodispositivotipotecnologiaFindManyArgs, 'select' | 'include'> & {
      select?: ReltipodispositivotipotecnologiaCountAggregateInputType | true
    }
  >

  export interface reltipodispositivotipotecnologiaDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Reltipodispositivotipotecnologia that matches the filter.
     * @param {reltipodispositivotipotecnologiaFindUniqueArgs} args - Arguments to find a Reltipodispositivotipotecnologia
     * @example
     * // Get one Reltipodispositivotipotecnologia
     * const reltipodispositivotipotecnologia = await prisma.reltipodispositivotipotecnologia.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends reltipodispositivotipotecnologiaFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, reltipodispositivotipotecnologiaFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'reltipodispositivotipotecnologia'> extends True ? Prisma__reltipodispositivotipotecnologiaClient<reltipodispositivotipotecnologiaGetPayload<T>> : Prisma__reltipodispositivotipotecnologiaClient<reltipodispositivotipotecnologiaGetPayload<T> | null, null>

    /**
     * Find one Reltipodispositivotipotecnologia that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {reltipodispositivotipotecnologiaFindUniqueOrThrowArgs} args - Arguments to find a Reltipodispositivotipotecnologia
     * @example
     * // Get one Reltipodispositivotipotecnologia
     * const reltipodispositivotipotecnologia = await prisma.reltipodispositivotipotecnologia.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends reltipodispositivotipotecnologiaFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, reltipodispositivotipotecnologiaFindUniqueOrThrowArgs>
    ): Prisma__reltipodispositivotipotecnologiaClient<reltipodispositivotipotecnologiaGetPayload<T>>

    /**
     * Find the first Reltipodispositivotipotecnologia that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reltipodispositivotipotecnologiaFindFirstArgs} args - Arguments to find a Reltipodispositivotipotecnologia
     * @example
     * // Get one Reltipodispositivotipotecnologia
     * const reltipodispositivotipotecnologia = await prisma.reltipodispositivotipotecnologia.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends reltipodispositivotipotecnologiaFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, reltipodispositivotipotecnologiaFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'reltipodispositivotipotecnologia'> extends True ? Prisma__reltipodispositivotipotecnologiaClient<reltipodispositivotipotecnologiaGetPayload<T>> : Prisma__reltipodispositivotipotecnologiaClient<reltipodispositivotipotecnologiaGetPayload<T> | null, null>

    /**
     * Find the first Reltipodispositivotipotecnologia that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reltipodispositivotipotecnologiaFindFirstOrThrowArgs} args - Arguments to find a Reltipodispositivotipotecnologia
     * @example
     * // Get one Reltipodispositivotipotecnologia
     * const reltipodispositivotipotecnologia = await prisma.reltipodispositivotipotecnologia.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends reltipodispositivotipotecnologiaFindFirstOrThrowArgs>(
      args?: SelectSubset<T, reltipodispositivotipotecnologiaFindFirstOrThrowArgs>
    ): Prisma__reltipodispositivotipotecnologiaClient<reltipodispositivotipotecnologiaGetPayload<T>>

    /**
     * Find zero or more Reltipodispositivotipotecnologias that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reltipodispositivotipotecnologiaFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Reltipodispositivotipotecnologias
     * const reltipodispositivotipotecnologias = await prisma.reltipodispositivotipotecnologia.findMany()
     * 
     * // Get first 10 Reltipodispositivotipotecnologias
     * const reltipodispositivotipotecnologias = await prisma.reltipodispositivotipotecnologia.findMany({ take: 10 })
     * 
     * // Only select the `IDRelTipoDispTipoTec`
     * const reltipodispositivotipotecnologiaWithIDRelTipoDispTipoTecOnly = await prisma.reltipodispositivotipotecnologia.findMany({ select: { IDRelTipoDispTipoTec: true } })
     * 
    **/
    findMany<T extends reltipodispositivotipotecnologiaFindManyArgs>(
      args?: SelectSubset<T, reltipodispositivotipotecnologiaFindManyArgs>
    ): PrismaPromise<Array<reltipodispositivotipotecnologiaGetPayload<T>>>

    /**
     * Create a Reltipodispositivotipotecnologia.
     * @param {reltipodispositivotipotecnologiaCreateArgs} args - Arguments to create a Reltipodispositivotipotecnologia.
     * @example
     * // Create one Reltipodispositivotipotecnologia
     * const Reltipodispositivotipotecnologia = await prisma.reltipodispositivotipotecnologia.create({
     *   data: {
     *     // ... data to create a Reltipodispositivotipotecnologia
     *   }
     * })
     * 
    **/
    create<T extends reltipodispositivotipotecnologiaCreateArgs>(
      args: SelectSubset<T, reltipodispositivotipotecnologiaCreateArgs>
    ): Prisma__reltipodispositivotipotecnologiaClient<reltipodispositivotipotecnologiaGetPayload<T>>

    /**
     * Create many Reltipodispositivotipotecnologias.
     *     @param {reltipodispositivotipotecnologiaCreateManyArgs} args - Arguments to create many Reltipodispositivotipotecnologias.
     *     @example
     *     // Create many Reltipodispositivotipotecnologias
     *     const reltipodispositivotipotecnologia = await prisma.reltipodispositivotipotecnologia.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends reltipodispositivotipotecnologiaCreateManyArgs>(
      args?: SelectSubset<T, reltipodispositivotipotecnologiaCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Reltipodispositivotipotecnologia.
     * @param {reltipodispositivotipotecnologiaDeleteArgs} args - Arguments to delete one Reltipodispositivotipotecnologia.
     * @example
     * // Delete one Reltipodispositivotipotecnologia
     * const Reltipodispositivotipotecnologia = await prisma.reltipodispositivotipotecnologia.delete({
     *   where: {
     *     // ... filter to delete one Reltipodispositivotipotecnologia
     *   }
     * })
     * 
    **/
    delete<T extends reltipodispositivotipotecnologiaDeleteArgs>(
      args: SelectSubset<T, reltipodispositivotipotecnologiaDeleteArgs>
    ): Prisma__reltipodispositivotipotecnologiaClient<reltipodispositivotipotecnologiaGetPayload<T>>

    /**
     * Update one Reltipodispositivotipotecnologia.
     * @param {reltipodispositivotipotecnologiaUpdateArgs} args - Arguments to update one Reltipodispositivotipotecnologia.
     * @example
     * // Update one Reltipodispositivotipotecnologia
     * const reltipodispositivotipotecnologia = await prisma.reltipodispositivotipotecnologia.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends reltipodispositivotipotecnologiaUpdateArgs>(
      args: SelectSubset<T, reltipodispositivotipotecnologiaUpdateArgs>
    ): Prisma__reltipodispositivotipotecnologiaClient<reltipodispositivotipotecnologiaGetPayload<T>>

    /**
     * Delete zero or more Reltipodispositivotipotecnologias.
     * @param {reltipodispositivotipotecnologiaDeleteManyArgs} args - Arguments to filter Reltipodispositivotipotecnologias to delete.
     * @example
     * // Delete a few Reltipodispositivotipotecnologias
     * const { count } = await prisma.reltipodispositivotipotecnologia.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends reltipodispositivotipotecnologiaDeleteManyArgs>(
      args?: SelectSubset<T, reltipodispositivotipotecnologiaDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Reltipodispositivotipotecnologias.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reltipodispositivotipotecnologiaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Reltipodispositivotipotecnologias
     * const reltipodispositivotipotecnologia = await prisma.reltipodispositivotipotecnologia.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends reltipodispositivotipotecnologiaUpdateManyArgs>(
      args: SelectSubset<T, reltipodispositivotipotecnologiaUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Reltipodispositivotipotecnologia.
     * @param {reltipodispositivotipotecnologiaUpsertArgs} args - Arguments to update or create a Reltipodispositivotipotecnologia.
     * @example
     * // Update or create a Reltipodispositivotipotecnologia
     * const reltipodispositivotipotecnologia = await prisma.reltipodispositivotipotecnologia.upsert({
     *   create: {
     *     // ... data to create a Reltipodispositivotipotecnologia
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Reltipodispositivotipotecnologia we want to update
     *   }
     * })
    **/
    upsert<T extends reltipodispositivotipotecnologiaUpsertArgs>(
      args: SelectSubset<T, reltipodispositivotipotecnologiaUpsertArgs>
    ): Prisma__reltipodispositivotipotecnologiaClient<reltipodispositivotipotecnologiaGetPayload<T>>

    /**
     * Count the number of Reltipodispositivotipotecnologias.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reltipodispositivotipotecnologiaCountArgs} args - Arguments to filter Reltipodispositivotipotecnologias to count.
     * @example
     * // Count the number of Reltipodispositivotipotecnologias
     * const count = await prisma.reltipodispositivotipotecnologia.count({
     *   where: {
     *     // ... the filter for the Reltipodispositivotipotecnologias we want to count
     *   }
     * })
    **/
    count<T extends reltipodispositivotipotecnologiaCountArgs>(
      args?: Subset<T, reltipodispositivotipotecnologiaCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReltipodispositivotipotecnologiaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Reltipodispositivotipotecnologia.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReltipodispositivotipotecnologiaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReltipodispositivotipotecnologiaAggregateArgs>(args: Subset<T, ReltipodispositivotipotecnologiaAggregateArgs>): PrismaPromise<GetReltipodispositivotipotecnologiaAggregateType<T>>

    /**
     * Group by Reltipodispositivotipotecnologia.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReltipodispositivotipotecnologiaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReltipodispositivotipotecnologiaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReltipodispositivotipotecnologiaGroupByArgs['orderBy'] }
        : { orderBy?: ReltipodispositivotipotecnologiaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReltipodispositivotipotecnologiaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReltipodispositivotipotecnologiaGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for reltipodispositivotipotecnologia.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__reltipodispositivotipotecnologiaClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * reltipodispositivotipotecnologia base type for findUnique actions
   */
  export type reltipodispositivotipotecnologiaFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the reltipodispositivotipotecnologia
     * 
    **/
    select?: reltipodispositivotipotecnologiaSelect | null
    /**
     * Filter, which reltipodispositivotipotecnologia to fetch.
     * 
    **/
    where: reltipodispositivotipotecnologiaWhereUniqueInput
  }

  /**
   * reltipodispositivotipotecnologia: findUnique
   */
  export interface reltipodispositivotipotecnologiaFindUniqueArgs extends reltipodispositivotipotecnologiaFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * reltipodispositivotipotecnologia findUniqueOrThrow
   */
  export type reltipodispositivotipotecnologiaFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the reltipodispositivotipotecnologia
     * 
    **/
    select?: reltipodispositivotipotecnologiaSelect | null
    /**
     * Filter, which reltipodispositivotipotecnologia to fetch.
     * 
    **/
    where: reltipodispositivotipotecnologiaWhereUniqueInput
  }


  /**
   * reltipodispositivotipotecnologia base type for findFirst actions
   */
  export type reltipodispositivotipotecnologiaFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the reltipodispositivotipotecnologia
     * 
    **/
    select?: reltipodispositivotipotecnologiaSelect | null
    /**
     * Filter, which reltipodispositivotipotecnologia to fetch.
     * 
    **/
    where?: reltipodispositivotipotecnologiaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of reltipodispositivotipotecnologias to fetch.
     * 
    **/
    orderBy?: Enumerable<reltipodispositivotipotecnologiaOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for reltipodispositivotipotecnologias.
     * 
    **/
    cursor?: reltipodispositivotipotecnologiaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` reltipodispositivotipotecnologias from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` reltipodispositivotipotecnologias.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of reltipodispositivotipotecnologias.
     * 
    **/
    distinct?: Enumerable<ReltipodispositivotipotecnologiaScalarFieldEnum>
  }

  /**
   * reltipodispositivotipotecnologia: findFirst
   */
  export interface reltipodispositivotipotecnologiaFindFirstArgs extends reltipodispositivotipotecnologiaFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * reltipodispositivotipotecnologia findFirstOrThrow
   */
  export type reltipodispositivotipotecnologiaFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the reltipodispositivotipotecnologia
     * 
    **/
    select?: reltipodispositivotipotecnologiaSelect | null
    /**
     * Filter, which reltipodispositivotipotecnologia to fetch.
     * 
    **/
    where?: reltipodispositivotipotecnologiaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of reltipodispositivotipotecnologias to fetch.
     * 
    **/
    orderBy?: Enumerable<reltipodispositivotipotecnologiaOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for reltipodispositivotipotecnologias.
     * 
    **/
    cursor?: reltipodispositivotipotecnologiaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` reltipodispositivotipotecnologias from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` reltipodispositivotipotecnologias.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of reltipodispositivotipotecnologias.
     * 
    **/
    distinct?: Enumerable<ReltipodispositivotipotecnologiaScalarFieldEnum>
  }


  /**
   * reltipodispositivotipotecnologia findMany
   */
  export type reltipodispositivotipotecnologiaFindManyArgs = {
    /**
     * Select specific fields to fetch from the reltipodispositivotipotecnologia
     * 
    **/
    select?: reltipodispositivotipotecnologiaSelect | null
    /**
     * Filter, which reltipodispositivotipotecnologias to fetch.
     * 
    **/
    where?: reltipodispositivotipotecnologiaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of reltipodispositivotipotecnologias to fetch.
     * 
    **/
    orderBy?: Enumerable<reltipodispositivotipotecnologiaOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing reltipodispositivotipotecnologias.
     * 
    **/
    cursor?: reltipodispositivotipotecnologiaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` reltipodispositivotipotecnologias from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` reltipodispositivotipotecnologias.
     * 
    **/
    skip?: number
    distinct?: Enumerable<ReltipodispositivotipotecnologiaScalarFieldEnum>
  }


  /**
   * reltipodispositivotipotecnologia create
   */
  export type reltipodispositivotipotecnologiaCreateArgs = {
    /**
     * Select specific fields to fetch from the reltipodispositivotipotecnologia
     * 
    **/
    select?: reltipodispositivotipotecnologiaSelect | null
    /**
     * The data needed to create a reltipodispositivotipotecnologia.
     * 
    **/
    data: XOR<reltipodispositivotipotecnologiaCreateInput, reltipodispositivotipotecnologiaUncheckedCreateInput>
  }


  /**
   * reltipodispositivotipotecnologia createMany
   */
  export type reltipodispositivotipotecnologiaCreateManyArgs = {
    /**
     * The data used to create many reltipodispositivotipotecnologias.
     * 
    **/
    data: Enumerable<reltipodispositivotipotecnologiaCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * reltipodispositivotipotecnologia update
   */
  export type reltipodispositivotipotecnologiaUpdateArgs = {
    /**
     * Select specific fields to fetch from the reltipodispositivotipotecnologia
     * 
    **/
    select?: reltipodispositivotipotecnologiaSelect | null
    /**
     * The data needed to update a reltipodispositivotipotecnologia.
     * 
    **/
    data: XOR<reltipodispositivotipotecnologiaUpdateInput, reltipodispositivotipotecnologiaUncheckedUpdateInput>
    /**
     * Choose, which reltipodispositivotipotecnologia to update.
     * 
    **/
    where: reltipodispositivotipotecnologiaWhereUniqueInput
  }


  /**
   * reltipodispositivotipotecnologia updateMany
   */
  export type reltipodispositivotipotecnologiaUpdateManyArgs = {
    /**
     * The data used to update reltipodispositivotipotecnologias.
     * 
    **/
    data: XOR<reltipodispositivotipotecnologiaUpdateManyMutationInput, reltipodispositivotipotecnologiaUncheckedUpdateManyInput>
    /**
     * Filter which reltipodispositivotipotecnologias to update
     * 
    **/
    where?: reltipodispositivotipotecnologiaWhereInput
  }


  /**
   * reltipodispositivotipotecnologia upsert
   */
  export type reltipodispositivotipotecnologiaUpsertArgs = {
    /**
     * Select specific fields to fetch from the reltipodispositivotipotecnologia
     * 
    **/
    select?: reltipodispositivotipotecnologiaSelect | null
    /**
     * The filter to search for the reltipodispositivotipotecnologia to update in case it exists.
     * 
    **/
    where: reltipodispositivotipotecnologiaWhereUniqueInput
    /**
     * In case the reltipodispositivotipotecnologia found by the `where` argument doesn't exist, create a new reltipodispositivotipotecnologia with this data.
     * 
    **/
    create: XOR<reltipodispositivotipotecnologiaCreateInput, reltipodispositivotipotecnologiaUncheckedCreateInput>
    /**
     * In case the reltipodispositivotipotecnologia was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<reltipodispositivotipotecnologiaUpdateInput, reltipodispositivotipotecnologiaUncheckedUpdateInput>
  }


  /**
   * reltipodispositivotipotecnologia delete
   */
  export type reltipodispositivotipotecnologiaDeleteArgs = {
    /**
     * Select specific fields to fetch from the reltipodispositivotipotecnologia
     * 
    **/
    select?: reltipodispositivotipotecnologiaSelect | null
    /**
     * Filter which reltipodispositivotipotecnologia to delete.
     * 
    **/
    where: reltipodispositivotipotecnologiaWhereUniqueInput
  }


  /**
   * reltipodispositivotipotecnologia deleteMany
   */
  export type reltipodispositivotipotecnologiaDeleteManyArgs = {
    /**
     * Filter which reltipodispositivotipotecnologias to delete
     * 
    **/
    where?: reltipodispositivotipotecnologiaWhereInput
  }


  /**
   * reltipodispositivotipotecnologia without action
   */
  export type reltipodispositivotipotecnologiaArgs = {
    /**
     * Select specific fields to fetch from the reltipodispositivotipotecnologia
     * 
    **/
    select?: reltipodispositivotipotecnologiaSelect | null
  }



  /**
   * Model reltipogatewayperfildispositivo
   */


  export type AggregateReltipogatewayperfildispositivo = {
    _count: ReltipogatewayperfildispositivoCountAggregateOutputType | null
    _avg: ReltipogatewayperfildispositivoAvgAggregateOutputType | null
    _sum: ReltipogatewayperfildispositivoSumAggregateOutputType | null
    _min: ReltipogatewayperfildispositivoMinAggregateOutputType | null
    _max: ReltipogatewayperfildispositivoMaxAggregateOutputType | null
  }

  export type ReltipogatewayperfildispositivoAvgAggregateOutputType = {
    IDRelTipoGatewayPerfil: number | null
    IDTipoGateway: number | null
    IDPerfilDispositivo: number | null
  }

  export type ReltipogatewayperfildispositivoSumAggregateOutputType = {
    IDRelTipoGatewayPerfil: number | null
    IDTipoGateway: number | null
    IDPerfilDispositivo: number | null
  }

  export type ReltipogatewayperfildispositivoMinAggregateOutputType = {
    IDRelTipoGatewayPerfil: number | null
    IDTipoGateway: number | null
    IDPerfilDispositivo: number | null
  }

  export type ReltipogatewayperfildispositivoMaxAggregateOutputType = {
    IDRelTipoGatewayPerfil: number | null
    IDTipoGateway: number | null
    IDPerfilDispositivo: number | null
  }

  export type ReltipogatewayperfildispositivoCountAggregateOutputType = {
    IDRelTipoGatewayPerfil: number
    IDTipoGateway: number
    IDPerfilDispositivo: number
    _all: number
  }


  export type ReltipogatewayperfildispositivoAvgAggregateInputType = {
    IDRelTipoGatewayPerfil?: true
    IDTipoGateway?: true
    IDPerfilDispositivo?: true
  }

  export type ReltipogatewayperfildispositivoSumAggregateInputType = {
    IDRelTipoGatewayPerfil?: true
    IDTipoGateway?: true
    IDPerfilDispositivo?: true
  }

  export type ReltipogatewayperfildispositivoMinAggregateInputType = {
    IDRelTipoGatewayPerfil?: true
    IDTipoGateway?: true
    IDPerfilDispositivo?: true
  }

  export type ReltipogatewayperfildispositivoMaxAggregateInputType = {
    IDRelTipoGatewayPerfil?: true
    IDTipoGateway?: true
    IDPerfilDispositivo?: true
  }

  export type ReltipogatewayperfildispositivoCountAggregateInputType = {
    IDRelTipoGatewayPerfil?: true
    IDTipoGateway?: true
    IDPerfilDispositivo?: true
    _all?: true
  }

  export type ReltipogatewayperfildispositivoAggregateArgs = {
    /**
     * Filter which reltipogatewayperfildispositivo to aggregate.
     * 
    **/
    where?: reltipogatewayperfildispositivoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of reltipogatewayperfildispositivos to fetch.
     * 
    **/
    orderBy?: Enumerable<reltipogatewayperfildispositivoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: reltipogatewayperfildispositivoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` reltipogatewayperfildispositivos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` reltipogatewayperfildispositivos.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned reltipogatewayperfildispositivos
    **/
    _count?: true | ReltipogatewayperfildispositivoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ReltipogatewayperfildispositivoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ReltipogatewayperfildispositivoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReltipogatewayperfildispositivoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReltipogatewayperfildispositivoMaxAggregateInputType
  }

  export type GetReltipogatewayperfildispositivoAggregateType<T extends ReltipogatewayperfildispositivoAggregateArgs> = {
        [P in keyof T & keyof AggregateReltipogatewayperfildispositivo]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReltipogatewayperfildispositivo[P]>
      : GetScalarType<T[P], AggregateReltipogatewayperfildispositivo[P]>
  }




  export type ReltipogatewayperfildispositivoGroupByArgs = {
    where?: reltipogatewayperfildispositivoWhereInput
    orderBy?: Enumerable<reltipogatewayperfildispositivoOrderByWithAggregationInput>
    by: Array<ReltipogatewayperfildispositivoScalarFieldEnum>
    having?: reltipogatewayperfildispositivoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReltipogatewayperfildispositivoCountAggregateInputType | true
    _avg?: ReltipogatewayperfildispositivoAvgAggregateInputType
    _sum?: ReltipogatewayperfildispositivoSumAggregateInputType
    _min?: ReltipogatewayperfildispositivoMinAggregateInputType
    _max?: ReltipogatewayperfildispositivoMaxAggregateInputType
  }


  export type ReltipogatewayperfildispositivoGroupByOutputType = {
    IDRelTipoGatewayPerfil: number
    IDTipoGateway: number | null
    IDPerfilDispositivo: number | null
    _count: ReltipogatewayperfildispositivoCountAggregateOutputType | null
    _avg: ReltipogatewayperfildispositivoAvgAggregateOutputType | null
    _sum: ReltipogatewayperfildispositivoSumAggregateOutputType | null
    _min: ReltipogatewayperfildispositivoMinAggregateOutputType | null
    _max: ReltipogatewayperfildispositivoMaxAggregateOutputType | null
  }

  type GetReltipogatewayperfildispositivoGroupByPayload<T extends ReltipogatewayperfildispositivoGroupByArgs> = PrismaPromise<
    Array<
      PickArray<ReltipogatewayperfildispositivoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReltipogatewayperfildispositivoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReltipogatewayperfildispositivoGroupByOutputType[P]>
            : GetScalarType<T[P], ReltipogatewayperfildispositivoGroupByOutputType[P]>
        }
      >
    >


  export type reltipogatewayperfildispositivoSelect = {
    IDRelTipoGatewayPerfil?: boolean
    IDTipoGateway?: boolean
    IDPerfilDispositivo?: boolean
  }


  export type reltipogatewayperfildispositivoGetPayload<S extends boolean | null | undefined | reltipogatewayperfildispositivoArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? reltipogatewayperfildispositivo :
    S extends undefined ? never :
    S extends { include: any } & (reltipogatewayperfildispositivoArgs | reltipogatewayperfildispositivoFindManyArgs)
    ? reltipogatewayperfildispositivo 
    : S extends { select: any } & (reltipogatewayperfildispositivoArgs | reltipogatewayperfildispositivoFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof reltipogatewayperfildispositivo ? reltipogatewayperfildispositivo[P] : never
  } 
      : reltipogatewayperfildispositivo


  type reltipogatewayperfildispositivoCountArgs = Merge<
    Omit<reltipogatewayperfildispositivoFindManyArgs, 'select' | 'include'> & {
      select?: ReltipogatewayperfildispositivoCountAggregateInputType | true
    }
  >

  export interface reltipogatewayperfildispositivoDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Reltipogatewayperfildispositivo that matches the filter.
     * @param {reltipogatewayperfildispositivoFindUniqueArgs} args - Arguments to find a Reltipogatewayperfildispositivo
     * @example
     * // Get one Reltipogatewayperfildispositivo
     * const reltipogatewayperfildispositivo = await prisma.reltipogatewayperfildispositivo.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends reltipogatewayperfildispositivoFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, reltipogatewayperfildispositivoFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'reltipogatewayperfildispositivo'> extends True ? Prisma__reltipogatewayperfildispositivoClient<reltipogatewayperfildispositivoGetPayload<T>> : Prisma__reltipogatewayperfildispositivoClient<reltipogatewayperfildispositivoGetPayload<T> | null, null>

    /**
     * Find one Reltipogatewayperfildispositivo that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {reltipogatewayperfildispositivoFindUniqueOrThrowArgs} args - Arguments to find a Reltipogatewayperfildispositivo
     * @example
     * // Get one Reltipogatewayperfildispositivo
     * const reltipogatewayperfildispositivo = await prisma.reltipogatewayperfildispositivo.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends reltipogatewayperfildispositivoFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, reltipogatewayperfildispositivoFindUniqueOrThrowArgs>
    ): Prisma__reltipogatewayperfildispositivoClient<reltipogatewayperfildispositivoGetPayload<T>>

    /**
     * Find the first Reltipogatewayperfildispositivo that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reltipogatewayperfildispositivoFindFirstArgs} args - Arguments to find a Reltipogatewayperfildispositivo
     * @example
     * // Get one Reltipogatewayperfildispositivo
     * const reltipogatewayperfildispositivo = await prisma.reltipogatewayperfildispositivo.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends reltipogatewayperfildispositivoFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, reltipogatewayperfildispositivoFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'reltipogatewayperfildispositivo'> extends True ? Prisma__reltipogatewayperfildispositivoClient<reltipogatewayperfildispositivoGetPayload<T>> : Prisma__reltipogatewayperfildispositivoClient<reltipogatewayperfildispositivoGetPayload<T> | null, null>

    /**
     * Find the first Reltipogatewayperfildispositivo that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reltipogatewayperfildispositivoFindFirstOrThrowArgs} args - Arguments to find a Reltipogatewayperfildispositivo
     * @example
     * // Get one Reltipogatewayperfildispositivo
     * const reltipogatewayperfildispositivo = await prisma.reltipogatewayperfildispositivo.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends reltipogatewayperfildispositivoFindFirstOrThrowArgs>(
      args?: SelectSubset<T, reltipogatewayperfildispositivoFindFirstOrThrowArgs>
    ): Prisma__reltipogatewayperfildispositivoClient<reltipogatewayperfildispositivoGetPayload<T>>

    /**
     * Find zero or more Reltipogatewayperfildispositivos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reltipogatewayperfildispositivoFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Reltipogatewayperfildispositivos
     * const reltipogatewayperfildispositivos = await prisma.reltipogatewayperfildispositivo.findMany()
     * 
     * // Get first 10 Reltipogatewayperfildispositivos
     * const reltipogatewayperfildispositivos = await prisma.reltipogatewayperfildispositivo.findMany({ take: 10 })
     * 
     * // Only select the `IDRelTipoGatewayPerfil`
     * const reltipogatewayperfildispositivoWithIDRelTipoGatewayPerfilOnly = await prisma.reltipogatewayperfildispositivo.findMany({ select: { IDRelTipoGatewayPerfil: true } })
     * 
    **/
    findMany<T extends reltipogatewayperfildispositivoFindManyArgs>(
      args?: SelectSubset<T, reltipogatewayperfildispositivoFindManyArgs>
    ): PrismaPromise<Array<reltipogatewayperfildispositivoGetPayload<T>>>

    /**
     * Create a Reltipogatewayperfildispositivo.
     * @param {reltipogatewayperfildispositivoCreateArgs} args - Arguments to create a Reltipogatewayperfildispositivo.
     * @example
     * // Create one Reltipogatewayperfildispositivo
     * const Reltipogatewayperfildispositivo = await prisma.reltipogatewayperfildispositivo.create({
     *   data: {
     *     // ... data to create a Reltipogatewayperfildispositivo
     *   }
     * })
     * 
    **/
    create<T extends reltipogatewayperfildispositivoCreateArgs>(
      args: SelectSubset<T, reltipogatewayperfildispositivoCreateArgs>
    ): Prisma__reltipogatewayperfildispositivoClient<reltipogatewayperfildispositivoGetPayload<T>>

    /**
     * Create many Reltipogatewayperfildispositivos.
     *     @param {reltipogatewayperfildispositivoCreateManyArgs} args - Arguments to create many Reltipogatewayperfildispositivos.
     *     @example
     *     // Create many Reltipogatewayperfildispositivos
     *     const reltipogatewayperfildispositivo = await prisma.reltipogatewayperfildispositivo.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends reltipogatewayperfildispositivoCreateManyArgs>(
      args?: SelectSubset<T, reltipogatewayperfildispositivoCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Reltipogatewayperfildispositivo.
     * @param {reltipogatewayperfildispositivoDeleteArgs} args - Arguments to delete one Reltipogatewayperfildispositivo.
     * @example
     * // Delete one Reltipogatewayperfildispositivo
     * const Reltipogatewayperfildispositivo = await prisma.reltipogatewayperfildispositivo.delete({
     *   where: {
     *     // ... filter to delete one Reltipogatewayperfildispositivo
     *   }
     * })
     * 
    **/
    delete<T extends reltipogatewayperfildispositivoDeleteArgs>(
      args: SelectSubset<T, reltipogatewayperfildispositivoDeleteArgs>
    ): Prisma__reltipogatewayperfildispositivoClient<reltipogatewayperfildispositivoGetPayload<T>>

    /**
     * Update one Reltipogatewayperfildispositivo.
     * @param {reltipogatewayperfildispositivoUpdateArgs} args - Arguments to update one Reltipogatewayperfildispositivo.
     * @example
     * // Update one Reltipogatewayperfildispositivo
     * const reltipogatewayperfildispositivo = await prisma.reltipogatewayperfildispositivo.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends reltipogatewayperfildispositivoUpdateArgs>(
      args: SelectSubset<T, reltipogatewayperfildispositivoUpdateArgs>
    ): Prisma__reltipogatewayperfildispositivoClient<reltipogatewayperfildispositivoGetPayload<T>>

    /**
     * Delete zero or more Reltipogatewayperfildispositivos.
     * @param {reltipogatewayperfildispositivoDeleteManyArgs} args - Arguments to filter Reltipogatewayperfildispositivos to delete.
     * @example
     * // Delete a few Reltipogatewayperfildispositivos
     * const { count } = await prisma.reltipogatewayperfildispositivo.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends reltipogatewayperfildispositivoDeleteManyArgs>(
      args?: SelectSubset<T, reltipogatewayperfildispositivoDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Reltipogatewayperfildispositivos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reltipogatewayperfildispositivoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Reltipogatewayperfildispositivos
     * const reltipogatewayperfildispositivo = await prisma.reltipogatewayperfildispositivo.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends reltipogatewayperfildispositivoUpdateManyArgs>(
      args: SelectSubset<T, reltipogatewayperfildispositivoUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Reltipogatewayperfildispositivo.
     * @param {reltipogatewayperfildispositivoUpsertArgs} args - Arguments to update or create a Reltipogatewayperfildispositivo.
     * @example
     * // Update or create a Reltipogatewayperfildispositivo
     * const reltipogatewayperfildispositivo = await prisma.reltipogatewayperfildispositivo.upsert({
     *   create: {
     *     // ... data to create a Reltipogatewayperfildispositivo
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Reltipogatewayperfildispositivo we want to update
     *   }
     * })
    **/
    upsert<T extends reltipogatewayperfildispositivoUpsertArgs>(
      args: SelectSubset<T, reltipogatewayperfildispositivoUpsertArgs>
    ): Prisma__reltipogatewayperfildispositivoClient<reltipogatewayperfildispositivoGetPayload<T>>

    /**
     * Count the number of Reltipogatewayperfildispositivos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reltipogatewayperfildispositivoCountArgs} args - Arguments to filter Reltipogatewayperfildispositivos to count.
     * @example
     * // Count the number of Reltipogatewayperfildispositivos
     * const count = await prisma.reltipogatewayperfildispositivo.count({
     *   where: {
     *     // ... the filter for the Reltipogatewayperfildispositivos we want to count
     *   }
     * })
    **/
    count<T extends reltipogatewayperfildispositivoCountArgs>(
      args?: Subset<T, reltipogatewayperfildispositivoCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReltipogatewayperfildispositivoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Reltipogatewayperfildispositivo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReltipogatewayperfildispositivoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReltipogatewayperfildispositivoAggregateArgs>(args: Subset<T, ReltipogatewayperfildispositivoAggregateArgs>): PrismaPromise<GetReltipogatewayperfildispositivoAggregateType<T>>

    /**
     * Group by Reltipogatewayperfildispositivo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReltipogatewayperfildispositivoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReltipogatewayperfildispositivoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReltipogatewayperfildispositivoGroupByArgs['orderBy'] }
        : { orderBy?: ReltipogatewayperfildispositivoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReltipogatewayperfildispositivoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReltipogatewayperfildispositivoGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for reltipogatewayperfildispositivo.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__reltipogatewayperfildispositivoClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * reltipogatewayperfildispositivo base type for findUnique actions
   */
  export type reltipogatewayperfildispositivoFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the reltipogatewayperfildispositivo
     * 
    **/
    select?: reltipogatewayperfildispositivoSelect | null
    /**
     * Filter, which reltipogatewayperfildispositivo to fetch.
     * 
    **/
    where: reltipogatewayperfildispositivoWhereUniqueInput
  }

  /**
   * reltipogatewayperfildispositivo: findUnique
   */
  export interface reltipogatewayperfildispositivoFindUniqueArgs extends reltipogatewayperfildispositivoFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * reltipogatewayperfildispositivo findUniqueOrThrow
   */
  export type reltipogatewayperfildispositivoFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the reltipogatewayperfildispositivo
     * 
    **/
    select?: reltipogatewayperfildispositivoSelect | null
    /**
     * Filter, which reltipogatewayperfildispositivo to fetch.
     * 
    **/
    where: reltipogatewayperfildispositivoWhereUniqueInput
  }


  /**
   * reltipogatewayperfildispositivo base type for findFirst actions
   */
  export type reltipogatewayperfildispositivoFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the reltipogatewayperfildispositivo
     * 
    **/
    select?: reltipogatewayperfildispositivoSelect | null
    /**
     * Filter, which reltipogatewayperfildispositivo to fetch.
     * 
    **/
    where?: reltipogatewayperfildispositivoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of reltipogatewayperfildispositivos to fetch.
     * 
    **/
    orderBy?: Enumerable<reltipogatewayperfildispositivoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for reltipogatewayperfildispositivos.
     * 
    **/
    cursor?: reltipogatewayperfildispositivoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` reltipogatewayperfildispositivos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` reltipogatewayperfildispositivos.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of reltipogatewayperfildispositivos.
     * 
    **/
    distinct?: Enumerable<ReltipogatewayperfildispositivoScalarFieldEnum>
  }

  /**
   * reltipogatewayperfildispositivo: findFirst
   */
  export interface reltipogatewayperfildispositivoFindFirstArgs extends reltipogatewayperfildispositivoFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * reltipogatewayperfildispositivo findFirstOrThrow
   */
  export type reltipogatewayperfildispositivoFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the reltipogatewayperfildispositivo
     * 
    **/
    select?: reltipogatewayperfildispositivoSelect | null
    /**
     * Filter, which reltipogatewayperfildispositivo to fetch.
     * 
    **/
    where?: reltipogatewayperfildispositivoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of reltipogatewayperfildispositivos to fetch.
     * 
    **/
    orderBy?: Enumerable<reltipogatewayperfildispositivoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for reltipogatewayperfildispositivos.
     * 
    **/
    cursor?: reltipogatewayperfildispositivoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` reltipogatewayperfildispositivos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` reltipogatewayperfildispositivos.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of reltipogatewayperfildispositivos.
     * 
    **/
    distinct?: Enumerable<ReltipogatewayperfildispositivoScalarFieldEnum>
  }


  /**
   * reltipogatewayperfildispositivo findMany
   */
  export type reltipogatewayperfildispositivoFindManyArgs = {
    /**
     * Select specific fields to fetch from the reltipogatewayperfildispositivo
     * 
    **/
    select?: reltipogatewayperfildispositivoSelect | null
    /**
     * Filter, which reltipogatewayperfildispositivos to fetch.
     * 
    **/
    where?: reltipogatewayperfildispositivoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of reltipogatewayperfildispositivos to fetch.
     * 
    **/
    orderBy?: Enumerable<reltipogatewayperfildispositivoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing reltipogatewayperfildispositivos.
     * 
    **/
    cursor?: reltipogatewayperfildispositivoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` reltipogatewayperfildispositivos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` reltipogatewayperfildispositivos.
     * 
    **/
    skip?: number
    distinct?: Enumerable<ReltipogatewayperfildispositivoScalarFieldEnum>
  }


  /**
   * reltipogatewayperfildispositivo create
   */
  export type reltipogatewayperfildispositivoCreateArgs = {
    /**
     * Select specific fields to fetch from the reltipogatewayperfildispositivo
     * 
    **/
    select?: reltipogatewayperfildispositivoSelect | null
    /**
     * The data needed to create a reltipogatewayperfildispositivo.
     * 
    **/
    data: XOR<reltipogatewayperfildispositivoCreateInput, reltipogatewayperfildispositivoUncheckedCreateInput>
  }


  /**
   * reltipogatewayperfildispositivo createMany
   */
  export type reltipogatewayperfildispositivoCreateManyArgs = {
    /**
     * The data used to create many reltipogatewayperfildispositivos.
     * 
    **/
    data: Enumerable<reltipogatewayperfildispositivoCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * reltipogatewayperfildispositivo update
   */
  export type reltipogatewayperfildispositivoUpdateArgs = {
    /**
     * Select specific fields to fetch from the reltipogatewayperfildispositivo
     * 
    **/
    select?: reltipogatewayperfildispositivoSelect | null
    /**
     * The data needed to update a reltipogatewayperfildispositivo.
     * 
    **/
    data: XOR<reltipogatewayperfildispositivoUpdateInput, reltipogatewayperfildispositivoUncheckedUpdateInput>
    /**
     * Choose, which reltipogatewayperfildispositivo to update.
     * 
    **/
    where: reltipogatewayperfildispositivoWhereUniqueInput
  }


  /**
   * reltipogatewayperfildispositivo updateMany
   */
  export type reltipogatewayperfildispositivoUpdateManyArgs = {
    /**
     * The data used to update reltipogatewayperfildispositivos.
     * 
    **/
    data: XOR<reltipogatewayperfildispositivoUpdateManyMutationInput, reltipogatewayperfildispositivoUncheckedUpdateManyInput>
    /**
     * Filter which reltipogatewayperfildispositivos to update
     * 
    **/
    where?: reltipogatewayperfildispositivoWhereInput
  }


  /**
   * reltipogatewayperfildispositivo upsert
   */
  export type reltipogatewayperfildispositivoUpsertArgs = {
    /**
     * Select specific fields to fetch from the reltipogatewayperfildispositivo
     * 
    **/
    select?: reltipogatewayperfildispositivoSelect | null
    /**
     * The filter to search for the reltipogatewayperfildispositivo to update in case it exists.
     * 
    **/
    where: reltipogatewayperfildispositivoWhereUniqueInput
    /**
     * In case the reltipogatewayperfildispositivo found by the `where` argument doesn't exist, create a new reltipogatewayperfildispositivo with this data.
     * 
    **/
    create: XOR<reltipogatewayperfildispositivoCreateInput, reltipogatewayperfildispositivoUncheckedCreateInput>
    /**
     * In case the reltipogatewayperfildispositivo was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<reltipogatewayperfildispositivoUpdateInput, reltipogatewayperfildispositivoUncheckedUpdateInput>
  }


  /**
   * reltipogatewayperfildispositivo delete
   */
  export type reltipogatewayperfildispositivoDeleteArgs = {
    /**
     * Select specific fields to fetch from the reltipogatewayperfildispositivo
     * 
    **/
    select?: reltipogatewayperfildispositivoSelect | null
    /**
     * Filter which reltipogatewayperfildispositivo to delete.
     * 
    **/
    where: reltipogatewayperfildispositivoWhereUniqueInput
  }


  /**
   * reltipogatewayperfildispositivo deleteMany
   */
  export type reltipogatewayperfildispositivoDeleteManyArgs = {
    /**
     * Filter which reltipogatewayperfildispositivos to delete
     * 
    **/
    where?: reltipogatewayperfildispositivoWhereInput
  }


  /**
   * reltipogatewayperfildispositivo without action
   */
  export type reltipogatewayperfildispositivoArgs = {
    /**
     * Select specific fields to fetch from the reltipogatewayperfildispositivo
     * 
    **/
    select?: reltipogatewayperfildispositivoSelect | null
  }



  /**
   * Model subsistemas
   */


  export type AggregateSubsistemas = {
    _count: SubsistemasCountAggregateOutputType | null
    _avg: SubsistemasAvgAggregateOutputType | null
    _sum: SubsistemasSumAggregateOutputType | null
    _min: SubsistemasMinAggregateOutputType | null
    _max: SubsistemasMaxAggregateOutputType | null
  }

  export type SubsistemasAvgAggregateOutputType = {
    IDSubSistema: number | null
    Puerto: number | null
  }

  export type SubsistemasSumAggregateOutputType = {
    IDSubSistema: number | null
    Puerto: number | null
  }

  export type SubsistemasMinAggregateOutputType = {
    IDSubSistema: number | null
    NombreSubSistema: string | null
    DescripcionSubSistema: string | null
    URLSubSistema: string | null
    Puerto: number | null
  }

  export type SubsistemasMaxAggregateOutputType = {
    IDSubSistema: number | null
    NombreSubSistema: string | null
    DescripcionSubSistema: string | null
    URLSubSistema: string | null
    Puerto: number | null
  }

  export type SubsistemasCountAggregateOutputType = {
    IDSubSistema: number
    NombreSubSistema: number
    DescripcionSubSistema: number
    URLSubSistema: number
    Puerto: number
    _all: number
  }


  export type SubsistemasAvgAggregateInputType = {
    IDSubSistema?: true
    Puerto?: true
  }

  export type SubsistemasSumAggregateInputType = {
    IDSubSistema?: true
    Puerto?: true
  }

  export type SubsistemasMinAggregateInputType = {
    IDSubSistema?: true
    NombreSubSistema?: true
    DescripcionSubSistema?: true
    URLSubSistema?: true
    Puerto?: true
  }

  export type SubsistemasMaxAggregateInputType = {
    IDSubSistema?: true
    NombreSubSistema?: true
    DescripcionSubSistema?: true
    URLSubSistema?: true
    Puerto?: true
  }

  export type SubsistemasCountAggregateInputType = {
    IDSubSistema?: true
    NombreSubSistema?: true
    DescripcionSubSistema?: true
    URLSubSistema?: true
    Puerto?: true
    _all?: true
  }

  export type SubsistemasAggregateArgs = {
    /**
     * Filter which subsistemas to aggregate.
     * 
    **/
    where?: subsistemasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of subsistemas to fetch.
     * 
    **/
    orderBy?: Enumerable<subsistemasOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: subsistemasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` subsistemas from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` subsistemas.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned subsistemas
    **/
    _count?: true | SubsistemasCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SubsistemasAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SubsistemasSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SubsistemasMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SubsistemasMaxAggregateInputType
  }

  export type GetSubsistemasAggregateType<T extends SubsistemasAggregateArgs> = {
        [P in keyof T & keyof AggregateSubsistemas]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSubsistemas[P]>
      : GetScalarType<T[P], AggregateSubsistemas[P]>
  }




  export type SubsistemasGroupByArgs = {
    where?: subsistemasWhereInput
    orderBy?: Enumerable<subsistemasOrderByWithAggregationInput>
    by: Array<SubsistemasScalarFieldEnum>
    having?: subsistemasScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SubsistemasCountAggregateInputType | true
    _avg?: SubsistemasAvgAggregateInputType
    _sum?: SubsistemasSumAggregateInputType
    _min?: SubsistemasMinAggregateInputType
    _max?: SubsistemasMaxAggregateInputType
  }


  export type SubsistemasGroupByOutputType = {
    IDSubSistema: number
    NombreSubSistema: string | null
    DescripcionSubSistema: string | null
    URLSubSistema: string | null
    Puerto: number | null
    _count: SubsistemasCountAggregateOutputType | null
    _avg: SubsistemasAvgAggregateOutputType | null
    _sum: SubsistemasSumAggregateOutputType | null
    _min: SubsistemasMinAggregateOutputType | null
    _max: SubsistemasMaxAggregateOutputType | null
  }

  type GetSubsistemasGroupByPayload<T extends SubsistemasGroupByArgs> = PrismaPromise<
    Array<
      PickArray<SubsistemasGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SubsistemasGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SubsistemasGroupByOutputType[P]>
            : GetScalarType<T[P], SubsistemasGroupByOutputType[P]>
        }
      >
    >


  export type subsistemasSelect = {
    IDSubSistema?: boolean
    NombreSubSistema?: boolean
    DescripcionSubSistema?: boolean
    URLSubSistema?: boolean
    Puerto?: boolean
  }


  export type subsistemasGetPayload<S extends boolean | null | undefined | subsistemasArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? subsistemas :
    S extends undefined ? never :
    S extends { include: any } & (subsistemasArgs | subsistemasFindManyArgs)
    ? subsistemas 
    : S extends { select: any } & (subsistemasArgs | subsistemasFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof subsistemas ? subsistemas[P] : never
  } 
      : subsistemas


  type subsistemasCountArgs = Merge<
    Omit<subsistemasFindManyArgs, 'select' | 'include'> & {
      select?: SubsistemasCountAggregateInputType | true
    }
  >

  export interface subsistemasDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Subsistemas that matches the filter.
     * @param {subsistemasFindUniqueArgs} args - Arguments to find a Subsistemas
     * @example
     * // Get one Subsistemas
     * const subsistemas = await prisma.subsistemas.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends subsistemasFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, subsistemasFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'subsistemas'> extends True ? Prisma__subsistemasClient<subsistemasGetPayload<T>> : Prisma__subsistemasClient<subsistemasGetPayload<T> | null, null>

    /**
     * Find one Subsistemas that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {subsistemasFindUniqueOrThrowArgs} args - Arguments to find a Subsistemas
     * @example
     * // Get one Subsistemas
     * const subsistemas = await prisma.subsistemas.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends subsistemasFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, subsistemasFindUniqueOrThrowArgs>
    ): Prisma__subsistemasClient<subsistemasGetPayload<T>>

    /**
     * Find the first Subsistemas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {subsistemasFindFirstArgs} args - Arguments to find a Subsistemas
     * @example
     * // Get one Subsistemas
     * const subsistemas = await prisma.subsistemas.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends subsistemasFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, subsistemasFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'subsistemas'> extends True ? Prisma__subsistemasClient<subsistemasGetPayload<T>> : Prisma__subsistemasClient<subsistemasGetPayload<T> | null, null>

    /**
     * Find the first Subsistemas that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {subsistemasFindFirstOrThrowArgs} args - Arguments to find a Subsistemas
     * @example
     * // Get one Subsistemas
     * const subsistemas = await prisma.subsistemas.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends subsistemasFindFirstOrThrowArgs>(
      args?: SelectSubset<T, subsistemasFindFirstOrThrowArgs>
    ): Prisma__subsistemasClient<subsistemasGetPayload<T>>

    /**
     * Find zero or more Subsistemas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {subsistemasFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Subsistemas
     * const subsistemas = await prisma.subsistemas.findMany()
     * 
     * // Get first 10 Subsistemas
     * const subsistemas = await prisma.subsistemas.findMany({ take: 10 })
     * 
     * // Only select the `IDSubSistema`
     * const subsistemasWithIDSubSistemaOnly = await prisma.subsistemas.findMany({ select: { IDSubSistema: true } })
     * 
    **/
    findMany<T extends subsistemasFindManyArgs>(
      args?: SelectSubset<T, subsistemasFindManyArgs>
    ): PrismaPromise<Array<subsistemasGetPayload<T>>>

    /**
     * Create a Subsistemas.
     * @param {subsistemasCreateArgs} args - Arguments to create a Subsistemas.
     * @example
     * // Create one Subsistemas
     * const Subsistemas = await prisma.subsistemas.create({
     *   data: {
     *     // ... data to create a Subsistemas
     *   }
     * })
     * 
    **/
    create<T extends subsistemasCreateArgs>(
      args: SelectSubset<T, subsistemasCreateArgs>
    ): Prisma__subsistemasClient<subsistemasGetPayload<T>>

    /**
     * Create many Subsistemas.
     *     @param {subsistemasCreateManyArgs} args - Arguments to create many Subsistemas.
     *     @example
     *     // Create many Subsistemas
     *     const subsistemas = await prisma.subsistemas.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends subsistemasCreateManyArgs>(
      args?: SelectSubset<T, subsistemasCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Subsistemas.
     * @param {subsistemasDeleteArgs} args - Arguments to delete one Subsistemas.
     * @example
     * // Delete one Subsistemas
     * const Subsistemas = await prisma.subsistemas.delete({
     *   where: {
     *     // ... filter to delete one Subsistemas
     *   }
     * })
     * 
    **/
    delete<T extends subsistemasDeleteArgs>(
      args: SelectSubset<T, subsistemasDeleteArgs>
    ): Prisma__subsistemasClient<subsistemasGetPayload<T>>

    /**
     * Update one Subsistemas.
     * @param {subsistemasUpdateArgs} args - Arguments to update one Subsistemas.
     * @example
     * // Update one Subsistemas
     * const subsistemas = await prisma.subsistemas.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends subsistemasUpdateArgs>(
      args: SelectSubset<T, subsistemasUpdateArgs>
    ): Prisma__subsistemasClient<subsistemasGetPayload<T>>

    /**
     * Delete zero or more Subsistemas.
     * @param {subsistemasDeleteManyArgs} args - Arguments to filter Subsistemas to delete.
     * @example
     * // Delete a few Subsistemas
     * const { count } = await prisma.subsistemas.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends subsistemasDeleteManyArgs>(
      args?: SelectSubset<T, subsistemasDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Subsistemas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {subsistemasUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Subsistemas
     * const subsistemas = await prisma.subsistemas.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends subsistemasUpdateManyArgs>(
      args: SelectSubset<T, subsistemasUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Subsistemas.
     * @param {subsistemasUpsertArgs} args - Arguments to update or create a Subsistemas.
     * @example
     * // Update or create a Subsistemas
     * const subsistemas = await prisma.subsistemas.upsert({
     *   create: {
     *     // ... data to create a Subsistemas
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Subsistemas we want to update
     *   }
     * })
    **/
    upsert<T extends subsistemasUpsertArgs>(
      args: SelectSubset<T, subsistemasUpsertArgs>
    ): Prisma__subsistemasClient<subsistemasGetPayload<T>>

    /**
     * Count the number of Subsistemas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {subsistemasCountArgs} args - Arguments to filter Subsistemas to count.
     * @example
     * // Count the number of Subsistemas
     * const count = await prisma.subsistemas.count({
     *   where: {
     *     // ... the filter for the Subsistemas we want to count
     *   }
     * })
    **/
    count<T extends subsistemasCountArgs>(
      args?: Subset<T, subsistemasCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SubsistemasCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Subsistemas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubsistemasAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SubsistemasAggregateArgs>(args: Subset<T, SubsistemasAggregateArgs>): PrismaPromise<GetSubsistemasAggregateType<T>>

    /**
     * Group by Subsistemas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubsistemasGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SubsistemasGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SubsistemasGroupByArgs['orderBy'] }
        : { orderBy?: SubsistemasGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SubsistemasGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSubsistemasGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for subsistemas.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__subsistemasClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * subsistemas base type for findUnique actions
   */
  export type subsistemasFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the subsistemas
     * 
    **/
    select?: subsistemasSelect | null
    /**
     * Filter, which subsistemas to fetch.
     * 
    **/
    where: subsistemasWhereUniqueInput
  }

  /**
   * subsistemas: findUnique
   */
  export interface subsistemasFindUniqueArgs extends subsistemasFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * subsistemas findUniqueOrThrow
   */
  export type subsistemasFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the subsistemas
     * 
    **/
    select?: subsistemasSelect | null
    /**
     * Filter, which subsistemas to fetch.
     * 
    **/
    where: subsistemasWhereUniqueInput
  }


  /**
   * subsistemas base type for findFirst actions
   */
  export type subsistemasFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the subsistemas
     * 
    **/
    select?: subsistemasSelect | null
    /**
     * Filter, which subsistemas to fetch.
     * 
    **/
    where?: subsistemasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of subsistemas to fetch.
     * 
    **/
    orderBy?: Enumerable<subsistemasOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for subsistemas.
     * 
    **/
    cursor?: subsistemasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` subsistemas from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` subsistemas.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of subsistemas.
     * 
    **/
    distinct?: Enumerable<SubsistemasScalarFieldEnum>
  }

  /**
   * subsistemas: findFirst
   */
  export interface subsistemasFindFirstArgs extends subsistemasFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * subsistemas findFirstOrThrow
   */
  export type subsistemasFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the subsistemas
     * 
    **/
    select?: subsistemasSelect | null
    /**
     * Filter, which subsistemas to fetch.
     * 
    **/
    where?: subsistemasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of subsistemas to fetch.
     * 
    **/
    orderBy?: Enumerable<subsistemasOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for subsistemas.
     * 
    **/
    cursor?: subsistemasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` subsistemas from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` subsistemas.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of subsistemas.
     * 
    **/
    distinct?: Enumerable<SubsistemasScalarFieldEnum>
  }


  /**
   * subsistemas findMany
   */
  export type subsistemasFindManyArgs = {
    /**
     * Select specific fields to fetch from the subsistemas
     * 
    **/
    select?: subsistemasSelect | null
    /**
     * Filter, which subsistemas to fetch.
     * 
    **/
    where?: subsistemasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of subsistemas to fetch.
     * 
    **/
    orderBy?: Enumerable<subsistemasOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing subsistemas.
     * 
    **/
    cursor?: subsistemasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` subsistemas from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` subsistemas.
     * 
    **/
    skip?: number
    distinct?: Enumerable<SubsistemasScalarFieldEnum>
  }


  /**
   * subsistemas create
   */
  export type subsistemasCreateArgs = {
    /**
     * Select specific fields to fetch from the subsistemas
     * 
    **/
    select?: subsistemasSelect | null
    /**
     * The data needed to create a subsistemas.
     * 
    **/
    data: XOR<subsistemasCreateInput, subsistemasUncheckedCreateInput>
  }


  /**
   * subsistemas createMany
   */
  export type subsistemasCreateManyArgs = {
    /**
     * The data used to create many subsistemas.
     * 
    **/
    data: Enumerable<subsistemasCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * subsistemas update
   */
  export type subsistemasUpdateArgs = {
    /**
     * Select specific fields to fetch from the subsistemas
     * 
    **/
    select?: subsistemasSelect | null
    /**
     * The data needed to update a subsistemas.
     * 
    **/
    data: XOR<subsistemasUpdateInput, subsistemasUncheckedUpdateInput>
    /**
     * Choose, which subsistemas to update.
     * 
    **/
    where: subsistemasWhereUniqueInput
  }


  /**
   * subsistemas updateMany
   */
  export type subsistemasUpdateManyArgs = {
    /**
     * The data used to update subsistemas.
     * 
    **/
    data: XOR<subsistemasUpdateManyMutationInput, subsistemasUncheckedUpdateManyInput>
    /**
     * Filter which subsistemas to update
     * 
    **/
    where?: subsistemasWhereInput
  }


  /**
   * subsistemas upsert
   */
  export type subsistemasUpsertArgs = {
    /**
     * Select specific fields to fetch from the subsistemas
     * 
    **/
    select?: subsistemasSelect | null
    /**
     * The filter to search for the subsistemas to update in case it exists.
     * 
    **/
    where: subsistemasWhereUniqueInput
    /**
     * In case the subsistemas found by the `where` argument doesn't exist, create a new subsistemas with this data.
     * 
    **/
    create: XOR<subsistemasCreateInput, subsistemasUncheckedCreateInput>
    /**
     * In case the subsistemas was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<subsistemasUpdateInput, subsistemasUncheckedUpdateInput>
  }


  /**
   * subsistemas delete
   */
  export type subsistemasDeleteArgs = {
    /**
     * Select specific fields to fetch from the subsistemas
     * 
    **/
    select?: subsistemasSelect | null
    /**
     * Filter which subsistemas to delete.
     * 
    **/
    where: subsistemasWhereUniqueInput
  }


  /**
   * subsistemas deleteMany
   */
  export type subsistemasDeleteManyArgs = {
    /**
     * Filter which subsistemas to delete
     * 
    **/
    where?: subsistemasWhereInput
  }


  /**
   * subsistemas without action
   */
  export type subsistemasArgs = {
    /**
     * Select specific fields to fetch from the subsistemas
     * 
    **/
    select?: subsistemasSelect | null
  }



  /**
   * Model tablasinformacion
   */


  export type AggregateTablasinformacion = {
    _count: TablasinformacionCountAggregateOutputType | null
    _avg: TablasinformacionAvgAggregateOutputType | null
    _sum: TablasinformacionSumAggregateOutputType | null
    _min: TablasinformacionMinAggregateOutputType | null
    _max: TablasinformacionMaxAggregateOutputType | null
  }

  export type TablasinformacionAvgAggregateOutputType = {
    IDTabla: number | null
    Tipo: number | null
    CodigoNetsocs: number | null
  }

  export type TablasinformacionSumAggregateOutputType = {
    IDTabla: number | null
    Tipo: number | null
    CodigoNetsocs: number | null
  }

  export type TablasinformacionMinAggregateOutputType = {
    IDTabla: number | null
    NombreTabla: string | null
    Tipo: number | null
    Identidad: string | null
    CodigoNetsocs: number | null
  }

  export type TablasinformacionMaxAggregateOutputType = {
    IDTabla: number | null
    NombreTabla: string | null
    Tipo: number | null
    Identidad: string | null
    CodigoNetsocs: number | null
  }

  export type TablasinformacionCountAggregateOutputType = {
    IDTabla: number
    NombreTabla: number
    Tipo: number
    Identidad: number
    CodigoNetsocs: number
    _all: number
  }


  export type TablasinformacionAvgAggregateInputType = {
    IDTabla?: true
    Tipo?: true
    CodigoNetsocs?: true
  }

  export type TablasinformacionSumAggregateInputType = {
    IDTabla?: true
    Tipo?: true
    CodigoNetsocs?: true
  }

  export type TablasinformacionMinAggregateInputType = {
    IDTabla?: true
    NombreTabla?: true
    Tipo?: true
    Identidad?: true
    CodigoNetsocs?: true
  }

  export type TablasinformacionMaxAggregateInputType = {
    IDTabla?: true
    NombreTabla?: true
    Tipo?: true
    Identidad?: true
    CodigoNetsocs?: true
  }

  export type TablasinformacionCountAggregateInputType = {
    IDTabla?: true
    NombreTabla?: true
    Tipo?: true
    Identidad?: true
    CodigoNetsocs?: true
    _all?: true
  }

  export type TablasinformacionAggregateArgs = {
    /**
     * Filter which tablasinformacion to aggregate.
     * 
    **/
    where?: tablasinformacionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tablasinformacions to fetch.
     * 
    **/
    orderBy?: Enumerable<tablasinformacionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: tablasinformacionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tablasinformacions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tablasinformacions.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned tablasinformacions
    **/
    _count?: true | TablasinformacionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TablasinformacionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TablasinformacionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TablasinformacionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TablasinformacionMaxAggregateInputType
  }

  export type GetTablasinformacionAggregateType<T extends TablasinformacionAggregateArgs> = {
        [P in keyof T & keyof AggregateTablasinformacion]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTablasinformacion[P]>
      : GetScalarType<T[P], AggregateTablasinformacion[P]>
  }




  export type TablasinformacionGroupByArgs = {
    where?: tablasinformacionWhereInput
    orderBy?: Enumerable<tablasinformacionOrderByWithAggregationInput>
    by: Array<TablasinformacionScalarFieldEnum>
    having?: tablasinformacionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TablasinformacionCountAggregateInputType | true
    _avg?: TablasinformacionAvgAggregateInputType
    _sum?: TablasinformacionSumAggregateInputType
    _min?: TablasinformacionMinAggregateInputType
    _max?: TablasinformacionMaxAggregateInputType
  }


  export type TablasinformacionGroupByOutputType = {
    IDTabla: number
    NombreTabla: string | null
    Tipo: number | null
    Identidad: string | null
    CodigoNetsocs: number | null
    _count: TablasinformacionCountAggregateOutputType | null
    _avg: TablasinformacionAvgAggregateOutputType | null
    _sum: TablasinformacionSumAggregateOutputType | null
    _min: TablasinformacionMinAggregateOutputType | null
    _max: TablasinformacionMaxAggregateOutputType | null
  }

  type GetTablasinformacionGroupByPayload<T extends TablasinformacionGroupByArgs> = PrismaPromise<
    Array<
      PickArray<TablasinformacionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TablasinformacionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TablasinformacionGroupByOutputType[P]>
            : GetScalarType<T[P], TablasinformacionGroupByOutputType[P]>
        }
      >
    >


  export type tablasinformacionSelect = {
    IDTabla?: boolean
    NombreTabla?: boolean
    Tipo?: boolean
    Identidad?: boolean
    CodigoNetsocs?: boolean
  }


  export type tablasinformacionGetPayload<S extends boolean | null | undefined | tablasinformacionArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? tablasinformacion :
    S extends undefined ? never :
    S extends { include: any } & (tablasinformacionArgs | tablasinformacionFindManyArgs)
    ? tablasinformacion 
    : S extends { select: any } & (tablasinformacionArgs | tablasinformacionFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof tablasinformacion ? tablasinformacion[P] : never
  } 
      : tablasinformacion


  type tablasinformacionCountArgs = Merge<
    Omit<tablasinformacionFindManyArgs, 'select' | 'include'> & {
      select?: TablasinformacionCountAggregateInputType | true
    }
  >

  export interface tablasinformacionDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Tablasinformacion that matches the filter.
     * @param {tablasinformacionFindUniqueArgs} args - Arguments to find a Tablasinformacion
     * @example
     * // Get one Tablasinformacion
     * const tablasinformacion = await prisma.tablasinformacion.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends tablasinformacionFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, tablasinformacionFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'tablasinformacion'> extends True ? Prisma__tablasinformacionClient<tablasinformacionGetPayload<T>> : Prisma__tablasinformacionClient<tablasinformacionGetPayload<T> | null, null>

    /**
     * Find one Tablasinformacion that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {tablasinformacionFindUniqueOrThrowArgs} args - Arguments to find a Tablasinformacion
     * @example
     * // Get one Tablasinformacion
     * const tablasinformacion = await prisma.tablasinformacion.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends tablasinformacionFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, tablasinformacionFindUniqueOrThrowArgs>
    ): Prisma__tablasinformacionClient<tablasinformacionGetPayload<T>>

    /**
     * Find the first Tablasinformacion that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tablasinformacionFindFirstArgs} args - Arguments to find a Tablasinformacion
     * @example
     * // Get one Tablasinformacion
     * const tablasinformacion = await prisma.tablasinformacion.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends tablasinformacionFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, tablasinformacionFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'tablasinformacion'> extends True ? Prisma__tablasinformacionClient<tablasinformacionGetPayload<T>> : Prisma__tablasinformacionClient<tablasinformacionGetPayload<T> | null, null>

    /**
     * Find the first Tablasinformacion that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tablasinformacionFindFirstOrThrowArgs} args - Arguments to find a Tablasinformacion
     * @example
     * // Get one Tablasinformacion
     * const tablasinformacion = await prisma.tablasinformacion.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends tablasinformacionFindFirstOrThrowArgs>(
      args?: SelectSubset<T, tablasinformacionFindFirstOrThrowArgs>
    ): Prisma__tablasinformacionClient<tablasinformacionGetPayload<T>>

    /**
     * Find zero or more Tablasinformacions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tablasinformacionFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tablasinformacions
     * const tablasinformacions = await prisma.tablasinformacion.findMany()
     * 
     * // Get first 10 Tablasinformacions
     * const tablasinformacions = await prisma.tablasinformacion.findMany({ take: 10 })
     * 
     * // Only select the `IDTabla`
     * const tablasinformacionWithIDTablaOnly = await prisma.tablasinformacion.findMany({ select: { IDTabla: true } })
     * 
    **/
    findMany<T extends tablasinformacionFindManyArgs>(
      args?: SelectSubset<T, tablasinformacionFindManyArgs>
    ): PrismaPromise<Array<tablasinformacionGetPayload<T>>>

    /**
     * Create a Tablasinformacion.
     * @param {tablasinformacionCreateArgs} args - Arguments to create a Tablasinformacion.
     * @example
     * // Create one Tablasinformacion
     * const Tablasinformacion = await prisma.tablasinformacion.create({
     *   data: {
     *     // ... data to create a Tablasinformacion
     *   }
     * })
     * 
    **/
    create<T extends tablasinformacionCreateArgs>(
      args: SelectSubset<T, tablasinformacionCreateArgs>
    ): Prisma__tablasinformacionClient<tablasinformacionGetPayload<T>>

    /**
     * Create many Tablasinformacions.
     *     @param {tablasinformacionCreateManyArgs} args - Arguments to create many Tablasinformacions.
     *     @example
     *     // Create many Tablasinformacions
     *     const tablasinformacion = await prisma.tablasinformacion.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends tablasinformacionCreateManyArgs>(
      args?: SelectSubset<T, tablasinformacionCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Tablasinformacion.
     * @param {tablasinformacionDeleteArgs} args - Arguments to delete one Tablasinformacion.
     * @example
     * // Delete one Tablasinformacion
     * const Tablasinformacion = await prisma.tablasinformacion.delete({
     *   where: {
     *     // ... filter to delete one Tablasinformacion
     *   }
     * })
     * 
    **/
    delete<T extends tablasinformacionDeleteArgs>(
      args: SelectSubset<T, tablasinformacionDeleteArgs>
    ): Prisma__tablasinformacionClient<tablasinformacionGetPayload<T>>

    /**
     * Update one Tablasinformacion.
     * @param {tablasinformacionUpdateArgs} args - Arguments to update one Tablasinformacion.
     * @example
     * // Update one Tablasinformacion
     * const tablasinformacion = await prisma.tablasinformacion.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends tablasinformacionUpdateArgs>(
      args: SelectSubset<T, tablasinformacionUpdateArgs>
    ): Prisma__tablasinformacionClient<tablasinformacionGetPayload<T>>

    /**
     * Delete zero or more Tablasinformacions.
     * @param {tablasinformacionDeleteManyArgs} args - Arguments to filter Tablasinformacions to delete.
     * @example
     * // Delete a few Tablasinformacions
     * const { count } = await prisma.tablasinformacion.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends tablasinformacionDeleteManyArgs>(
      args?: SelectSubset<T, tablasinformacionDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tablasinformacions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tablasinformacionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tablasinformacions
     * const tablasinformacion = await prisma.tablasinformacion.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends tablasinformacionUpdateManyArgs>(
      args: SelectSubset<T, tablasinformacionUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Tablasinformacion.
     * @param {tablasinformacionUpsertArgs} args - Arguments to update or create a Tablasinformacion.
     * @example
     * // Update or create a Tablasinformacion
     * const tablasinformacion = await prisma.tablasinformacion.upsert({
     *   create: {
     *     // ... data to create a Tablasinformacion
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tablasinformacion we want to update
     *   }
     * })
    **/
    upsert<T extends tablasinformacionUpsertArgs>(
      args: SelectSubset<T, tablasinformacionUpsertArgs>
    ): Prisma__tablasinformacionClient<tablasinformacionGetPayload<T>>

    /**
     * Count the number of Tablasinformacions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tablasinformacionCountArgs} args - Arguments to filter Tablasinformacions to count.
     * @example
     * // Count the number of Tablasinformacions
     * const count = await prisma.tablasinformacion.count({
     *   where: {
     *     // ... the filter for the Tablasinformacions we want to count
     *   }
     * })
    **/
    count<T extends tablasinformacionCountArgs>(
      args?: Subset<T, tablasinformacionCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TablasinformacionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tablasinformacion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TablasinformacionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TablasinformacionAggregateArgs>(args: Subset<T, TablasinformacionAggregateArgs>): PrismaPromise<GetTablasinformacionAggregateType<T>>

    /**
     * Group by Tablasinformacion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TablasinformacionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TablasinformacionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TablasinformacionGroupByArgs['orderBy'] }
        : { orderBy?: TablasinformacionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TablasinformacionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTablasinformacionGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for tablasinformacion.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__tablasinformacionClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * tablasinformacion base type for findUnique actions
   */
  export type tablasinformacionFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the tablasinformacion
     * 
    **/
    select?: tablasinformacionSelect | null
    /**
     * Filter, which tablasinformacion to fetch.
     * 
    **/
    where: tablasinformacionWhereUniqueInput
  }

  /**
   * tablasinformacion: findUnique
   */
  export interface tablasinformacionFindUniqueArgs extends tablasinformacionFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * tablasinformacion findUniqueOrThrow
   */
  export type tablasinformacionFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the tablasinformacion
     * 
    **/
    select?: tablasinformacionSelect | null
    /**
     * Filter, which tablasinformacion to fetch.
     * 
    **/
    where: tablasinformacionWhereUniqueInput
  }


  /**
   * tablasinformacion base type for findFirst actions
   */
  export type tablasinformacionFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the tablasinformacion
     * 
    **/
    select?: tablasinformacionSelect | null
    /**
     * Filter, which tablasinformacion to fetch.
     * 
    **/
    where?: tablasinformacionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tablasinformacions to fetch.
     * 
    **/
    orderBy?: Enumerable<tablasinformacionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tablasinformacions.
     * 
    **/
    cursor?: tablasinformacionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tablasinformacions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tablasinformacions.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tablasinformacions.
     * 
    **/
    distinct?: Enumerable<TablasinformacionScalarFieldEnum>
  }

  /**
   * tablasinformacion: findFirst
   */
  export interface tablasinformacionFindFirstArgs extends tablasinformacionFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * tablasinformacion findFirstOrThrow
   */
  export type tablasinformacionFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the tablasinformacion
     * 
    **/
    select?: tablasinformacionSelect | null
    /**
     * Filter, which tablasinformacion to fetch.
     * 
    **/
    where?: tablasinformacionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tablasinformacions to fetch.
     * 
    **/
    orderBy?: Enumerable<tablasinformacionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tablasinformacions.
     * 
    **/
    cursor?: tablasinformacionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tablasinformacions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tablasinformacions.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tablasinformacions.
     * 
    **/
    distinct?: Enumerable<TablasinformacionScalarFieldEnum>
  }


  /**
   * tablasinformacion findMany
   */
  export type tablasinformacionFindManyArgs = {
    /**
     * Select specific fields to fetch from the tablasinformacion
     * 
    **/
    select?: tablasinformacionSelect | null
    /**
     * Filter, which tablasinformacions to fetch.
     * 
    **/
    where?: tablasinformacionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tablasinformacions to fetch.
     * 
    **/
    orderBy?: Enumerable<tablasinformacionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing tablasinformacions.
     * 
    **/
    cursor?: tablasinformacionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tablasinformacions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tablasinformacions.
     * 
    **/
    skip?: number
    distinct?: Enumerable<TablasinformacionScalarFieldEnum>
  }


  /**
   * tablasinformacion create
   */
  export type tablasinformacionCreateArgs = {
    /**
     * Select specific fields to fetch from the tablasinformacion
     * 
    **/
    select?: tablasinformacionSelect | null
    /**
     * The data needed to create a tablasinformacion.
     * 
    **/
    data: XOR<tablasinformacionCreateInput, tablasinformacionUncheckedCreateInput>
  }


  /**
   * tablasinformacion createMany
   */
  export type tablasinformacionCreateManyArgs = {
    /**
     * The data used to create many tablasinformacions.
     * 
    **/
    data: Enumerable<tablasinformacionCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * tablasinformacion update
   */
  export type tablasinformacionUpdateArgs = {
    /**
     * Select specific fields to fetch from the tablasinformacion
     * 
    **/
    select?: tablasinformacionSelect | null
    /**
     * The data needed to update a tablasinformacion.
     * 
    **/
    data: XOR<tablasinformacionUpdateInput, tablasinformacionUncheckedUpdateInput>
    /**
     * Choose, which tablasinformacion to update.
     * 
    **/
    where: tablasinformacionWhereUniqueInput
  }


  /**
   * tablasinformacion updateMany
   */
  export type tablasinformacionUpdateManyArgs = {
    /**
     * The data used to update tablasinformacions.
     * 
    **/
    data: XOR<tablasinformacionUpdateManyMutationInput, tablasinformacionUncheckedUpdateManyInput>
    /**
     * Filter which tablasinformacions to update
     * 
    **/
    where?: tablasinformacionWhereInput
  }


  /**
   * tablasinformacion upsert
   */
  export type tablasinformacionUpsertArgs = {
    /**
     * Select specific fields to fetch from the tablasinformacion
     * 
    **/
    select?: tablasinformacionSelect | null
    /**
     * The filter to search for the tablasinformacion to update in case it exists.
     * 
    **/
    where: tablasinformacionWhereUniqueInput
    /**
     * In case the tablasinformacion found by the `where` argument doesn't exist, create a new tablasinformacion with this data.
     * 
    **/
    create: XOR<tablasinformacionCreateInput, tablasinformacionUncheckedCreateInput>
    /**
     * In case the tablasinformacion was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<tablasinformacionUpdateInput, tablasinformacionUncheckedUpdateInput>
  }


  /**
   * tablasinformacion delete
   */
  export type tablasinformacionDeleteArgs = {
    /**
     * Select specific fields to fetch from the tablasinformacion
     * 
    **/
    select?: tablasinformacionSelect | null
    /**
     * Filter which tablasinformacion to delete.
     * 
    **/
    where: tablasinformacionWhereUniqueInput
  }


  /**
   * tablasinformacion deleteMany
   */
  export type tablasinformacionDeleteManyArgs = {
    /**
     * Filter which tablasinformacions to delete
     * 
    **/
    where?: tablasinformacionWhereInput
  }


  /**
   * tablasinformacion without action
   */
  export type tablasinformacionArgs = {
    /**
     * Select specific fields to fetch from the tablasinformacion
     * 
    **/
    select?: tablasinformacionSelect | null
  }



  /**
   * Model tecnologiasnetsocs
   */


  export type AggregateTecnologiasnetsocs = {
    _count: TecnologiasnetsocsCountAggregateOutputType | null
    _avg: TecnologiasnetsocsAvgAggregateOutputType | null
    _sum: TecnologiasnetsocsSumAggregateOutputType | null
    _min: TecnologiasnetsocsMinAggregateOutputType | null
    _max: TecnologiasnetsocsMaxAggregateOutputType | null
  }

  export type TecnologiasnetsocsAvgAggregateOutputType = {
    IDTecnologiaGateway: number | null
  }

  export type TecnologiasnetsocsSumAggregateOutputType = {
    IDTecnologiaGateway: number | null
  }

  export type TecnologiasnetsocsMinAggregateOutputType = {
    IDTecnologiaGateway: number | null
    NombreTecnologiaGateway: string | null
  }

  export type TecnologiasnetsocsMaxAggregateOutputType = {
    IDTecnologiaGateway: number | null
    NombreTecnologiaGateway: string | null
  }

  export type TecnologiasnetsocsCountAggregateOutputType = {
    IDTecnologiaGateway: number
    NombreTecnologiaGateway: number
    _all: number
  }


  export type TecnologiasnetsocsAvgAggregateInputType = {
    IDTecnologiaGateway?: true
  }

  export type TecnologiasnetsocsSumAggregateInputType = {
    IDTecnologiaGateway?: true
  }

  export type TecnologiasnetsocsMinAggregateInputType = {
    IDTecnologiaGateway?: true
    NombreTecnologiaGateway?: true
  }

  export type TecnologiasnetsocsMaxAggregateInputType = {
    IDTecnologiaGateway?: true
    NombreTecnologiaGateway?: true
  }

  export type TecnologiasnetsocsCountAggregateInputType = {
    IDTecnologiaGateway?: true
    NombreTecnologiaGateway?: true
    _all?: true
  }

  export type TecnologiasnetsocsAggregateArgs = {
    /**
     * Filter which tecnologiasnetsocs to aggregate.
     * 
    **/
    where?: tecnologiasnetsocsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tecnologiasnetsocs to fetch.
     * 
    **/
    orderBy?: Enumerable<tecnologiasnetsocsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: tecnologiasnetsocsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tecnologiasnetsocs from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tecnologiasnetsocs.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned tecnologiasnetsocs
    **/
    _count?: true | TecnologiasnetsocsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TecnologiasnetsocsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TecnologiasnetsocsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TecnologiasnetsocsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TecnologiasnetsocsMaxAggregateInputType
  }

  export type GetTecnologiasnetsocsAggregateType<T extends TecnologiasnetsocsAggregateArgs> = {
        [P in keyof T & keyof AggregateTecnologiasnetsocs]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTecnologiasnetsocs[P]>
      : GetScalarType<T[P], AggregateTecnologiasnetsocs[P]>
  }




  export type TecnologiasnetsocsGroupByArgs = {
    where?: tecnologiasnetsocsWhereInput
    orderBy?: Enumerable<tecnologiasnetsocsOrderByWithAggregationInput>
    by: Array<TecnologiasnetsocsScalarFieldEnum>
    having?: tecnologiasnetsocsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TecnologiasnetsocsCountAggregateInputType | true
    _avg?: TecnologiasnetsocsAvgAggregateInputType
    _sum?: TecnologiasnetsocsSumAggregateInputType
    _min?: TecnologiasnetsocsMinAggregateInputType
    _max?: TecnologiasnetsocsMaxAggregateInputType
  }


  export type TecnologiasnetsocsGroupByOutputType = {
    IDTecnologiaGateway: number
    NombreTecnologiaGateway: string | null
    _count: TecnologiasnetsocsCountAggregateOutputType | null
    _avg: TecnologiasnetsocsAvgAggregateOutputType | null
    _sum: TecnologiasnetsocsSumAggregateOutputType | null
    _min: TecnologiasnetsocsMinAggregateOutputType | null
    _max: TecnologiasnetsocsMaxAggregateOutputType | null
  }

  type GetTecnologiasnetsocsGroupByPayload<T extends TecnologiasnetsocsGroupByArgs> = PrismaPromise<
    Array<
      PickArray<TecnologiasnetsocsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TecnologiasnetsocsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TecnologiasnetsocsGroupByOutputType[P]>
            : GetScalarType<T[P], TecnologiasnetsocsGroupByOutputType[P]>
        }
      >
    >


  export type tecnologiasnetsocsSelect = {
    IDTecnologiaGateway?: boolean
    NombreTecnologiaGateway?: boolean
  }


  export type tecnologiasnetsocsGetPayload<S extends boolean | null | undefined | tecnologiasnetsocsArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? tecnologiasnetsocs :
    S extends undefined ? never :
    S extends { include: any } & (tecnologiasnetsocsArgs | tecnologiasnetsocsFindManyArgs)
    ? tecnologiasnetsocs 
    : S extends { select: any } & (tecnologiasnetsocsArgs | tecnologiasnetsocsFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof tecnologiasnetsocs ? tecnologiasnetsocs[P] : never
  } 
      : tecnologiasnetsocs


  type tecnologiasnetsocsCountArgs = Merge<
    Omit<tecnologiasnetsocsFindManyArgs, 'select' | 'include'> & {
      select?: TecnologiasnetsocsCountAggregateInputType | true
    }
  >

  export interface tecnologiasnetsocsDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Tecnologiasnetsocs that matches the filter.
     * @param {tecnologiasnetsocsFindUniqueArgs} args - Arguments to find a Tecnologiasnetsocs
     * @example
     * // Get one Tecnologiasnetsocs
     * const tecnologiasnetsocs = await prisma.tecnologiasnetsocs.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends tecnologiasnetsocsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, tecnologiasnetsocsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'tecnologiasnetsocs'> extends True ? Prisma__tecnologiasnetsocsClient<tecnologiasnetsocsGetPayload<T>> : Prisma__tecnologiasnetsocsClient<tecnologiasnetsocsGetPayload<T> | null, null>

    /**
     * Find one Tecnologiasnetsocs that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {tecnologiasnetsocsFindUniqueOrThrowArgs} args - Arguments to find a Tecnologiasnetsocs
     * @example
     * // Get one Tecnologiasnetsocs
     * const tecnologiasnetsocs = await prisma.tecnologiasnetsocs.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends tecnologiasnetsocsFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, tecnologiasnetsocsFindUniqueOrThrowArgs>
    ): Prisma__tecnologiasnetsocsClient<tecnologiasnetsocsGetPayload<T>>

    /**
     * Find the first Tecnologiasnetsocs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tecnologiasnetsocsFindFirstArgs} args - Arguments to find a Tecnologiasnetsocs
     * @example
     * // Get one Tecnologiasnetsocs
     * const tecnologiasnetsocs = await prisma.tecnologiasnetsocs.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends tecnologiasnetsocsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, tecnologiasnetsocsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'tecnologiasnetsocs'> extends True ? Prisma__tecnologiasnetsocsClient<tecnologiasnetsocsGetPayload<T>> : Prisma__tecnologiasnetsocsClient<tecnologiasnetsocsGetPayload<T> | null, null>

    /**
     * Find the first Tecnologiasnetsocs that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tecnologiasnetsocsFindFirstOrThrowArgs} args - Arguments to find a Tecnologiasnetsocs
     * @example
     * // Get one Tecnologiasnetsocs
     * const tecnologiasnetsocs = await prisma.tecnologiasnetsocs.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends tecnologiasnetsocsFindFirstOrThrowArgs>(
      args?: SelectSubset<T, tecnologiasnetsocsFindFirstOrThrowArgs>
    ): Prisma__tecnologiasnetsocsClient<tecnologiasnetsocsGetPayload<T>>

    /**
     * Find zero or more Tecnologiasnetsocs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tecnologiasnetsocsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tecnologiasnetsocs
     * const tecnologiasnetsocs = await prisma.tecnologiasnetsocs.findMany()
     * 
     * // Get first 10 Tecnologiasnetsocs
     * const tecnologiasnetsocs = await prisma.tecnologiasnetsocs.findMany({ take: 10 })
     * 
     * // Only select the `IDTecnologiaGateway`
     * const tecnologiasnetsocsWithIDTecnologiaGatewayOnly = await prisma.tecnologiasnetsocs.findMany({ select: { IDTecnologiaGateway: true } })
     * 
    **/
    findMany<T extends tecnologiasnetsocsFindManyArgs>(
      args?: SelectSubset<T, tecnologiasnetsocsFindManyArgs>
    ): PrismaPromise<Array<tecnologiasnetsocsGetPayload<T>>>

    /**
     * Create a Tecnologiasnetsocs.
     * @param {tecnologiasnetsocsCreateArgs} args - Arguments to create a Tecnologiasnetsocs.
     * @example
     * // Create one Tecnologiasnetsocs
     * const Tecnologiasnetsocs = await prisma.tecnologiasnetsocs.create({
     *   data: {
     *     // ... data to create a Tecnologiasnetsocs
     *   }
     * })
     * 
    **/
    create<T extends tecnologiasnetsocsCreateArgs>(
      args: SelectSubset<T, tecnologiasnetsocsCreateArgs>
    ): Prisma__tecnologiasnetsocsClient<tecnologiasnetsocsGetPayload<T>>

    /**
     * Create many Tecnologiasnetsocs.
     *     @param {tecnologiasnetsocsCreateManyArgs} args - Arguments to create many Tecnologiasnetsocs.
     *     @example
     *     // Create many Tecnologiasnetsocs
     *     const tecnologiasnetsocs = await prisma.tecnologiasnetsocs.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends tecnologiasnetsocsCreateManyArgs>(
      args?: SelectSubset<T, tecnologiasnetsocsCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Tecnologiasnetsocs.
     * @param {tecnologiasnetsocsDeleteArgs} args - Arguments to delete one Tecnologiasnetsocs.
     * @example
     * // Delete one Tecnologiasnetsocs
     * const Tecnologiasnetsocs = await prisma.tecnologiasnetsocs.delete({
     *   where: {
     *     // ... filter to delete one Tecnologiasnetsocs
     *   }
     * })
     * 
    **/
    delete<T extends tecnologiasnetsocsDeleteArgs>(
      args: SelectSubset<T, tecnologiasnetsocsDeleteArgs>
    ): Prisma__tecnologiasnetsocsClient<tecnologiasnetsocsGetPayload<T>>

    /**
     * Update one Tecnologiasnetsocs.
     * @param {tecnologiasnetsocsUpdateArgs} args - Arguments to update one Tecnologiasnetsocs.
     * @example
     * // Update one Tecnologiasnetsocs
     * const tecnologiasnetsocs = await prisma.tecnologiasnetsocs.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends tecnologiasnetsocsUpdateArgs>(
      args: SelectSubset<T, tecnologiasnetsocsUpdateArgs>
    ): Prisma__tecnologiasnetsocsClient<tecnologiasnetsocsGetPayload<T>>

    /**
     * Delete zero or more Tecnologiasnetsocs.
     * @param {tecnologiasnetsocsDeleteManyArgs} args - Arguments to filter Tecnologiasnetsocs to delete.
     * @example
     * // Delete a few Tecnologiasnetsocs
     * const { count } = await prisma.tecnologiasnetsocs.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends tecnologiasnetsocsDeleteManyArgs>(
      args?: SelectSubset<T, tecnologiasnetsocsDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tecnologiasnetsocs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tecnologiasnetsocsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tecnologiasnetsocs
     * const tecnologiasnetsocs = await prisma.tecnologiasnetsocs.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends tecnologiasnetsocsUpdateManyArgs>(
      args: SelectSubset<T, tecnologiasnetsocsUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Tecnologiasnetsocs.
     * @param {tecnologiasnetsocsUpsertArgs} args - Arguments to update or create a Tecnologiasnetsocs.
     * @example
     * // Update or create a Tecnologiasnetsocs
     * const tecnologiasnetsocs = await prisma.tecnologiasnetsocs.upsert({
     *   create: {
     *     // ... data to create a Tecnologiasnetsocs
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tecnologiasnetsocs we want to update
     *   }
     * })
    **/
    upsert<T extends tecnologiasnetsocsUpsertArgs>(
      args: SelectSubset<T, tecnologiasnetsocsUpsertArgs>
    ): Prisma__tecnologiasnetsocsClient<tecnologiasnetsocsGetPayload<T>>

    /**
     * Count the number of Tecnologiasnetsocs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tecnologiasnetsocsCountArgs} args - Arguments to filter Tecnologiasnetsocs to count.
     * @example
     * // Count the number of Tecnologiasnetsocs
     * const count = await prisma.tecnologiasnetsocs.count({
     *   where: {
     *     // ... the filter for the Tecnologiasnetsocs we want to count
     *   }
     * })
    **/
    count<T extends tecnologiasnetsocsCountArgs>(
      args?: Subset<T, tecnologiasnetsocsCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TecnologiasnetsocsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tecnologiasnetsocs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TecnologiasnetsocsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TecnologiasnetsocsAggregateArgs>(args: Subset<T, TecnologiasnetsocsAggregateArgs>): PrismaPromise<GetTecnologiasnetsocsAggregateType<T>>

    /**
     * Group by Tecnologiasnetsocs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TecnologiasnetsocsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TecnologiasnetsocsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TecnologiasnetsocsGroupByArgs['orderBy'] }
        : { orderBy?: TecnologiasnetsocsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TecnologiasnetsocsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTecnologiasnetsocsGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for tecnologiasnetsocs.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__tecnologiasnetsocsClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * tecnologiasnetsocs base type for findUnique actions
   */
  export type tecnologiasnetsocsFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the tecnologiasnetsocs
     * 
    **/
    select?: tecnologiasnetsocsSelect | null
    /**
     * Filter, which tecnologiasnetsocs to fetch.
     * 
    **/
    where: tecnologiasnetsocsWhereUniqueInput
  }

  /**
   * tecnologiasnetsocs: findUnique
   */
  export interface tecnologiasnetsocsFindUniqueArgs extends tecnologiasnetsocsFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * tecnologiasnetsocs findUniqueOrThrow
   */
  export type tecnologiasnetsocsFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the tecnologiasnetsocs
     * 
    **/
    select?: tecnologiasnetsocsSelect | null
    /**
     * Filter, which tecnologiasnetsocs to fetch.
     * 
    **/
    where: tecnologiasnetsocsWhereUniqueInput
  }


  /**
   * tecnologiasnetsocs base type for findFirst actions
   */
  export type tecnologiasnetsocsFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the tecnologiasnetsocs
     * 
    **/
    select?: tecnologiasnetsocsSelect | null
    /**
     * Filter, which tecnologiasnetsocs to fetch.
     * 
    **/
    where?: tecnologiasnetsocsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tecnologiasnetsocs to fetch.
     * 
    **/
    orderBy?: Enumerable<tecnologiasnetsocsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tecnologiasnetsocs.
     * 
    **/
    cursor?: tecnologiasnetsocsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tecnologiasnetsocs from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tecnologiasnetsocs.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tecnologiasnetsocs.
     * 
    **/
    distinct?: Enumerable<TecnologiasnetsocsScalarFieldEnum>
  }

  /**
   * tecnologiasnetsocs: findFirst
   */
  export interface tecnologiasnetsocsFindFirstArgs extends tecnologiasnetsocsFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * tecnologiasnetsocs findFirstOrThrow
   */
  export type tecnologiasnetsocsFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the tecnologiasnetsocs
     * 
    **/
    select?: tecnologiasnetsocsSelect | null
    /**
     * Filter, which tecnologiasnetsocs to fetch.
     * 
    **/
    where?: tecnologiasnetsocsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tecnologiasnetsocs to fetch.
     * 
    **/
    orderBy?: Enumerable<tecnologiasnetsocsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tecnologiasnetsocs.
     * 
    **/
    cursor?: tecnologiasnetsocsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tecnologiasnetsocs from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tecnologiasnetsocs.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tecnologiasnetsocs.
     * 
    **/
    distinct?: Enumerable<TecnologiasnetsocsScalarFieldEnum>
  }


  /**
   * tecnologiasnetsocs findMany
   */
  export type tecnologiasnetsocsFindManyArgs = {
    /**
     * Select specific fields to fetch from the tecnologiasnetsocs
     * 
    **/
    select?: tecnologiasnetsocsSelect | null
    /**
     * Filter, which tecnologiasnetsocs to fetch.
     * 
    **/
    where?: tecnologiasnetsocsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tecnologiasnetsocs to fetch.
     * 
    **/
    orderBy?: Enumerable<tecnologiasnetsocsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing tecnologiasnetsocs.
     * 
    **/
    cursor?: tecnologiasnetsocsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tecnologiasnetsocs from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tecnologiasnetsocs.
     * 
    **/
    skip?: number
    distinct?: Enumerable<TecnologiasnetsocsScalarFieldEnum>
  }


  /**
   * tecnologiasnetsocs create
   */
  export type tecnologiasnetsocsCreateArgs = {
    /**
     * Select specific fields to fetch from the tecnologiasnetsocs
     * 
    **/
    select?: tecnologiasnetsocsSelect | null
    /**
     * The data needed to create a tecnologiasnetsocs.
     * 
    **/
    data: XOR<tecnologiasnetsocsCreateInput, tecnologiasnetsocsUncheckedCreateInput>
  }


  /**
   * tecnologiasnetsocs createMany
   */
  export type tecnologiasnetsocsCreateManyArgs = {
    /**
     * The data used to create many tecnologiasnetsocs.
     * 
    **/
    data: Enumerable<tecnologiasnetsocsCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * tecnologiasnetsocs update
   */
  export type tecnologiasnetsocsUpdateArgs = {
    /**
     * Select specific fields to fetch from the tecnologiasnetsocs
     * 
    **/
    select?: tecnologiasnetsocsSelect | null
    /**
     * The data needed to update a tecnologiasnetsocs.
     * 
    **/
    data: XOR<tecnologiasnetsocsUpdateInput, tecnologiasnetsocsUncheckedUpdateInput>
    /**
     * Choose, which tecnologiasnetsocs to update.
     * 
    **/
    where: tecnologiasnetsocsWhereUniqueInput
  }


  /**
   * tecnologiasnetsocs updateMany
   */
  export type tecnologiasnetsocsUpdateManyArgs = {
    /**
     * The data used to update tecnologiasnetsocs.
     * 
    **/
    data: XOR<tecnologiasnetsocsUpdateManyMutationInput, tecnologiasnetsocsUncheckedUpdateManyInput>
    /**
     * Filter which tecnologiasnetsocs to update
     * 
    **/
    where?: tecnologiasnetsocsWhereInput
  }


  /**
   * tecnologiasnetsocs upsert
   */
  export type tecnologiasnetsocsUpsertArgs = {
    /**
     * Select specific fields to fetch from the tecnologiasnetsocs
     * 
    **/
    select?: tecnologiasnetsocsSelect | null
    /**
     * The filter to search for the tecnologiasnetsocs to update in case it exists.
     * 
    **/
    where: tecnologiasnetsocsWhereUniqueInput
    /**
     * In case the tecnologiasnetsocs found by the `where` argument doesn't exist, create a new tecnologiasnetsocs with this data.
     * 
    **/
    create: XOR<tecnologiasnetsocsCreateInput, tecnologiasnetsocsUncheckedCreateInput>
    /**
     * In case the tecnologiasnetsocs was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<tecnologiasnetsocsUpdateInput, tecnologiasnetsocsUncheckedUpdateInput>
  }


  /**
   * tecnologiasnetsocs delete
   */
  export type tecnologiasnetsocsDeleteArgs = {
    /**
     * Select specific fields to fetch from the tecnologiasnetsocs
     * 
    **/
    select?: tecnologiasnetsocsSelect | null
    /**
     * Filter which tecnologiasnetsocs to delete.
     * 
    **/
    where: tecnologiasnetsocsWhereUniqueInput
  }


  /**
   * tecnologiasnetsocs deleteMany
   */
  export type tecnologiasnetsocsDeleteManyArgs = {
    /**
     * Filter which tecnologiasnetsocs to delete
     * 
    **/
    where?: tecnologiasnetsocsWhereInput
  }


  /**
   * tecnologiasnetsocs without action
   */
  export type tecnologiasnetsocsArgs = {
    /**
     * Select specific fields to fetch from the tecnologiasnetsocs
     * 
    **/
    select?: tecnologiasnetsocsSelect | null
  }



  /**
   * Enums
   */

  // Based on
  // https://github.com/microsoft/TypeScript/issues/3192#issuecomment-261720275

  export const ControladoresScalarFieldEnum: {
    IDControlador: 'IDControlador',
    IDEdificio: 'IDEdificio',
    NombreControlador: 'NombreControlador',
    Descripcion: 'Descripcion',
    IDIcono: 'IDIcono',
    TipoControlador: 'TipoControlador',
    Prioridad: 'Prioridad',
    Certificado: 'Certificado',
    PuertoSSL: 'PuertoSSL',
    PuertoNoSSL: 'PuertoNoSSL',
    PuertoMantenimiento: 'PuertoMantenimiento',
    PuertoConexionSC: 'PuertoConexionSC',
    PuertoConexionCC: 'PuertoConexionCC',
    SOAP: 'SOAP',
    Socket: 'Socket',
    API: 'API',
    Sincroniza: 'Sincroniza',
    DireccionAIPV4: 'DireccionAIPV4',
    DireccionBIPv4: 'DireccionBIPv4',
    DireccionAIPV6: 'DireccionAIPV6',
    DireccionBIPv6: 'DireccionBIPv6',
    DireccionPublica1: 'DireccionPublica1',
    DireccionPublica2: 'DireccionPublica2',
    Localizacion: 'Localizacion',
    Latitud: 'Latitud',
    Longitud: 'Longitud',
    Estatus: 'Estatus',
    FechaCreado: 'FechaCreado',
    FechaDesactivado: 'FechaDesactivado'
  };

  export type ControladoresScalarFieldEnum = (typeof ControladoresScalarFieldEnum)[keyof typeof ControladoresScalarFieldEnum]


  export const DispositivosScalarFieldEnum: {
    IDDispositivo: 'IDDispositivo',
    IDSubsistema: 'IDSubsistema',
    IDTipoFamilia: 'IDTipoFamilia',
    IDFamilia: 'IDFamilia',
    IDFabricante: 'IDFabricante',
    IDTipoDispositivo: 'IDTipoDispositivo',
    IDGateway: 'IDGateway',
    IDControlador: 'IDControlador',
    IDModelo: 'IDModelo',
    IDEdificio: 'IDEdificio',
    IDZona: 'IDZona',
    IDPuerta: 'IDPuerta',
    NombreDispositivo: 'NombreDispositivo',
    Descripcion: 'Descripcion',
    IDIconografia: 'IDIconografia',
    IDMenuPropio: 'IDMenuPropio',
    Estatus: 'Estatus',
    Sentidos: 'Sentidos',
    Ignorado: 'Ignorado',
    Enrolamiento: 'Enrolamiento',
    Latitud: 'Latitud',
    Longitud: 'Longitud',
    DireccionGPS: 'DireccionGPS',
    GeometriaGPS: 'GeometriaGPS',
    IDTipoEvento: 'IDTipoEvento',
    IDModeloElemento: 'IDModeloElemento',
    FechaCreacion: 'FechaCreacion',
    FechaDesactivacion: 'FechaDesactivacion',
    FechaEliminacion: 'FechaEliminacion',
    Parametros: 'Parametros',
    Certificado: 'Certificado',
    PuertoSSL: 'PuertoSSL',
    PuertoNoSSL: 'PuertoNoSSL',
    PuertoMantenimiento: 'PuertoMantenimiento',
    PuertoConexionSC: 'PuertoConexionSC',
    PuertoConexionCC: 'PuertoConexionCC',
    SOAP: 'SOAP',
    Socket: 'Socket',
    API: 'API',
    Sincroniza: 'Sincroniza',
    DireccionAIPV4: 'DireccionAIPV4',
    DireccionBIPv4: 'DireccionBIPv4',
    DireccionAIPV6: 'DireccionAIPV6',
    DireccionBIPv6: 'DireccionBIPv6',
    DireccionPublica1: 'DireccionPublica1',
    DireccionPublica2: 'DireccionPublica2',
    Serial: 'Serial',
    user: 'user',
    password: 'password',
    IDManual: 'IDManual',
    Directo: 'Directo'
  };

  export type DispositivosScalarFieldEnum = (typeof DispositivosScalarFieldEnum)[keyof typeof DispositivosScalarFieldEnum]


  export const GatewayScalarFieldEnum: {
    IDGateway: 'IDGateway',
    IDTipoGateway: 'IDTipoGateway',
    IDControlador: 'IDControlador',
    IDEdificio: 'IDEdificio',
    IDIdentificadorExterno: 'IDIdentificadorExterno',
    IDTipoEvento: 'IDTipoEvento',
    IDGrupoMetodo: 'IDGrupoMetodo',
    NAbonado: 'NAbonado',
    NombreGateway: 'NombreGateway',
    Descripcion: 'Descripcion',
    IDIcono: 'IDIcono',
    ValorEstado: 'ValorEstado',
    Parametros: 'Parametros',
    EstadoOnOff: 'EstadoOnOff',
    Latitud: 'Latitud',
    Longitud: 'Longitud',
    SerialGPS: 'SerialGPS',
    GeometriaGPS: 'GeometriaGPS',
    FechaCreado: 'FechaCreado',
    FechaDesactivado: 'FechaDesactivado',
    Certificado: 'Certificado',
    PuertoSSL: 'PuertoSSL',
    PuertoNoSSL: 'PuertoNoSSL',
    PuertoMantenimiento: 'PuertoMantenimiento',
    PuertoConexionSC: 'PuertoConexionSC',
    PuertoConexionCC: 'PuertoConexionCC',
    SOAP: 'SOAP',
    Socket: 'Socket',
    API: 'API',
    Sincroniza: 'Sincroniza',
    DireccionAIPV4: 'DireccionAIPV4',
    DireccionBIPv4: 'DireccionBIPv4',
    DireccionAIPV6: 'DireccionAIPV6',
    DireccionBIPv6: 'DireccionBIPv6',
    DireccionPublica1: 'DireccionPublica1',
    DireccionPublica2: 'DireccionPublica2',
    user: 'user',
    password: 'password',
    Serial: 'Serial',
    IDManual: 'IDManual',
    IDZona: 'IDZona'
  };

  export type GatewayScalarFieldEnum = (typeof GatewayScalarFieldEnum)[keyof typeof GatewayScalarFieldEnum]


  export const GruposdispositivosScalarFieldEnum: {
    IDGrupoDispositivo: 'IDGrupoDispositivo',
    NombreGrupoDispositivo: 'NombreGrupoDispositivo',
    Identificador: 'Identificador',
    Descripcion: 'Descripcion'
  };

  export type GruposdispositivosScalarFieldEnum = (typeof GruposdispositivosScalarFieldEnum)[keyof typeof GruposdispositivosScalarFieldEnum]


  export const InventariocatastroScalarFieldEnum: {
    IDEntidadInventario: 'IDEntidadInventario',
    IDTipoEntidadInventario: 'IDTipoEntidadInventario',
    IDCategoriaEntidadInventario: 'IDCategoriaEntidadInventario',
    IDGateway: 'IDGateway',
    IDDispositivo: 'IDDispositivo',
    IDMetaEdificio: 'IDMetaEdificio',
    IDEdificio: 'IDEdificio',
    NombreEntidadInventario: 'NombreEntidadInventario',
    Descripcion: 'Descripcion',
    Latitud: 'Latitud',
    Longitud: 'Longitud',
    SerialGPS: 'SerialGPS',
    GeometriaGPS: 'GeometriaGPS',
    FechaAlta: 'FechaAlta',
    FechaBaja: 'FechaBaja'
  };

  export type InventariocatastroScalarFieldEnum = (typeof InventariocatastroScalarFieldEnum)[keyof typeof InventariocatastroScalarFieldEnum]


  export const LibreriasapisScalarFieldEnum: {
    IDLIBAPISDK: 'IDLIBAPISDK',
    Nombre: 'Nombre',
    Tipo: 'Tipo',
    Web: 'Web',
    Subsistema: 'Subsistema',
    Alcance: 'Alcance'
  };

  export type LibreriasapisScalarFieldEnum = (typeof LibreriasapisScalarFieldEnum)[keyof typeof LibreriasapisScalarFieldEnum]


  export const MetodogrupoScalarFieldEnum: {
    IDGrupoMetodo: 'IDGrupoMetodo',
    NombreGrupoMetodo: 'NombreGrupoMetodo',
    Corporacion: 'Corporacion',
    Departamento: 'Departamento',
    Edificio: 'Edificio',
    Itinerario: 'Itinerario',
    Empleado: 'Empleado',
    Modificable: 'Modificable',
    Descripcion: 'Descripcion',
    Tipo: 'Tipo',
    IDGrupoMetodoPadre: 'IDGrupoMetodoPadre',
    Identificador: 'Identificador',
    IdentificadorExterno: 'IdentificadorExterno'
  };

  export type MetodogrupoScalarFieldEnum = (typeof MetodogrupoScalarFieldEnum)[keyof typeof MetodogrupoScalarFieldEnum]


  export const MetodosScalarFieldEnum: {
    IDMetodo: 'IDMetodo',
    Indice: 'Indice',
    IDGrupoMetodo: 'IDGrupoMetodo',
    IDLibreria: 'IDLibreria',
    IDMetodoPadre: 'IDMetodoPadre',
    Clase: 'Clase',
    Tipo: 'Tipo',
    Propagable: 'Propagable',
    BlobsPropagable: 'BlobsPropagable',
    NParametros: 'NParametros',
    NParametrosBinarios: 'NParametrosBinarios',
    Basico: 'Basico',
    Estado: 'Estado',
    Descripcion: 'Descripcion',
    NombreMetodo: 'NombreMetodo',
    NombreFuncion: 'NombreFuncion',
    MetodoTrigger: 'MetodoTrigger',
    EnvioAplicacion: 'EnvioAplicacion',
    EjecucionLibre: 'EjecucionLibre'
  };

  export type MetodosScalarFieldEnum = (typeof MetodosScalarFieldEnum)[keyof typeof MetodosScalarFieldEnum]


  export const ObjetosplanimetriaScalarFieldEnum: {
    Id: 'Id',
    NombreObjeto: 'NombreObjeto',
    URLHost: 'URLHost',
    IpHost: 'IpHost',
    Puerto: 'Puerto',
    Usuario: 'Usuario',
    Clave: 'Clave'
  };

  export type ObjetosplanimetriaScalarFieldEnum = (typeof ObjetosplanimetriaScalarFieldEnum)[keyof typeof ObjetosplanimetriaScalarFieldEnum]


  export const ReldispositivodispositivoScalarFieldEnum: {
    IDRelDisDispositivo: 'IDRelDisDispositivo',
    IDDispositivoPadre: 'IDDispositivoPadre',
    IDDispositivoHijo: 'IDDispositivoHijo'
  };

  export type ReldispositivodispositivoScalarFieldEnum = (typeof ReldispositivodispositivoScalarFieldEnum)[keyof typeof ReldispositivodispositivoScalarFieldEnum]


  export const ReldispositivogatewayScalarFieldEnum: {
    IDRelDisGateway: 'IDRelDisGateway',
    IDDispositivo: 'IDDispositivo',
    IDGateway: 'IDGateway'
  };

  export type ReldispositivogatewayScalarFieldEnum = (typeof ReldispositivogatewayScalarFieldEnum)[keyof typeof ReldispositivogatewayScalarFieldEnum]


  export const ReldispositivogrupodispositivoScalarFieldEnum: {
    IDRelDisGrupoDis: 'IDRelDisGrupoDis',
    IDGrupo: 'IDGrupo',
    IDDispositivo: 'IDDispositivo'
  };

  export type ReldispositivogrupodispositivoScalarFieldEnum = (typeof ReldispositivogrupodispositivoScalarFieldEnum)[keyof typeof ReldispositivogrupodispositivoScalarFieldEnum]


  export const ReldispositivoperfildispositivoScalarFieldEnum: {
    IDRelDisPerfil: 'IDRelDisPerfil',
    IDDispositivo: 'IDDispositivo',
    IDPerfilDispositivo: 'IDPerfilDispositivo'
  };

  export type ReldispositivoperfildispositivoScalarFieldEnum = (typeof ReldispositivoperfildispositivoScalarFieldEnum)[keyof typeof ReldispositivoperfildispositivoScalarFieldEnum]


  export const ReldispositivoplantillaanalogicaScalarFieldEnum: {
    IDRelDisPlantillaAnaloga: 'IDRelDisPlantillaAnaloga',
    IDPlantillaAnalogica: 'IDPlantillaAnalogica',
    IDDispositivo: 'IDDispositivo',
    Formula: 'Formula',
    Version: 'Version'
  };

  export type ReldispositivoplantillaanalogicaScalarFieldEnum = (typeof ReldispositivoplantillaanalogicaScalarFieldEnum)[keyof typeof ReldispositivoplantillaanalogicaScalarFieldEnum]


  export const ReldispositivopuertaScalarFieldEnum: {
    IDRelDisPuerta: 'IDRelDisPuerta',
    IDDispositivo: 'IDDispositivo',
    IDPuerta: 'IDPuerta',
    IDTipoDispositivo: 'IDTipoDispositivo'
  };

  export type ReldispositivopuertaScalarFieldEnum = (typeof ReldispositivopuertaScalarFieldEnum)[keyof typeof ReldispositivopuertaScalarFieldEnum]


  export const ReldispositivosubsistemaScalarFieldEnum: {
    IDRelDisSubsistema: 'IDRelDisSubsistema',
    IDSubsistema: 'IDSubsistema',
    IDDispositivo: 'IDDispositivo'
  };

  export type ReldispositivosubsistemaScalarFieldEnum = (typeof ReldispositivosubsistemaScalarFieldEnum)[keyof typeof ReldispositivosubsistemaScalarFieldEnum]


  export const ReldispositivotipoeventoScalarFieldEnum: {
    IDRelDisTipoEvento: 'IDRelDisTipoEvento',
    IDDispositivo: 'IDDispositivo',
    ClaseEvento: 'ClaseEvento'
  };

  export type ReldispositivotipoeventoScalarFieldEnum = (typeof ReldispositivotipoeventoScalarFieldEnum)[keyof typeof ReldispositivotipoeventoScalarFieldEnum]


  export const ReldispositivozonaScalarFieldEnum: {
    IDRelDisZona: 'IDRelDisZona',
    IDDispositivo: 'IDDispositivo',
    IDZona: 'IDZona'
  };

  export type ReldispositivozonaScalarFieldEnum = (typeof ReldispositivozonaScalarFieldEnum)[keyof typeof ReldispositivozonaScalarFieldEnum]


  export const ReltipocontroladormetodoScalarFieldEnum: {
    IDTipoControlador: 'IDTipoControlador',
    IDMetodo: 'IDMetodo',
    RelTipoControladorMetodo: 'RelTipoControladorMetodo'
  };

  export type ReltipocontroladormetodoScalarFieldEnum = (typeof ReltipocontroladormetodoScalarFieldEnum)[keyof typeof ReltipocontroladormetodoScalarFieldEnum]


  export const ReltipodispositivoperfildispositivoScalarFieldEnum: {
    IDRelTipoDispPerfil: 'IDRelTipoDispPerfil',
    IDTipoDispositivo: 'IDTipoDispositivo',
    IDPerfilDispositivo: 'IDPerfilDispositivo'
  };

  export type ReltipodispositivoperfildispositivoScalarFieldEnum = (typeof ReltipodispositivoperfildispositivoScalarFieldEnum)[keyof typeof ReltipodispositivoperfildispositivoScalarFieldEnum]


  export const ReltipodispositivoperfileventoScalarFieldEnum: {
    IDRelTipoDisPerfilEvento: 'IDRelTipoDisPerfilEvento',
    IDTipoDispositivo: 'IDTipoDispositivo',
    IDPerfilEvento: 'IDPerfilEvento'
  };

  export type ReltipodispositivoperfileventoScalarFieldEnum = (typeof ReltipodispositivoperfileventoScalarFieldEnum)[keyof typeof ReltipodispositivoperfileventoScalarFieldEnum]


  export const ReltipodispositivotipotecnologiaScalarFieldEnum: {
    IDRelTipoDispTipoTec: 'IDRelTipoDispTipoTec',
    IDTipoDispositivo: 'IDTipoDispositivo',
    IDTipoTecnologia: 'IDTipoTecnologia'
  };

  export type ReltipodispositivotipotecnologiaScalarFieldEnum = (typeof ReltipodispositivotipotecnologiaScalarFieldEnum)[keyof typeof ReltipodispositivotipotecnologiaScalarFieldEnum]


  export const ReltipogatewayperfildispositivoScalarFieldEnum: {
    IDRelTipoGatewayPerfil: 'IDRelTipoGatewayPerfil',
    IDTipoGateway: 'IDTipoGateway',
    IDPerfilDispositivo: 'IDPerfilDispositivo'
  };

  export type ReltipogatewayperfildispositivoScalarFieldEnum = (typeof ReltipogatewayperfildispositivoScalarFieldEnum)[keyof typeof ReltipogatewayperfildispositivoScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const SubsistemasScalarFieldEnum: {
    IDSubSistema: 'IDSubSistema',
    NombreSubSistema: 'NombreSubSistema',
    DescripcionSubSistema: 'DescripcionSubSistema',
    URLSubSistema: 'URLSubSistema',
    Puerto: 'Puerto'
  };

  export type SubsistemasScalarFieldEnum = (typeof SubsistemasScalarFieldEnum)[keyof typeof SubsistemasScalarFieldEnum]


  export const TablasinformacionScalarFieldEnum: {
    IDTabla: 'IDTabla',
    NombreTabla: 'NombreTabla',
    Tipo: 'Tipo',
    Identidad: 'Identidad',
    CodigoNetsocs: 'CodigoNetsocs'
  };

  export type TablasinformacionScalarFieldEnum = (typeof TablasinformacionScalarFieldEnum)[keyof typeof TablasinformacionScalarFieldEnum]


  export const TecnologiasnetsocsScalarFieldEnum: {
    IDTecnologiaGateway: 'IDTecnologiaGateway',
    NombreTecnologiaGateway: 'NombreTecnologiaGateway'
  };

  export type TecnologiasnetsocsScalarFieldEnum = (typeof TecnologiasnetsocsScalarFieldEnum)[keyof typeof TecnologiasnetsocsScalarFieldEnum]


  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  /**
   * Deep Input Types
   */


  export type controladoresWhereInput = {
    AND?: Enumerable<controladoresWhereInput>
    OR?: Enumerable<controladoresWhereInput>
    NOT?: Enumerable<controladoresWhereInput>
    IDControlador?: IntFilter | number
    IDEdificio?: IntNullableFilter | number | null
    NombreControlador?: StringNullableFilter | string | null
    Descripcion?: StringNullableFilter | string | null
    IDIcono?: IntNullableFilter | number | null
    TipoControlador?: IntNullableFilter | number | null
    Prioridad?: StringNullableFilter | string | null
    Certificado?: StringNullableFilter | string | null
    PuertoSSL?: IntNullableFilter | number | null
    PuertoNoSSL?: IntNullableFilter | number | null
    PuertoMantenimiento?: IntNullableFilter | number | null
    PuertoConexionSC?: IntNullableFilter | number | null
    PuertoConexionCC?: IntNullableFilter | number | null
    SOAP?: StringNullableFilter | string | null
    Socket?: StringNullableFilter | string | null
    API?: StringNullableFilter | string | null
    Sincroniza?: StringNullableFilter | string | null
    DireccionAIPV4?: StringNullableFilter | string | null
    DireccionBIPv4?: StringNullableFilter | string | null
    DireccionAIPV6?: StringNullableFilter | string | null
    DireccionBIPv6?: StringNullableFilter | string | null
    DireccionPublica1?: StringNullableFilter | string | null
    DireccionPublica2?: StringNullableFilter | string | null
    Localizacion?: StringNullableFilter | string | null
    Latitud?: DecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
    Longitud?: DecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
    Estatus?: IntNullableFilter | number | null
    FechaCreado?: DateTimeNullableFilter | Date | string | null
    FechaDesactivado?: DateTimeNullableFilter | Date | string | null
  }

  export type controladoresOrderByWithRelationInput = {
    IDControlador?: SortOrder
    IDEdificio?: SortOrder
    NombreControlador?: SortOrder
    Descripcion?: SortOrder
    IDIcono?: SortOrder
    TipoControlador?: SortOrder
    Prioridad?: SortOrder
    Certificado?: SortOrder
    PuertoSSL?: SortOrder
    PuertoNoSSL?: SortOrder
    PuertoMantenimiento?: SortOrder
    PuertoConexionSC?: SortOrder
    PuertoConexionCC?: SortOrder
    SOAP?: SortOrder
    Socket?: SortOrder
    API?: SortOrder
    Sincroniza?: SortOrder
    DireccionAIPV4?: SortOrder
    DireccionBIPv4?: SortOrder
    DireccionAIPV6?: SortOrder
    DireccionBIPv6?: SortOrder
    DireccionPublica1?: SortOrder
    DireccionPublica2?: SortOrder
    Localizacion?: SortOrder
    Latitud?: SortOrder
    Longitud?: SortOrder
    Estatus?: SortOrder
    FechaCreado?: SortOrder
    FechaDesactivado?: SortOrder
  }

  export type controladoresWhereUniqueInput = {
    IDControlador?: number
  }

  export type controladoresOrderByWithAggregationInput = {
    IDControlador?: SortOrder
    IDEdificio?: SortOrder
    NombreControlador?: SortOrder
    Descripcion?: SortOrder
    IDIcono?: SortOrder
    TipoControlador?: SortOrder
    Prioridad?: SortOrder
    Certificado?: SortOrder
    PuertoSSL?: SortOrder
    PuertoNoSSL?: SortOrder
    PuertoMantenimiento?: SortOrder
    PuertoConexionSC?: SortOrder
    PuertoConexionCC?: SortOrder
    SOAP?: SortOrder
    Socket?: SortOrder
    API?: SortOrder
    Sincroniza?: SortOrder
    DireccionAIPV4?: SortOrder
    DireccionBIPv4?: SortOrder
    DireccionAIPV6?: SortOrder
    DireccionBIPv6?: SortOrder
    DireccionPublica1?: SortOrder
    DireccionPublica2?: SortOrder
    Localizacion?: SortOrder
    Latitud?: SortOrder
    Longitud?: SortOrder
    Estatus?: SortOrder
    FechaCreado?: SortOrder
    FechaDesactivado?: SortOrder
    _count?: controladoresCountOrderByAggregateInput
    _avg?: controladoresAvgOrderByAggregateInput
    _max?: controladoresMaxOrderByAggregateInput
    _min?: controladoresMinOrderByAggregateInput
    _sum?: controladoresSumOrderByAggregateInput
  }

  export type controladoresScalarWhereWithAggregatesInput = {
    AND?: Enumerable<controladoresScalarWhereWithAggregatesInput>
    OR?: Enumerable<controladoresScalarWhereWithAggregatesInput>
    NOT?: Enumerable<controladoresScalarWhereWithAggregatesInput>
    IDControlador?: IntWithAggregatesFilter | number
    IDEdificio?: IntNullableWithAggregatesFilter | number | null
    NombreControlador?: StringNullableWithAggregatesFilter | string | null
    Descripcion?: StringNullableWithAggregatesFilter | string | null
    IDIcono?: IntNullableWithAggregatesFilter | number | null
    TipoControlador?: IntNullableWithAggregatesFilter | number | null
    Prioridad?: StringNullableWithAggregatesFilter | string | null
    Certificado?: StringNullableWithAggregatesFilter | string | null
    PuertoSSL?: IntNullableWithAggregatesFilter | number | null
    PuertoNoSSL?: IntNullableWithAggregatesFilter | number | null
    PuertoMantenimiento?: IntNullableWithAggregatesFilter | number | null
    PuertoConexionSC?: IntNullableWithAggregatesFilter | number | null
    PuertoConexionCC?: IntNullableWithAggregatesFilter | number | null
    SOAP?: StringNullableWithAggregatesFilter | string | null
    Socket?: StringNullableWithAggregatesFilter | string | null
    API?: StringNullableWithAggregatesFilter | string | null
    Sincroniza?: StringNullableWithAggregatesFilter | string | null
    DireccionAIPV4?: StringNullableWithAggregatesFilter | string | null
    DireccionBIPv4?: StringNullableWithAggregatesFilter | string | null
    DireccionAIPV6?: StringNullableWithAggregatesFilter | string | null
    DireccionBIPv6?: StringNullableWithAggregatesFilter | string | null
    DireccionPublica1?: StringNullableWithAggregatesFilter | string | null
    DireccionPublica2?: StringNullableWithAggregatesFilter | string | null
    Localizacion?: StringNullableWithAggregatesFilter | string | null
    Latitud?: DecimalNullableWithAggregatesFilter | Decimal | DecimalJsLike | number | string | null
    Longitud?: DecimalNullableWithAggregatesFilter | Decimal | DecimalJsLike | number | string | null
    Estatus?: IntNullableWithAggregatesFilter | number | null
    FechaCreado?: DateTimeNullableWithAggregatesFilter | Date | string | null
    FechaDesactivado?: DateTimeNullableWithAggregatesFilter | Date | string | null
  }

  export type dispositivosWhereInput = {
    AND?: Enumerable<dispositivosWhereInput>
    OR?: Enumerable<dispositivosWhereInput>
    NOT?: Enumerable<dispositivosWhereInput>
    IDDispositivo?: IntFilter | number
    IDSubsistema?: IntNullableFilter | number | null
    IDTipoFamilia?: IntNullableFilter | number | null
    IDFamilia?: IntNullableFilter | number | null
    IDFabricante?: IntNullableFilter | number | null
    IDTipoDispositivo?: IntNullableFilter | number | null
    IDGateway?: IntNullableFilter | number | null
    IDControlador?: IntNullableFilter | number | null
    IDModelo?: IntNullableFilter | number | null
    IDEdificio?: IntNullableFilter | number | null
    IDZona?: IntNullableFilter | number | null
    IDPuerta?: IntNullableFilter | number | null
    NombreDispositivo?: StringNullableFilter | string | null
    Descripcion?: StringNullableFilter | string | null
    IDIconografia?: IntNullableFilter | number | null
    IDMenuPropio?: IntNullableFilter | number | null
    Estatus?: StringNullableFilter | string | null
    Sentidos?: StringNullableFilter | string | null
    Ignorado?: StringNullableFilter | string | null
    Enrolamiento?: StringNullableFilter | string | null
    Latitud?: DecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
    Longitud?: DecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
    DireccionGPS?: StringNullableFilter | string | null
    GeometriaGPS?: StringNullableFilter | string | null
    IDTipoEvento?: IntNullableFilter | number | null
    IDModeloElemento?: IntNullableFilter | number | null
    FechaCreacion?: DateTimeNullableFilter | Date | string | null
    FechaDesactivacion?: DateTimeNullableFilter | Date | string | null
    FechaEliminacion?: DateTimeNullableFilter | Date | string | null
    Parametros?: StringNullableFilter | string | null
    Certificado?: StringNullableFilter | string | null
    PuertoSSL?: IntNullableFilter | number | null
    PuertoNoSSL?: IntNullableFilter | number | null
    PuertoMantenimiento?: IntNullableFilter | number | null
    PuertoConexionSC?: IntNullableFilter | number | null
    PuertoConexionCC?: IntNullableFilter | number | null
    SOAP?: StringNullableFilter | string | null
    Socket?: StringNullableFilter | string | null
    API?: StringNullableFilter | string | null
    Sincroniza?: StringNullableFilter | string | null
    DireccionAIPV4?: StringNullableFilter | string | null
    DireccionBIPv4?: StringNullableFilter | string | null
    DireccionAIPV6?: StringNullableFilter | string | null
    DireccionBIPv6?: StringNullableFilter | string | null
    DireccionPublica1?: StringNullableFilter | string | null
    DireccionPublica2?: StringNullableFilter | string | null
    Serial?: StringNullableFilter | string | null
    user?: StringNullableFilter | string | null
    password?: StringNullableFilter | string | null
    IDManual?: IntNullableFilter | number | null
    Directo?: IntNullableFilter | number | null
  }

  export type dispositivosOrderByWithRelationInput = {
    IDDispositivo?: SortOrder
    IDSubsistema?: SortOrder
    IDTipoFamilia?: SortOrder
    IDFamilia?: SortOrder
    IDFabricante?: SortOrder
    IDTipoDispositivo?: SortOrder
    IDGateway?: SortOrder
    IDControlador?: SortOrder
    IDModelo?: SortOrder
    IDEdificio?: SortOrder
    IDZona?: SortOrder
    IDPuerta?: SortOrder
    NombreDispositivo?: SortOrder
    Descripcion?: SortOrder
    IDIconografia?: SortOrder
    IDMenuPropio?: SortOrder
    Estatus?: SortOrder
    Sentidos?: SortOrder
    Ignorado?: SortOrder
    Enrolamiento?: SortOrder
    Latitud?: SortOrder
    Longitud?: SortOrder
    DireccionGPS?: SortOrder
    GeometriaGPS?: SortOrder
    IDTipoEvento?: SortOrder
    IDModeloElemento?: SortOrder
    FechaCreacion?: SortOrder
    FechaDesactivacion?: SortOrder
    FechaEliminacion?: SortOrder
    Parametros?: SortOrder
    Certificado?: SortOrder
    PuertoSSL?: SortOrder
    PuertoNoSSL?: SortOrder
    PuertoMantenimiento?: SortOrder
    PuertoConexionSC?: SortOrder
    PuertoConexionCC?: SortOrder
    SOAP?: SortOrder
    Socket?: SortOrder
    API?: SortOrder
    Sincroniza?: SortOrder
    DireccionAIPV4?: SortOrder
    DireccionBIPv4?: SortOrder
    DireccionAIPV6?: SortOrder
    DireccionBIPv6?: SortOrder
    DireccionPublica1?: SortOrder
    DireccionPublica2?: SortOrder
    Serial?: SortOrder
    user?: SortOrder
    password?: SortOrder
    IDManual?: SortOrder
    Directo?: SortOrder
  }

  export type dispositivosWhereUniqueInput = {
    IDDispositivo?: number
  }

  export type dispositivosOrderByWithAggregationInput = {
    IDDispositivo?: SortOrder
    IDSubsistema?: SortOrder
    IDTipoFamilia?: SortOrder
    IDFamilia?: SortOrder
    IDFabricante?: SortOrder
    IDTipoDispositivo?: SortOrder
    IDGateway?: SortOrder
    IDControlador?: SortOrder
    IDModelo?: SortOrder
    IDEdificio?: SortOrder
    IDZona?: SortOrder
    IDPuerta?: SortOrder
    NombreDispositivo?: SortOrder
    Descripcion?: SortOrder
    IDIconografia?: SortOrder
    IDMenuPropio?: SortOrder
    Estatus?: SortOrder
    Sentidos?: SortOrder
    Ignorado?: SortOrder
    Enrolamiento?: SortOrder
    Latitud?: SortOrder
    Longitud?: SortOrder
    DireccionGPS?: SortOrder
    GeometriaGPS?: SortOrder
    IDTipoEvento?: SortOrder
    IDModeloElemento?: SortOrder
    FechaCreacion?: SortOrder
    FechaDesactivacion?: SortOrder
    FechaEliminacion?: SortOrder
    Parametros?: SortOrder
    Certificado?: SortOrder
    PuertoSSL?: SortOrder
    PuertoNoSSL?: SortOrder
    PuertoMantenimiento?: SortOrder
    PuertoConexionSC?: SortOrder
    PuertoConexionCC?: SortOrder
    SOAP?: SortOrder
    Socket?: SortOrder
    API?: SortOrder
    Sincroniza?: SortOrder
    DireccionAIPV4?: SortOrder
    DireccionBIPv4?: SortOrder
    DireccionAIPV6?: SortOrder
    DireccionBIPv6?: SortOrder
    DireccionPublica1?: SortOrder
    DireccionPublica2?: SortOrder
    Serial?: SortOrder
    user?: SortOrder
    password?: SortOrder
    IDManual?: SortOrder
    Directo?: SortOrder
    _count?: dispositivosCountOrderByAggregateInput
    _avg?: dispositivosAvgOrderByAggregateInput
    _max?: dispositivosMaxOrderByAggregateInput
    _min?: dispositivosMinOrderByAggregateInput
    _sum?: dispositivosSumOrderByAggregateInput
  }

  export type dispositivosScalarWhereWithAggregatesInput = {
    AND?: Enumerable<dispositivosScalarWhereWithAggregatesInput>
    OR?: Enumerable<dispositivosScalarWhereWithAggregatesInput>
    NOT?: Enumerable<dispositivosScalarWhereWithAggregatesInput>
    IDDispositivo?: IntWithAggregatesFilter | number
    IDSubsistema?: IntNullableWithAggregatesFilter | number | null
    IDTipoFamilia?: IntNullableWithAggregatesFilter | number | null
    IDFamilia?: IntNullableWithAggregatesFilter | number | null
    IDFabricante?: IntNullableWithAggregatesFilter | number | null
    IDTipoDispositivo?: IntNullableWithAggregatesFilter | number | null
    IDGateway?: IntNullableWithAggregatesFilter | number | null
    IDControlador?: IntNullableWithAggregatesFilter | number | null
    IDModelo?: IntNullableWithAggregatesFilter | number | null
    IDEdificio?: IntNullableWithAggregatesFilter | number | null
    IDZona?: IntNullableWithAggregatesFilter | number | null
    IDPuerta?: IntNullableWithAggregatesFilter | number | null
    NombreDispositivo?: StringNullableWithAggregatesFilter | string | null
    Descripcion?: StringNullableWithAggregatesFilter | string | null
    IDIconografia?: IntNullableWithAggregatesFilter | number | null
    IDMenuPropio?: IntNullableWithAggregatesFilter | number | null
    Estatus?: StringNullableWithAggregatesFilter | string | null
    Sentidos?: StringNullableWithAggregatesFilter | string | null
    Ignorado?: StringNullableWithAggregatesFilter | string | null
    Enrolamiento?: StringNullableWithAggregatesFilter | string | null
    Latitud?: DecimalNullableWithAggregatesFilter | Decimal | DecimalJsLike | number | string | null
    Longitud?: DecimalNullableWithAggregatesFilter | Decimal | DecimalJsLike | number | string | null
    DireccionGPS?: StringNullableWithAggregatesFilter | string | null
    GeometriaGPS?: StringNullableWithAggregatesFilter | string | null
    IDTipoEvento?: IntNullableWithAggregatesFilter | number | null
    IDModeloElemento?: IntNullableWithAggregatesFilter | number | null
    FechaCreacion?: DateTimeNullableWithAggregatesFilter | Date | string | null
    FechaDesactivacion?: DateTimeNullableWithAggregatesFilter | Date | string | null
    FechaEliminacion?: DateTimeNullableWithAggregatesFilter | Date | string | null
    Parametros?: StringNullableWithAggregatesFilter | string | null
    Certificado?: StringNullableWithAggregatesFilter | string | null
    PuertoSSL?: IntNullableWithAggregatesFilter | number | null
    PuertoNoSSL?: IntNullableWithAggregatesFilter | number | null
    PuertoMantenimiento?: IntNullableWithAggregatesFilter | number | null
    PuertoConexionSC?: IntNullableWithAggregatesFilter | number | null
    PuertoConexionCC?: IntNullableWithAggregatesFilter | number | null
    SOAP?: StringNullableWithAggregatesFilter | string | null
    Socket?: StringNullableWithAggregatesFilter | string | null
    API?: StringNullableWithAggregatesFilter | string | null
    Sincroniza?: StringNullableWithAggregatesFilter | string | null
    DireccionAIPV4?: StringNullableWithAggregatesFilter | string | null
    DireccionBIPv4?: StringNullableWithAggregatesFilter | string | null
    DireccionAIPV6?: StringNullableWithAggregatesFilter | string | null
    DireccionBIPv6?: StringNullableWithAggregatesFilter | string | null
    DireccionPublica1?: StringNullableWithAggregatesFilter | string | null
    DireccionPublica2?: StringNullableWithAggregatesFilter | string | null
    Serial?: StringNullableWithAggregatesFilter | string | null
    user?: StringNullableWithAggregatesFilter | string | null
    password?: StringNullableWithAggregatesFilter | string | null
    IDManual?: IntNullableWithAggregatesFilter | number | null
    Directo?: IntNullableWithAggregatesFilter | number | null
  }

  export type gatewayWhereInput = {
    AND?: Enumerable<gatewayWhereInput>
    OR?: Enumerable<gatewayWhereInput>
    NOT?: Enumerable<gatewayWhereInput>
    IDGateway?: IntFilter | number
    IDTipoGateway?: IntNullableFilter | number | null
    IDControlador?: IntNullableFilter | number | null
    IDEdificio?: IntNullableFilter | number | null
    IDIdentificadorExterno?: StringNullableFilter | string | null
    IDTipoEvento?: IntNullableFilter | number | null
    IDGrupoMetodo?: IntNullableFilter | number | null
    NAbonado?: StringNullableFilter | string | null
    NombreGateway?: StringNullableFilter | string | null
    Descripcion?: StringNullableFilter | string | null
    IDIcono?: IntNullableFilter | number | null
    ValorEstado?: BytesNullableFilter | Buffer | null
    Parametros?: StringNullableFilter | string | null
    EstadoOnOff?: StringNullableFilter | string | null
    Latitud?: DecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
    Longitud?: DecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
    SerialGPS?: StringNullableFilter | string | null
    GeometriaGPS?: StringNullableFilter | string | null
    FechaCreado?: DateTimeNullableFilter | Date | string | null
    FechaDesactivado?: DateTimeNullableFilter | Date | string | null
    Certificado?: StringNullableFilter | string | null
    PuertoSSL?: IntNullableFilter | number | null
    PuertoNoSSL?: IntNullableFilter | number | null
    PuertoMantenimiento?: IntNullableFilter | number | null
    PuertoConexionSC?: IntNullableFilter | number | null
    PuertoConexionCC?: IntNullableFilter | number | null
    SOAP?: StringNullableFilter | string | null
    Socket?: StringNullableFilter | string | null
    API?: StringNullableFilter | string | null
    Sincroniza?: StringNullableFilter | string | null
    DireccionAIPV4?: StringNullableFilter | string | null
    DireccionBIPv4?: StringNullableFilter | string | null
    DireccionAIPV6?: StringNullableFilter | string | null
    DireccionBIPv6?: StringNullableFilter | string | null
    DireccionPublica1?: StringNullableFilter | string | null
    DireccionPublica2?: StringNullableFilter | string | null
    user?: StringNullableFilter | string | null
    password?: StringNullableFilter | string | null
    Serial?: StringNullableFilter | string | null
    IDManual?: IntNullableFilter | number | null
    IDZona?: IntNullableFilter | number | null
  }

  export type gatewayOrderByWithRelationInput = {
    IDGateway?: SortOrder
    IDTipoGateway?: SortOrder
    IDControlador?: SortOrder
    IDEdificio?: SortOrder
    IDIdentificadorExterno?: SortOrder
    IDTipoEvento?: SortOrder
    IDGrupoMetodo?: SortOrder
    NAbonado?: SortOrder
    NombreGateway?: SortOrder
    Descripcion?: SortOrder
    IDIcono?: SortOrder
    ValorEstado?: SortOrder
    Parametros?: SortOrder
    EstadoOnOff?: SortOrder
    Latitud?: SortOrder
    Longitud?: SortOrder
    SerialGPS?: SortOrder
    GeometriaGPS?: SortOrder
    FechaCreado?: SortOrder
    FechaDesactivado?: SortOrder
    Certificado?: SortOrder
    PuertoSSL?: SortOrder
    PuertoNoSSL?: SortOrder
    PuertoMantenimiento?: SortOrder
    PuertoConexionSC?: SortOrder
    PuertoConexionCC?: SortOrder
    SOAP?: SortOrder
    Socket?: SortOrder
    API?: SortOrder
    Sincroniza?: SortOrder
    DireccionAIPV4?: SortOrder
    DireccionBIPv4?: SortOrder
    DireccionAIPV6?: SortOrder
    DireccionBIPv6?: SortOrder
    DireccionPublica1?: SortOrder
    DireccionPublica2?: SortOrder
    user?: SortOrder
    password?: SortOrder
    Serial?: SortOrder
    IDManual?: SortOrder
    IDZona?: SortOrder
  }

  export type gatewayWhereUniqueInput = {
    IDGateway?: number
  }

  export type gatewayOrderByWithAggregationInput = {
    IDGateway?: SortOrder
    IDTipoGateway?: SortOrder
    IDControlador?: SortOrder
    IDEdificio?: SortOrder
    IDIdentificadorExterno?: SortOrder
    IDTipoEvento?: SortOrder
    IDGrupoMetodo?: SortOrder
    NAbonado?: SortOrder
    NombreGateway?: SortOrder
    Descripcion?: SortOrder
    IDIcono?: SortOrder
    ValorEstado?: SortOrder
    Parametros?: SortOrder
    EstadoOnOff?: SortOrder
    Latitud?: SortOrder
    Longitud?: SortOrder
    SerialGPS?: SortOrder
    GeometriaGPS?: SortOrder
    FechaCreado?: SortOrder
    FechaDesactivado?: SortOrder
    Certificado?: SortOrder
    PuertoSSL?: SortOrder
    PuertoNoSSL?: SortOrder
    PuertoMantenimiento?: SortOrder
    PuertoConexionSC?: SortOrder
    PuertoConexionCC?: SortOrder
    SOAP?: SortOrder
    Socket?: SortOrder
    API?: SortOrder
    Sincroniza?: SortOrder
    DireccionAIPV4?: SortOrder
    DireccionBIPv4?: SortOrder
    DireccionAIPV6?: SortOrder
    DireccionBIPv6?: SortOrder
    DireccionPublica1?: SortOrder
    DireccionPublica2?: SortOrder
    user?: SortOrder
    password?: SortOrder
    Serial?: SortOrder
    IDManual?: SortOrder
    IDZona?: SortOrder
    _count?: gatewayCountOrderByAggregateInput
    _avg?: gatewayAvgOrderByAggregateInput
    _max?: gatewayMaxOrderByAggregateInput
    _min?: gatewayMinOrderByAggregateInput
    _sum?: gatewaySumOrderByAggregateInput
  }

  export type gatewayScalarWhereWithAggregatesInput = {
    AND?: Enumerable<gatewayScalarWhereWithAggregatesInput>
    OR?: Enumerable<gatewayScalarWhereWithAggregatesInput>
    NOT?: Enumerable<gatewayScalarWhereWithAggregatesInput>
    IDGateway?: IntWithAggregatesFilter | number
    IDTipoGateway?: IntNullableWithAggregatesFilter | number | null
    IDControlador?: IntNullableWithAggregatesFilter | number | null
    IDEdificio?: IntNullableWithAggregatesFilter | number | null
    IDIdentificadorExterno?: StringNullableWithAggregatesFilter | string | null
    IDTipoEvento?: IntNullableWithAggregatesFilter | number | null
    IDGrupoMetodo?: IntNullableWithAggregatesFilter | number | null
    NAbonado?: StringNullableWithAggregatesFilter | string | null
    NombreGateway?: StringNullableWithAggregatesFilter | string | null
    Descripcion?: StringNullableWithAggregatesFilter | string | null
    IDIcono?: IntNullableWithAggregatesFilter | number | null
    ValorEstado?: BytesNullableWithAggregatesFilter | Buffer | null
    Parametros?: StringNullableWithAggregatesFilter | string | null
    EstadoOnOff?: StringNullableWithAggregatesFilter | string | null
    Latitud?: DecimalNullableWithAggregatesFilter | Decimal | DecimalJsLike | number | string | null
    Longitud?: DecimalNullableWithAggregatesFilter | Decimal | DecimalJsLike | number | string | null
    SerialGPS?: StringNullableWithAggregatesFilter | string | null
    GeometriaGPS?: StringNullableWithAggregatesFilter | string | null
    FechaCreado?: DateTimeNullableWithAggregatesFilter | Date | string | null
    FechaDesactivado?: DateTimeNullableWithAggregatesFilter | Date | string | null
    Certificado?: StringNullableWithAggregatesFilter | string | null
    PuertoSSL?: IntNullableWithAggregatesFilter | number | null
    PuertoNoSSL?: IntNullableWithAggregatesFilter | number | null
    PuertoMantenimiento?: IntNullableWithAggregatesFilter | number | null
    PuertoConexionSC?: IntNullableWithAggregatesFilter | number | null
    PuertoConexionCC?: IntNullableWithAggregatesFilter | number | null
    SOAP?: StringNullableWithAggregatesFilter | string | null
    Socket?: StringNullableWithAggregatesFilter | string | null
    API?: StringNullableWithAggregatesFilter | string | null
    Sincroniza?: StringNullableWithAggregatesFilter | string | null
    DireccionAIPV4?: StringNullableWithAggregatesFilter | string | null
    DireccionBIPv4?: StringNullableWithAggregatesFilter | string | null
    DireccionAIPV6?: StringNullableWithAggregatesFilter | string | null
    DireccionBIPv6?: StringNullableWithAggregatesFilter | string | null
    DireccionPublica1?: StringNullableWithAggregatesFilter | string | null
    DireccionPublica2?: StringNullableWithAggregatesFilter | string | null
    user?: StringNullableWithAggregatesFilter | string | null
    password?: StringNullableWithAggregatesFilter | string | null
    Serial?: StringNullableWithAggregatesFilter | string | null
    IDManual?: IntNullableWithAggregatesFilter | number | null
    IDZona?: IntNullableWithAggregatesFilter | number | null
  }

  export type gruposdispositivosWhereInput = {
    AND?: Enumerable<gruposdispositivosWhereInput>
    OR?: Enumerable<gruposdispositivosWhereInput>
    NOT?: Enumerable<gruposdispositivosWhereInput>
    IDGrupoDispositivo?: IntFilter | number
    NombreGrupoDispositivo?: StringNullableFilter | string | null
    Identificador?: StringNullableFilter | string | null
    Descripcion?: StringNullableFilter | string | null
  }

  export type gruposdispositivosOrderByWithRelationInput = {
    IDGrupoDispositivo?: SortOrder
    NombreGrupoDispositivo?: SortOrder
    Identificador?: SortOrder
    Descripcion?: SortOrder
  }

  export type gruposdispositivosWhereUniqueInput = {
    IDGrupoDispositivo?: number
  }

  export type gruposdispositivosOrderByWithAggregationInput = {
    IDGrupoDispositivo?: SortOrder
    NombreGrupoDispositivo?: SortOrder
    Identificador?: SortOrder
    Descripcion?: SortOrder
    _count?: gruposdispositivosCountOrderByAggregateInput
    _avg?: gruposdispositivosAvgOrderByAggregateInput
    _max?: gruposdispositivosMaxOrderByAggregateInput
    _min?: gruposdispositivosMinOrderByAggregateInput
    _sum?: gruposdispositivosSumOrderByAggregateInput
  }

  export type gruposdispositivosScalarWhereWithAggregatesInput = {
    AND?: Enumerable<gruposdispositivosScalarWhereWithAggregatesInput>
    OR?: Enumerable<gruposdispositivosScalarWhereWithAggregatesInput>
    NOT?: Enumerable<gruposdispositivosScalarWhereWithAggregatesInput>
    IDGrupoDispositivo?: IntWithAggregatesFilter | number
    NombreGrupoDispositivo?: StringNullableWithAggregatesFilter | string | null
    Identificador?: StringNullableWithAggregatesFilter | string | null
    Descripcion?: StringNullableWithAggregatesFilter | string | null
  }

  export type inventariocatastroWhereInput = {
    AND?: Enumerable<inventariocatastroWhereInput>
    OR?: Enumerable<inventariocatastroWhereInput>
    NOT?: Enumerable<inventariocatastroWhereInput>
    IDEntidadInventario?: IntFilter | number
    IDTipoEntidadInventario?: IntNullableFilter | number | null
    IDCategoriaEntidadInventario?: IntNullableFilter | number | null
    IDGateway?: IntNullableFilter | number | null
    IDDispositivo?: IntNullableFilter | number | null
    IDMetaEdificio?: IntNullableFilter | number | null
    IDEdificio?: IntNullableFilter | number | null
    NombreEntidadInventario?: StringNullableFilter | string | null
    Descripcion?: StringNullableFilter | string | null
    Latitud?: DecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
    Longitud?: DecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
    SerialGPS?: StringNullableFilter | string | null
    GeometriaGPS?: StringNullableFilter | string | null
    FechaAlta?: DateTimeNullableFilter | Date | string | null
    FechaBaja?: DateTimeNullableFilter | Date | string | null
  }

  export type inventariocatastroOrderByWithRelationInput = {
    IDEntidadInventario?: SortOrder
    IDTipoEntidadInventario?: SortOrder
    IDCategoriaEntidadInventario?: SortOrder
    IDGateway?: SortOrder
    IDDispositivo?: SortOrder
    IDMetaEdificio?: SortOrder
    IDEdificio?: SortOrder
    NombreEntidadInventario?: SortOrder
    Descripcion?: SortOrder
    Latitud?: SortOrder
    Longitud?: SortOrder
    SerialGPS?: SortOrder
    GeometriaGPS?: SortOrder
    FechaAlta?: SortOrder
    FechaBaja?: SortOrder
  }

  export type inventariocatastroWhereUniqueInput = {
    IDEntidadInventario?: number
  }

  export type inventariocatastroOrderByWithAggregationInput = {
    IDEntidadInventario?: SortOrder
    IDTipoEntidadInventario?: SortOrder
    IDCategoriaEntidadInventario?: SortOrder
    IDGateway?: SortOrder
    IDDispositivo?: SortOrder
    IDMetaEdificio?: SortOrder
    IDEdificio?: SortOrder
    NombreEntidadInventario?: SortOrder
    Descripcion?: SortOrder
    Latitud?: SortOrder
    Longitud?: SortOrder
    SerialGPS?: SortOrder
    GeometriaGPS?: SortOrder
    FechaAlta?: SortOrder
    FechaBaja?: SortOrder
    _count?: inventariocatastroCountOrderByAggregateInput
    _avg?: inventariocatastroAvgOrderByAggregateInput
    _max?: inventariocatastroMaxOrderByAggregateInput
    _min?: inventariocatastroMinOrderByAggregateInput
    _sum?: inventariocatastroSumOrderByAggregateInput
  }

  export type inventariocatastroScalarWhereWithAggregatesInput = {
    AND?: Enumerable<inventariocatastroScalarWhereWithAggregatesInput>
    OR?: Enumerable<inventariocatastroScalarWhereWithAggregatesInput>
    NOT?: Enumerable<inventariocatastroScalarWhereWithAggregatesInput>
    IDEntidadInventario?: IntWithAggregatesFilter | number
    IDTipoEntidadInventario?: IntNullableWithAggregatesFilter | number | null
    IDCategoriaEntidadInventario?: IntNullableWithAggregatesFilter | number | null
    IDGateway?: IntNullableWithAggregatesFilter | number | null
    IDDispositivo?: IntNullableWithAggregatesFilter | number | null
    IDMetaEdificio?: IntNullableWithAggregatesFilter | number | null
    IDEdificio?: IntNullableWithAggregatesFilter | number | null
    NombreEntidadInventario?: StringNullableWithAggregatesFilter | string | null
    Descripcion?: StringNullableWithAggregatesFilter | string | null
    Latitud?: DecimalNullableWithAggregatesFilter | Decimal | DecimalJsLike | number | string | null
    Longitud?: DecimalNullableWithAggregatesFilter | Decimal | DecimalJsLike | number | string | null
    SerialGPS?: StringNullableWithAggregatesFilter | string | null
    GeometriaGPS?: StringNullableWithAggregatesFilter | string | null
    FechaAlta?: DateTimeNullableWithAggregatesFilter | Date | string | null
    FechaBaja?: DateTimeNullableWithAggregatesFilter | Date | string | null
  }

  export type libreriasapisWhereInput = {
    AND?: Enumerable<libreriasapisWhereInput>
    OR?: Enumerable<libreriasapisWhereInput>
    NOT?: Enumerable<libreriasapisWhereInput>
    IDLIBAPISDK?: IntFilter | number
    Nombre?: StringNullableFilter | string | null
    Tipo?: StringNullableFilter | string | null
    Web?: StringNullableFilter | string | null
    Subsistema?: IntNullableFilter | number | null
    Alcance?: StringNullableFilter | string | null
  }

  export type libreriasapisOrderByWithRelationInput = {
    IDLIBAPISDK?: SortOrder
    Nombre?: SortOrder
    Tipo?: SortOrder
    Web?: SortOrder
    Subsistema?: SortOrder
    Alcance?: SortOrder
  }

  export type libreriasapisWhereUniqueInput = {
    IDLIBAPISDK?: number
  }

  export type libreriasapisOrderByWithAggregationInput = {
    IDLIBAPISDK?: SortOrder
    Nombre?: SortOrder
    Tipo?: SortOrder
    Web?: SortOrder
    Subsistema?: SortOrder
    Alcance?: SortOrder
    _count?: libreriasapisCountOrderByAggregateInput
    _avg?: libreriasapisAvgOrderByAggregateInput
    _max?: libreriasapisMaxOrderByAggregateInput
    _min?: libreriasapisMinOrderByAggregateInput
    _sum?: libreriasapisSumOrderByAggregateInput
  }

  export type libreriasapisScalarWhereWithAggregatesInput = {
    AND?: Enumerable<libreriasapisScalarWhereWithAggregatesInput>
    OR?: Enumerable<libreriasapisScalarWhereWithAggregatesInput>
    NOT?: Enumerable<libreriasapisScalarWhereWithAggregatesInput>
    IDLIBAPISDK?: IntWithAggregatesFilter | number
    Nombre?: StringNullableWithAggregatesFilter | string | null
    Tipo?: StringNullableWithAggregatesFilter | string | null
    Web?: StringNullableWithAggregatesFilter | string | null
    Subsistema?: IntNullableWithAggregatesFilter | number | null
    Alcance?: StringNullableWithAggregatesFilter | string | null
  }

  export type metodogrupoWhereInput = {
    AND?: Enumerable<metodogrupoWhereInput>
    OR?: Enumerable<metodogrupoWhereInput>
    NOT?: Enumerable<metodogrupoWhereInput>
    IDGrupoMetodo?: IntFilter | number
    NombreGrupoMetodo?: StringNullableFilter | string | null
    Corporacion?: StringNullableFilter | string | null
    Departamento?: StringNullableFilter | string | null
    Edificio?: StringNullableFilter | string | null
    Itinerario?: StringNullableFilter | string | null
    Empleado?: StringNullableFilter | string | null
    Modificable?: StringNullableFilter | string | null
    Descripcion?: StringNullableFilter | string | null
    Tipo?: StringNullableFilter | string | null
    IDGrupoMetodoPadre?: IntNullableFilter | number | null
    Identificador?: StringNullableFilter | string | null
    IdentificadorExterno?: StringNullableFilter | string | null
  }

  export type metodogrupoOrderByWithRelationInput = {
    IDGrupoMetodo?: SortOrder
    NombreGrupoMetodo?: SortOrder
    Corporacion?: SortOrder
    Departamento?: SortOrder
    Edificio?: SortOrder
    Itinerario?: SortOrder
    Empleado?: SortOrder
    Modificable?: SortOrder
    Descripcion?: SortOrder
    Tipo?: SortOrder
    IDGrupoMetodoPadre?: SortOrder
    Identificador?: SortOrder
    IdentificadorExterno?: SortOrder
  }

  export type metodogrupoWhereUniqueInput = {
    IDGrupoMetodo?: number
  }

  export type metodogrupoOrderByWithAggregationInput = {
    IDGrupoMetodo?: SortOrder
    NombreGrupoMetodo?: SortOrder
    Corporacion?: SortOrder
    Departamento?: SortOrder
    Edificio?: SortOrder
    Itinerario?: SortOrder
    Empleado?: SortOrder
    Modificable?: SortOrder
    Descripcion?: SortOrder
    Tipo?: SortOrder
    IDGrupoMetodoPadre?: SortOrder
    Identificador?: SortOrder
    IdentificadorExterno?: SortOrder
    _count?: metodogrupoCountOrderByAggregateInput
    _avg?: metodogrupoAvgOrderByAggregateInput
    _max?: metodogrupoMaxOrderByAggregateInput
    _min?: metodogrupoMinOrderByAggregateInput
    _sum?: metodogrupoSumOrderByAggregateInput
  }

  export type metodogrupoScalarWhereWithAggregatesInput = {
    AND?: Enumerable<metodogrupoScalarWhereWithAggregatesInput>
    OR?: Enumerable<metodogrupoScalarWhereWithAggregatesInput>
    NOT?: Enumerable<metodogrupoScalarWhereWithAggregatesInput>
    IDGrupoMetodo?: IntWithAggregatesFilter | number
    NombreGrupoMetodo?: StringNullableWithAggregatesFilter | string | null
    Corporacion?: StringNullableWithAggregatesFilter | string | null
    Departamento?: StringNullableWithAggregatesFilter | string | null
    Edificio?: StringNullableWithAggregatesFilter | string | null
    Itinerario?: StringNullableWithAggregatesFilter | string | null
    Empleado?: StringNullableWithAggregatesFilter | string | null
    Modificable?: StringNullableWithAggregatesFilter | string | null
    Descripcion?: StringNullableWithAggregatesFilter | string | null
    Tipo?: StringNullableWithAggregatesFilter | string | null
    IDGrupoMetodoPadre?: IntNullableWithAggregatesFilter | number | null
    Identificador?: StringNullableWithAggregatesFilter | string | null
    IdentificadorExterno?: StringNullableWithAggregatesFilter | string | null
  }

  export type metodosWhereInput = {
    AND?: Enumerable<metodosWhereInput>
    OR?: Enumerable<metodosWhereInput>
    NOT?: Enumerable<metodosWhereInput>
    IDMetodo?: IntFilter | number
    Indice?: IntFilter | number
    IDGrupoMetodo?: IntFilter | number
    IDLibreria?: IntNullableFilter | number | null
    IDMetodoPadre?: IntNullableFilter | number | null
    Clase?: StringFilter | string
    Tipo?: StringFilter | string
    Propagable?: StringFilter | string
    BlobsPropagable?: StringFilter | string
    NParametros?: IntFilter | number
    NParametrosBinarios?: IntFilter | number
    Basico?: StringFilter | string
    Estado?: StringFilter | string
    Descripcion?: StringNullableFilter | string | null
    NombreMetodo?: StringNullableFilter | string | null
    NombreFuncion?: StringNullableFilter | string | null
    MetodoTrigger?: StringNullableFilter | string | null
    EnvioAplicacion?: StringFilter | string
    EjecucionLibre?: StringFilter | string
  }

  export type metodosOrderByWithRelationInput = {
    IDMetodo?: SortOrder
    Indice?: SortOrder
    IDGrupoMetodo?: SortOrder
    IDLibreria?: SortOrder
    IDMetodoPadre?: SortOrder
    Clase?: SortOrder
    Tipo?: SortOrder
    Propagable?: SortOrder
    BlobsPropagable?: SortOrder
    NParametros?: SortOrder
    NParametrosBinarios?: SortOrder
    Basico?: SortOrder
    Estado?: SortOrder
    Descripcion?: SortOrder
    NombreMetodo?: SortOrder
    NombreFuncion?: SortOrder
    MetodoTrigger?: SortOrder
    EnvioAplicacion?: SortOrder
    EjecucionLibre?: SortOrder
  }

  export type metodosWhereUniqueInput = {
    IDMetodo?: number
  }

  export type metodosOrderByWithAggregationInput = {
    IDMetodo?: SortOrder
    Indice?: SortOrder
    IDGrupoMetodo?: SortOrder
    IDLibreria?: SortOrder
    IDMetodoPadre?: SortOrder
    Clase?: SortOrder
    Tipo?: SortOrder
    Propagable?: SortOrder
    BlobsPropagable?: SortOrder
    NParametros?: SortOrder
    NParametrosBinarios?: SortOrder
    Basico?: SortOrder
    Estado?: SortOrder
    Descripcion?: SortOrder
    NombreMetodo?: SortOrder
    NombreFuncion?: SortOrder
    MetodoTrigger?: SortOrder
    EnvioAplicacion?: SortOrder
    EjecucionLibre?: SortOrder
    _count?: metodosCountOrderByAggregateInput
    _avg?: metodosAvgOrderByAggregateInput
    _max?: metodosMaxOrderByAggregateInput
    _min?: metodosMinOrderByAggregateInput
    _sum?: metodosSumOrderByAggregateInput
  }

  export type metodosScalarWhereWithAggregatesInput = {
    AND?: Enumerable<metodosScalarWhereWithAggregatesInput>
    OR?: Enumerable<metodosScalarWhereWithAggregatesInput>
    NOT?: Enumerable<metodosScalarWhereWithAggregatesInput>
    IDMetodo?: IntWithAggregatesFilter | number
    Indice?: IntWithAggregatesFilter | number
    IDGrupoMetodo?: IntWithAggregatesFilter | number
    IDLibreria?: IntNullableWithAggregatesFilter | number | null
    IDMetodoPadre?: IntNullableWithAggregatesFilter | number | null
    Clase?: StringWithAggregatesFilter | string
    Tipo?: StringWithAggregatesFilter | string
    Propagable?: StringWithAggregatesFilter | string
    BlobsPropagable?: StringWithAggregatesFilter | string
    NParametros?: IntWithAggregatesFilter | number
    NParametrosBinarios?: IntWithAggregatesFilter | number
    Basico?: StringWithAggregatesFilter | string
    Estado?: StringWithAggregatesFilter | string
    Descripcion?: StringNullableWithAggregatesFilter | string | null
    NombreMetodo?: StringNullableWithAggregatesFilter | string | null
    NombreFuncion?: StringNullableWithAggregatesFilter | string | null
    MetodoTrigger?: StringNullableWithAggregatesFilter | string | null
    EnvioAplicacion?: StringWithAggregatesFilter | string
    EjecucionLibre?: StringWithAggregatesFilter | string
  }

  export type objetosplanimetriaWhereInput = {
    AND?: Enumerable<objetosplanimetriaWhereInput>
    OR?: Enumerable<objetosplanimetriaWhereInput>
    NOT?: Enumerable<objetosplanimetriaWhereInput>
    Id?: IntFilter | number
    NombreObjeto?: StringNullableFilter | string | null
    URLHost?: StringNullableFilter | string | null
    IpHost?: StringNullableFilter | string | null
    Puerto?: IntNullableFilter | number | null
    Usuario?: StringNullableFilter | string | null
    Clave?: StringNullableFilter | string | null
  }

  export type objetosplanimetriaOrderByWithRelationInput = {
    Id?: SortOrder
    NombreObjeto?: SortOrder
    URLHost?: SortOrder
    IpHost?: SortOrder
    Puerto?: SortOrder
    Usuario?: SortOrder
    Clave?: SortOrder
  }

  export type objetosplanimetriaWhereUniqueInput = {
    Id?: number
  }

  export type objetosplanimetriaOrderByWithAggregationInput = {
    Id?: SortOrder
    NombreObjeto?: SortOrder
    URLHost?: SortOrder
    IpHost?: SortOrder
    Puerto?: SortOrder
    Usuario?: SortOrder
    Clave?: SortOrder
    _count?: objetosplanimetriaCountOrderByAggregateInput
    _avg?: objetosplanimetriaAvgOrderByAggregateInput
    _max?: objetosplanimetriaMaxOrderByAggregateInput
    _min?: objetosplanimetriaMinOrderByAggregateInput
    _sum?: objetosplanimetriaSumOrderByAggregateInput
  }

  export type objetosplanimetriaScalarWhereWithAggregatesInput = {
    AND?: Enumerable<objetosplanimetriaScalarWhereWithAggregatesInput>
    OR?: Enumerable<objetosplanimetriaScalarWhereWithAggregatesInput>
    NOT?: Enumerable<objetosplanimetriaScalarWhereWithAggregatesInput>
    Id?: IntWithAggregatesFilter | number
    NombreObjeto?: StringNullableWithAggregatesFilter | string | null
    URLHost?: StringNullableWithAggregatesFilter | string | null
    IpHost?: StringNullableWithAggregatesFilter | string | null
    Puerto?: IntNullableWithAggregatesFilter | number | null
    Usuario?: StringNullableWithAggregatesFilter | string | null
    Clave?: StringNullableWithAggregatesFilter | string | null
  }

  export type reldispositivodispositivoWhereInput = {
    AND?: Enumerable<reldispositivodispositivoWhereInput>
    OR?: Enumerable<reldispositivodispositivoWhereInput>
    NOT?: Enumerable<reldispositivodispositivoWhereInput>
    IDRelDisDispositivo?: IntFilter | number
    IDDispositivoPadre?: IntNullableFilter | number | null
    IDDispositivoHijo?: IntNullableFilter | number | null
  }

  export type reldispositivodispositivoOrderByWithRelationInput = {
    IDRelDisDispositivo?: SortOrder
    IDDispositivoPadre?: SortOrder
    IDDispositivoHijo?: SortOrder
  }

  export type reldispositivodispositivoWhereUniqueInput = {
    IDRelDisDispositivo?: number
  }

  export type reldispositivodispositivoOrderByWithAggregationInput = {
    IDRelDisDispositivo?: SortOrder
    IDDispositivoPadre?: SortOrder
    IDDispositivoHijo?: SortOrder
    _count?: reldispositivodispositivoCountOrderByAggregateInput
    _avg?: reldispositivodispositivoAvgOrderByAggregateInput
    _max?: reldispositivodispositivoMaxOrderByAggregateInput
    _min?: reldispositivodispositivoMinOrderByAggregateInput
    _sum?: reldispositivodispositivoSumOrderByAggregateInput
  }

  export type reldispositivodispositivoScalarWhereWithAggregatesInput = {
    AND?: Enumerable<reldispositivodispositivoScalarWhereWithAggregatesInput>
    OR?: Enumerable<reldispositivodispositivoScalarWhereWithAggregatesInput>
    NOT?: Enumerable<reldispositivodispositivoScalarWhereWithAggregatesInput>
    IDRelDisDispositivo?: IntWithAggregatesFilter | number
    IDDispositivoPadre?: IntNullableWithAggregatesFilter | number | null
    IDDispositivoHijo?: IntNullableWithAggregatesFilter | number | null
  }

  export type reldispositivogatewayWhereInput = {
    AND?: Enumerable<reldispositivogatewayWhereInput>
    OR?: Enumerable<reldispositivogatewayWhereInput>
    NOT?: Enumerable<reldispositivogatewayWhereInput>
    IDRelDisGateway?: IntFilter | number
    IDDispositivo?: IntNullableFilter | number | null
    IDGateway?: IntNullableFilter | number | null
  }

  export type reldispositivogatewayOrderByWithRelationInput = {
    IDRelDisGateway?: SortOrder
    IDDispositivo?: SortOrder
    IDGateway?: SortOrder
  }

  export type reldispositivogatewayWhereUniqueInput = {
    IDRelDisGateway?: number
  }

  export type reldispositivogatewayOrderByWithAggregationInput = {
    IDRelDisGateway?: SortOrder
    IDDispositivo?: SortOrder
    IDGateway?: SortOrder
    _count?: reldispositivogatewayCountOrderByAggregateInput
    _avg?: reldispositivogatewayAvgOrderByAggregateInput
    _max?: reldispositivogatewayMaxOrderByAggregateInput
    _min?: reldispositivogatewayMinOrderByAggregateInput
    _sum?: reldispositivogatewaySumOrderByAggregateInput
  }

  export type reldispositivogatewayScalarWhereWithAggregatesInput = {
    AND?: Enumerable<reldispositivogatewayScalarWhereWithAggregatesInput>
    OR?: Enumerable<reldispositivogatewayScalarWhereWithAggregatesInput>
    NOT?: Enumerable<reldispositivogatewayScalarWhereWithAggregatesInput>
    IDRelDisGateway?: IntWithAggregatesFilter | number
    IDDispositivo?: IntNullableWithAggregatesFilter | number | null
    IDGateway?: IntNullableWithAggregatesFilter | number | null
  }

  export type reldispositivogrupodispositivoWhereInput = {
    AND?: Enumerable<reldispositivogrupodispositivoWhereInput>
    OR?: Enumerable<reldispositivogrupodispositivoWhereInput>
    NOT?: Enumerable<reldispositivogrupodispositivoWhereInput>
    IDRelDisGrupoDis?: IntFilter | number
    IDGrupo?: StringNullableFilter | string | null
    IDDispositivo?: StringNullableFilter | string | null
  }

  export type reldispositivogrupodispositivoOrderByWithRelationInput = {
    IDRelDisGrupoDis?: SortOrder
    IDGrupo?: SortOrder
    IDDispositivo?: SortOrder
  }

  export type reldispositivogrupodispositivoWhereUniqueInput = {
    IDRelDisGrupoDis?: number
  }

  export type reldispositivogrupodispositivoOrderByWithAggregationInput = {
    IDRelDisGrupoDis?: SortOrder
    IDGrupo?: SortOrder
    IDDispositivo?: SortOrder
    _count?: reldispositivogrupodispositivoCountOrderByAggregateInput
    _avg?: reldispositivogrupodispositivoAvgOrderByAggregateInput
    _max?: reldispositivogrupodispositivoMaxOrderByAggregateInput
    _min?: reldispositivogrupodispositivoMinOrderByAggregateInput
    _sum?: reldispositivogrupodispositivoSumOrderByAggregateInput
  }

  export type reldispositivogrupodispositivoScalarWhereWithAggregatesInput = {
    AND?: Enumerable<reldispositivogrupodispositivoScalarWhereWithAggregatesInput>
    OR?: Enumerable<reldispositivogrupodispositivoScalarWhereWithAggregatesInput>
    NOT?: Enumerable<reldispositivogrupodispositivoScalarWhereWithAggregatesInput>
    IDRelDisGrupoDis?: IntWithAggregatesFilter | number
    IDGrupo?: StringNullableWithAggregatesFilter | string | null
    IDDispositivo?: StringNullableWithAggregatesFilter | string | null
  }

  export type reldispositivoperfildispositivoWhereInput = {
    AND?: Enumerable<reldispositivoperfildispositivoWhereInput>
    OR?: Enumerable<reldispositivoperfildispositivoWhereInput>
    NOT?: Enumerable<reldispositivoperfildispositivoWhereInput>
    IDRelDisPerfil?: IntFilter | number
    IDDispositivo?: IntFilter | number
    IDPerfilDispositivo?: IntFilter | number
  }

  export type reldispositivoperfildispositivoOrderByWithRelationInput = {
    IDRelDisPerfil?: SortOrder
    IDDispositivo?: SortOrder
    IDPerfilDispositivo?: SortOrder
  }

  export type reldispositivoperfildispositivoWhereUniqueInput = {
    IDRelDisPerfil?: number
  }

  export type reldispositivoperfildispositivoOrderByWithAggregationInput = {
    IDRelDisPerfil?: SortOrder
    IDDispositivo?: SortOrder
    IDPerfilDispositivo?: SortOrder
    _count?: reldispositivoperfildispositivoCountOrderByAggregateInput
    _avg?: reldispositivoperfildispositivoAvgOrderByAggregateInput
    _max?: reldispositivoperfildispositivoMaxOrderByAggregateInput
    _min?: reldispositivoperfildispositivoMinOrderByAggregateInput
    _sum?: reldispositivoperfildispositivoSumOrderByAggregateInput
  }

  export type reldispositivoperfildispositivoScalarWhereWithAggregatesInput = {
    AND?: Enumerable<reldispositivoperfildispositivoScalarWhereWithAggregatesInput>
    OR?: Enumerable<reldispositivoperfildispositivoScalarWhereWithAggregatesInput>
    NOT?: Enumerable<reldispositivoperfildispositivoScalarWhereWithAggregatesInput>
    IDRelDisPerfil?: IntWithAggregatesFilter | number
    IDDispositivo?: IntWithAggregatesFilter | number
    IDPerfilDispositivo?: IntWithAggregatesFilter | number
  }

  export type reldispositivoplantillaanalogicaWhereInput = {
    AND?: Enumerable<reldispositivoplantillaanalogicaWhereInput>
    OR?: Enumerable<reldispositivoplantillaanalogicaWhereInput>
    NOT?: Enumerable<reldispositivoplantillaanalogicaWhereInput>
    IDRelDisPlantillaAnaloga?: IntFilter | number
    IDPlantillaAnalogica?: IntFilter | number
    IDDispositivo?: IntFilter | number
    Formula?: StringNullableFilter | string | null
    Version?: StringNullableFilter | string | null
  }

  export type reldispositivoplantillaanalogicaOrderByWithRelationInput = {
    IDRelDisPlantillaAnaloga?: SortOrder
    IDPlantillaAnalogica?: SortOrder
    IDDispositivo?: SortOrder
    Formula?: SortOrder
    Version?: SortOrder
  }

  export type reldispositivoplantillaanalogicaWhereUniqueInput = {
    IDRelDisPlantillaAnaloga?: number
  }

  export type reldispositivoplantillaanalogicaOrderByWithAggregationInput = {
    IDRelDisPlantillaAnaloga?: SortOrder
    IDPlantillaAnalogica?: SortOrder
    IDDispositivo?: SortOrder
    Formula?: SortOrder
    Version?: SortOrder
    _count?: reldispositivoplantillaanalogicaCountOrderByAggregateInput
    _avg?: reldispositivoplantillaanalogicaAvgOrderByAggregateInput
    _max?: reldispositivoplantillaanalogicaMaxOrderByAggregateInput
    _min?: reldispositivoplantillaanalogicaMinOrderByAggregateInput
    _sum?: reldispositivoplantillaanalogicaSumOrderByAggregateInput
  }

  export type reldispositivoplantillaanalogicaScalarWhereWithAggregatesInput = {
    AND?: Enumerable<reldispositivoplantillaanalogicaScalarWhereWithAggregatesInput>
    OR?: Enumerable<reldispositivoplantillaanalogicaScalarWhereWithAggregatesInput>
    NOT?: Enumerable<reldispositivoplantillaanalogicaScalarWhereWithAggregatesInput>
    IDRelDisPlantillaAnaloga?: IntWithAggregatesFilter | number
    IDPlantillaAnalogica?: IntWithAggregatesFilter | number
    IDDispositivo?: IntWithAggregatesFilter | number
    Formula?: StringNullableWithAggregatesFilter | string | null
    Version?: StringNullableWithAggregatesFilter | string | null
  }

  export type reldispositivopuertaWhereInput = {
    AND?: Enumerable<reldispositivopuertaWhereInput>
    OR?: Enumerable<reldispositivopuertaWhereInput>
    NOT?: Enumerable<reldispositivopuertaWhereInput>
    IDRelDisPuerta?: IntFilter | number
    IDDispositivo?: IntFilter | number
    IDPuerta?: IntFilter | number
    IDTipoDispositivo?: IntFilter | number
  }

  export type reldispositivopuertaOrderByWithRelationInput = {
    IDRelDisPuerta?: SortOrder
    IDDispositivo?: SortOrder
    IDPuerta?: SortOrder
    IDTipoDispositivo?: SortOrder
  }

  export type reldispositivopuertaWhereUniqueInput = {
    IDRelDisPuerta?: number
  }

  export type reldispositivopuertaOrderByWithAggregationInput = {
    IDRelDisPuerta?: SortOrder
    IDDispositivo?: SortOrder
    IDPuerta?: SortOrder
    IDTipoDispositivo?: SortOrder
    _count?: reldispositivopuertaCountOrderByAggregateInput
    _avg?: reldispositivopuertaAvgOrderByAggregateInput
    _max?: reldispositivopuertaMaxOrderByAggregateInput
    _min?: reldispositivopuertaMinOrderByAggregateInput
    _sum?: reldispositivopuertaSumOrderByAggregateInput
  }

  export type reldispositivopuertaScalarWhereWithAggregatesInput = {
    AND?: Enumerable<reldispositivopuertaScalarWhereWithAggregatesInput>
    OR?: Enumerable<reldispositivopuertaScalarWhereWithAggregatesInput>
    NOT?: Enumerable<reldispositivopuertaScalarWhereWithAggregatesInput>
    IDRelDisPuerta?: IntWithAggregatesFilter | number
    IDDispositivo?: IntWithAggregatesFilter | number
    IDPuerta?: IntWithAggregatesFilter | number
    IDTipoDispositivo?: IntWithAggregatesFilter | number
  }

  export type reldispositivosubsistemaWhereInput = {
    AND?: Enumerable<reldispositivosubsistemaWhereInput>
    OR?: Enumerable<reldispositivosubsistemaWhereInput>
    NOT?: Enumerable<reldispositivosubsistemaWhereInput>
    IDRelDisSubsistema?: IntFilter | number
    IDSubsistema?: IntNullableFilter | number | null
    IDDispositivo?: IntNullableFilter | number | null
  }

  export type reldispositivosubsistemaOrderByWithRelationInput = {
    IDRelDisSubsistema?: SortOrder
    IDSubsistema?: SortOrder
    IDDispositivo?: SortOrder
  }

  export type reldispositivosubsistemaWhereUniqueInput = {
    IDRelDisSubsistema?: number
  }

  export type reldispositivosubsistemaOrderByWithAggregationInput = {
    IDRelDisSubsistema?: SortOrder
    IDSubsistema?: SortOrder
    IDDispositivo?: SortOrder
    _count?: reldispositivosubsistemaCountOrderByAggregateInput
    _avg?: reldispositivosubsistemaAvgOrderByAggregateInput
    _max?: reldispositivosubsistemaMaxOrderByAggregateInput
    _min?: reldispositivosubsistemaMinOrderByAggregateInput
    _sum?: reldispositivosubsistemaSumOrderByAggregateInput
  }

  export type reldispositivosubsistemaScalarWhereWithAggregatesInput = {
    AND?: Enumerable<reldispositivosubsistemaScalarWhereWithAggregatesInput>
    OR?: Enumerable<reldispositivosubsistemaScalarWhereWithAggregatesInput>
    NOT?: Enumerable<reldispositivosubsistemaScalarWhereWithAggregatesInput>
    IDRelDisSubsistema?: IntWithAggregatesFilter | number
    IDSubsistema?: IntNullableWithAggregatesFilter | number | null
    IDDispositivo?: IntNullableWithAggregatesFilter | number | null
  }

  export type reldispositivotipoeventoWhereInput = {
    AND?: Enumerable<reldispositivotipoeventoWhereInput>
    OR?: Enumerable<reldispositivotipoeventoWhereInput>
    NOT?: Enumerable<reldispositivotipoeventoWhereInput>
    IDRelDisTipoEvento?: IntFilter | number
    IDDispositivo?: IntFilter | number
    ClaseEvento?: IntFilter | number
  }

  export type reldispositivotipoeventoOrderByWithRelationInput = {
    IDRelDisTipoEvento?: SortOrder
    IDDispositivo?: SortOrder
    ClaseEvento?: SortOrder
  }

  export type reldispositivotipoeventoWhereUniqueInput = {
    IDRelDisTipoEvento?: number
  }

  export type reldispositivotipoeventoOrderByWithAggregationInput = {
    IDRelDisTipoEvento?: SortOrder
    IDDispositivo?: SortOrder
    ClaseEvento?: SortOrder
    _count?: reldispositivotipoeventoCountOrderByAggregateInput
    _avg?: reldispositivotipoeventoAvgOrderByAggregateInput
    _max?: reldispositivotipoeventoMaxOrderByAggregateInput
    _min?: reldispositivotipoeventoMinOrderByAggregateInput
    _sum?: reldispositivotipoeventoSumOrderByAggregateInput
  }

  export type reldispositivotipoeventoScalarWhereWithAggregatesInput = {
    AND?: Enumerable<reldispositivotipoeventoScalarWhereWithAggregatesInput>
    OR?: Enumerable<reldispositivotipoeventoScalarWhereWithAggregatesInput>
    NOT?: Enumerable<reldispositivotipoeventoScalarWhereWithAggregatesInput>
    IDRelDisTipoEvento?: IntWithAggregatesFilter | number
    IDDispositivo?: IntWithAggregatesFilter | number
    ClaseEvento?: IntWithAggregatesFilter | number
  }

  export type reldispositivozonaWhereInput = {
    AND?: Enumerable<reldispositivozonaWhereInput>
    OR?: Enumerable<reldispositivozonaWhereInput>
    NOT?: Enumerable<reldispositivozonaWhereInput>
    IDRelDisZona?: IntFilter | number
    IDDispositivo?: IntNullableFilter | number | null
    IDZona?: IntNullableFilter | number | null
  }

  export type reldispositivozonaOrderByWithRelationInput = {
    IDRelDisZona?: SortOrder
    IDDispositivo?: SortOrder
    IDZona?: SortOrder
  }

  export type reldispositivozonaWhereUniqueInput = {
    IDRelDisZona?: number
  }

  export type reldispositivozonaOrderByWithAggregationInput = {
    IDRelDisZona?: SortOrder
    IDDispositivo?: SortOrder
    IDZona?: SortOrder
    _count?: reldispositivozonaCountOrderByAggregateInput
    _avg?: reldispositivozonaAvgOrderByAggregateInput
    _max?: reldispositivozonaMaxOrderByAggregateInput
    _min?: reldispositivozonaMinOrderByAggregateInput
    _sum?: reldispositivozonaSumOrderByAggregateInput
  }

  export type reldispositivozonaScalarWhereWithAggregatesInput = {
    AND?: Enumerable<reldispositivozonaScalarWhereWithAggregatesInput>
    OR?: Enumerable<reldispositivozonaScalarWhereWithAggregatesInput>
    NOT?: Enumerable<reldispositivozonaScalarWhereWithAggregatesInput>
    IDRelDisZona?: IntWithAggregatesFilter | number
    IDDispositivo?: IntNullableWithAggregatesFilter | number | null
    IDZona?: IntNullableWithAggregatesFilter | number | null
  }

  export type reltipocontroladormetodoWhereInput = {
    AND?: Enumerable<reltipocontroladormetodoWhereInput>
    OR?: Enumerable<reltipocontroladormetodoWhereInput>
    NOT?: Enumerable<reltipocontroladormetodoWhereInput>
    IDTipoControlador?: IntFilter | number
    IDMetodo?: IntNullableFilter | number | null
    RelTipoControladorMetodo?: IntNullableFilter | number | null
  }

  export type reltipocontroladormetodoOrderByWithRelationInput = {
    IDTipoControlador?: SortOrder
    IDMetodo?: SortOrder
    RelTipoControladorMetodo?: SortOrder
  }

  export type reltipocontroladormetodoWhereUniqueInput = {
    IDTipoControlador?: number
  }

  export type reltipocontroladormetodoOrderByWithAggregationInput = {
    IDTipoControlador?: SortOrder
    IDMetodo?: SortOrder
    RelTipoControladorMetodo?: SortOrder
    _count?: reltipocontroladormetodoCountOrderByAggregateInput
    _avg?: reltipocontroladormetodoAvgOrderByAggregateInput
    _max?: reltipocontroladormetodoMaxOrderByAggregateInput
    _min?: reltipocontroladormetodoMinOrderByAggregateInput
    _sum?: reltipocontroladormetodoSumOrderByAggregateInput
  }

  export type reltipocontroladormetodoScalarWhereWithAggregatesInput = {
    AND?: Enumerable<reltipocontroladormetodoScalarWhereWithAggregatesInput>
    OR?: Enumerable<reltipocontroladormetodoScalarWhereWithAggregatesInput>
    NOT?: Enumerable<reltipocontroladormetodoScalarWhereWithAggregatesInput>
    IDTipoControlador?: IntWithAggregatesFilter | number
    IDMetodo?: IntNullableWithAggregatesFilter | number | null
    RelTipoControladorMetodo?: IntNullableWithAggregatesFilter | number | null
  }

  export type reltipodispositivoperfildispositivoWhereInput = {
    AND?: Enumerable<reltipodispositivoperfildispositivoWhereInput>
    OR?: Enumerable<reltipodispositivoperfildispositivoWhereInput>
    NOT?: Enumerable<reltipodispositivoperfildispositivoWhereInput>
    IDRelTipoDispPerfil?: IntFilter | number
    IDTipoDispositivo?: IntFilter | number
    IDPerfilDispositivo?: IntFilter | number
  }

  export type reltipodispositivoperfildispositivoOrderByWithRelationInput = {
    IDRelTipoDispPerfil?: SortOrder
    IDTipoDispositivo?: SortOrder
    IDPerfilDispositivo?: SortOrder
  }

  export type reltipodispositivoperfildispositivoWhereUniqueInput = {
    IDRelTipoDispPerfil?: number
  }

  export type reltipodispositivoperfildispositivoOrderByWithAggregationInput = {
    IDRelTipoDispPerfil?: SortOrder
    IDTipoDispositivo?: SortOrder
    IDPerfilDispositivo?: SortOrder
    _count?: reltipodispositivoperfildispositivoCountOrderByAggregateInput
    _avg?: reltipodispositivoperfildispositivoAvgOrderByAggregateInput
    _max?: reltipodispositivoperfildispositivoMaxOrderByAggregateInput
    _min?: reltipodispositivoperfildispositivoMinOrderByAggregateInput
    _sum?: reltipodispositivoperfildispositivoSumOrderByAggregateInput
  }

  export type reltipodispositivoperfildispositivoScalarWhereWithAggregatesInput = {
    AND?: Enumerable<reltipodispositivoperfildispositivoScalarWhereWithAggregatesInput>
    OR?: Enumerable<reltipodispositivoperfildispositivoScalarWhereWithAggregatesInput>
    NOT?: Enumerable<reltipodispositivoperfildispositivoScalarWhereWithAggregatesInput>
    IDRelTipoDispPerfil?: IntWithAggregatesFilter | number
    IDTipoDispositivo?: IntWithAggregatesFilter | number
    IDPerfilDispositivo?: IntWithAggregatesFilter | number
  }

  export type reltipodispositivoperfileventoWhereInput = {
    AND?: Enumerable<reltipodispositivoperfileventoWhereInput>
    OR?: Enumerable<reltipodispositivoperfileventoWhereInput>
    NOT?: Enumerable<reltipodispositivoperfileventoWhereInput>
    IDRelTipoDisPerfilEvento?: IntFilter | number
    IDTipoDispositivo?: IntFilter | number
    IDPerfilEvento?: IntFilter | number
  }

  export type reltipodispositivoperfileventoOrderByWithRelationInput = {
    IDRelTipoDisPerfilEvento?: SortOrder
    IDTipoDispositivo?: SortOrder
    IDPerfilEvento?: SortOrder
  }

  export type reltipodispositivoperfileventoWhereUniqueInput = {
    IDRelTipoDisPerfilEvento?: number
  }

  export type reltipodispositivoperfileventoOrderByWithAggregationInput = {
    IDRelTipoDisPerfilEvento?: SortOrder
    IDTipoDispositivo?: SortOrder
    IDPerfilEvento?: SortOrder
    _count?: reltipodispositivoperfileventoCountOrderByAggregateInput
    _avg?: reltipodispositivoperfileventoAvgOrderByAggregateInput
    _max?: reltipodispositivoperfileventoMaxOrderByAggregateInput
    _min?: reltipodispositivoperfileventoMinOrderByAggregateInput
    _sum?: reltipodispositivoperfileventoSumOrderByAggregateInput
  }

  export type reltipodispositivoperfileventoScalarWhereWithAggregatesInput = {
    AND?: Enumerable<reltipodispositivoperfileventoScalarWhereWithAggregatesInput>
    OR?: Enumerable<reltipodispositivoperfileventoScalarWhereWithAggregatesInput>
    NOT?: Enumerable<reltipodispositivoperfileventoScalarWhereWithAggregatesInput>
    IDRelTipoDisPerfilEvento?: IntWithAggregatesFilter | number
    IDTipoDispositivo?: IntWithAggregatesFilter | number
    IDPerfilEvento?: IntWithAggregatesFilter | number
  }

  export type reltipodispositivotipotecnologiaWhereInput = {
    AND?: Enumerable<reltipodispositivotipotecnologiaWhereInput>
    OR?: Enumerable<reltipodispositivotipotecnologiaWhereInput>
    NOT?: Enumerable<reltipodispositivotipotecnologiaWhereInput>
    IDRelTipoDispTipoTec?: IntFilter | number
    IDTipoDispositivo?: IntFilter | number
    IDTipoTecnologia?: IntFilter | number
  }

  export type reltipodispositivotipotecnologiaOrderByWithRelationInput = {
    IDRelTipoDispTipoTec?: SortOrder
    IDTipoDispositivo?: SortOrder
    IDTipoTecnologia?: SortOrder
  }

  export type reltipodispositivotipotecnologiaWhereUniqueInput = {
    IDRelTipoDispTipoTec?: number
  }

  export type reltipodispositivotipotecnologiaOrderByWithAggregationInput = {
    IDRelTipoDispTipoTec?: SortOrder
    IDTipoDispositivo?: SortOrder
    IDTipoTecnologia?: SortOrder
    _count?: reltipodispositivotipotecnologiaCountOrderByAggregateInput
    _avg?: reltipodispositivotipotecnologiaAvgOrderByAggregateInput
    _max?: reltipodispositivotipotecnologiaMaxOrderByAggregateInput
    _min?: reltipodispositivotipotecnologiaMinOrderByAggregateInput
    _sum?: reltipodispositivotipotecnologiaSumOrderByAggregateInput
  }

  export type reltipodispositivotipotecnologiaScalarWhereWithAggregatesInput = {
    AND?: Enumerable<reltipodispositivotipotecnologiaScalarWhereWithAggregatesInput>
    OR?: Enumerable<reltipodispositivotipotecnologiaScalarWhereWithAggregatesInput>
    NOT?: Enumerable<reltipodispositivotipotecnologiaScalarWhereWithAggregatesInput>
    IDRelTipoDispTipoTec?: IntWithAggregatesFilter | number
    IDTipoDispositivo?: IntWithAggregatesFilter | number
    IDTipoTecnologia?: IntWithAggregatesFilter | number
  }

  export type reltipogatewayperfildispositivoWhereInput = {
    AND?: Enumerable<reltipogatewayperfildispositivoWhereInput>
    OR?: Enumerable<reltipogatewayperfildispositivoWhereInput>
    NOT?: Enumerable<reltipogatewayperfildispositivoWhereInput>
    IDRelTipoGatewayPerfil?: IntFilter | number
    IDTipoGateway?: IntNullableFilter | number | null
    IDPerfilDispositivo?: IntNullableFilter | number | null
  }

  export type reltipogatewayperfildispositivoOrderByWithRelationInput = {
    IDRelTipoGatewayPerfil?: SortOrder
    IDTipoGateway?: SortOrder
    IDPerfilDispositivo?: SortOrder
  }

  export type reltipogatewayperfildispositivoWhereUniqueInput = {
    IDRelTipoGatewayPerfil?: number
  }

  export type reltipogatewayperfildispositivoOrderByWithAggregationInput = {
    IDRelTipoGatewayPerfil?: SortOrder
    IDTipoGateway?: SortOrder
    IDPerfilDispositivo?: SortOrder
    _count?: reltipogatewayperfildispositivoCountOrderByAggregateInput
    _avg?: reltipogatewayperfildispositivoAvgOrderByAggregateInput
    _max?: reltipogatewayperfildispositivoMaxOrderByAggregateInput
    _min?: reltipogatewayperfildispositivoMinOrderByAggregateInput
    _sum?: reltipogatewayperfildispositivoSumOrderByAggregateInput
  }

  export type reltipogatewayperfildispositivoScalarWhereWithAggregatesInput = {
    AND?: Enumerable<reltipogatewayperfildispositivoScalarWhereWithAggregatesInput>
    OR?: Enumerable<reltipogatewayperfildispositivoScalarWhereWithAggregatesInput>
    NOT?: Enumerable<reltipogatewayperfildispositivoScalarWhereWithAggregatesInput>
    IDRelTipoGatewayPerfil?: IntWithAggregatesFilter | number
    IDTipoGateway?: IntNullableWithAggregatesFilter | number | null
    IDPerfilDispositivo?: IntNullableWithAggregatesFilter | number | null
  }

  export type subsistemasWhereInput = {
    AND?: Enumerable<subsistemasWhereInput>
    OR?: Enumerable<subsistemasWhereInput>
    NOT?: Enumerable<subsistemasWhereInput>
    IDSubSistema?: IntFilter | number
    NombreSubSistema?: StringNullableFilter | string | null
    DescripcionSubSistema?: StringNullableFilter | string | null
    URLSubSistema?: StringNullableFilter | string | null
    Puerto?: IntNullableFilter | number | null
  }

  export type subsistemasOrderByWithRelationInput = {
    IDSubSistema?: SortOrder
    NombreSubSistema?: SortOrder
    DescripcionSubSistema?: SortOrder
    URLSubSistema?: SortOrder
    Puerto?: SortOrder
  }

  export type subsistemasWhereUniqueInput = {
    IDSubSistema?: number
  }

  export type subsistemasOrderByWithAggregationInput = {
    IDSubSistema?: SortOrder
    NombreSubSistema?: SortOrder
    DescripcionSubSistema?: SortOrder
    URLSubSistema?: SortOrder
    Puerto?: SortOrder
    _count?: subsistemasCountOrderByAggregateInput
    _avg?: subsistemasAvgOrderByAggregateInput
    _max?: subsistemasMaxOrderByAggregateInput
    _min?: subsistemasMinOrderByAggregateInput
    _sum?: subsistemasSumOrderByAggregateInput
  }

  export type subsistemasScalarWhereWithAggregatesInput = {
    AND?: Enumerable<subsistemasScalarWhereWithAggregatesInput>
    OR?: Enumerable<subsistemasScalarWhereWithAggregatesInput>
    NOT?: Enumerable<subsistemasScalarWhereWithAggregatesInput>
    IDSubSistema?: IntWithAggregatesFilter | number
    NombreSubSistema?: StringNullableWithAggregatesFilter | string | null
    DescripcionSubSistema?: StringNullableWithAggregatesFilter | string | null
    URLSubSistema?: StringNullableWithAggregatesFilter | string | null
    Puerto?: IntNullableWithAggregatesFilter | number | null
  }

  export type tablasinformacionWhereInput = {
    AND?: Enumerable<tablasinformacionWhereInput>
    OR?: Enumerable<tablasinformacionWhereInput>
    NOT?: Enumerable<tablasinformacionWhereInput>
    IDTabla?: IntFilter | number
    NombreTabla?: StringNullableFilter | string | null
    Tipo?: IntNullableFilter | number | null
    Identidad?: StringNullableFilter | string | null
    CodigoNetsocs?: IntNullableFilter | number | null
  }

  export type tablasinformacionOrderByWithRelationInput = {
    IDTabla?: SortOrder
    NombreTabla?: SortOrder
    Tipo?: SortOrder
    Identidad?: SortOrder
    CodigoNetsocs?: SortOrder
  }

  export type tablasinformacionWhereUniqueInput = {
    IDTabla?: number
  }

  export type tablasinformacionOrderByWithAggregationInput = {
    IDTabla?: SortOrder
    NombreTabla?: SortOrder
    Tipo?: SortOrder
    Identidad?: SortOrder
    CodigoNetsocs?: SortOrder
    _count?: tablasinformacionCountOrderByAggregateInput
    _avg?: tablasinformacionAvgOrderByAggregateInput
    _max?: tablasinformacionMaxOrderByAggregateInput
    _min?: tablasinformacionMinOrderByAggregateInput
    _sum?: tablasinformacionSumOrderByAggregateInput
  }

  export type tablasinformacionScalarWhereWithAggregatesInput = {
    AND?: Enumerable<tablasinformacionScalarWhereWithAggregatesInput>
    OR?: Enumerable<tablasinformacionScalarWhereWithAggregatesInput>
    NOT?: Enumerable<tablasinformacionScalarWhereWithAggregatesInput>
    IDTabla?: IntWithAggregatesFilter | number
    NombreTabla?: StringNullableWithAggregatesFilter | string | null
    Tipo?: IntNullableWithAggregatesFilter | number | null
    Identidad?: StringNullableWithAggregatesFilter | string | null
    CodigoNetsocs?: IntNullableWithAggregatesFilter | number | null
  }

  export type tecnologiasnetsocsWhereInput = {
    AND?: Enumerable<tecnologiasnetsocsWhereInput>
    OR?: Enumerable<tecnologiasnetsocsWhereInput>
    NOT?: Enumerable<tecnologiasnetsocsWhereInput>
    IDTecnologiaGateway?: IntFilter | number
    NombreTecnologiaGateway?: StringNullableFilter | string | null
  }

  export type tecnologiasnetsocsOrderByWithRelationInput = {
    IDTecnologiaGateway?: SortOrder
    NombreTecnologiaGateway?: SortOrder
  }

  export type tecnologiasnetsocsWhereUniqueInput = {
    IDTecnologiaGateway?: number
  }

  export type tecnologiasnetsocsOrderByWithAggregationInput = {
    IDTecnologiaGateway?: SortOrder
    NombreTecnologiaGateway?: SortOrder
    _count?: tecnologiasnetsocsCountOrderByAggregateInput
    _avg?: tecnologiasnetsocsAvgOrderByAggregateInput
    _max?: tecnologiasnetsocsMaxOrderByAggregateInput
    _min?: tecnologiasnetsocsMinOrderByAggregateInput
    _sum?: tecnologiasnetsocsSumOrderByAggregateInput
  }

  export type tecnologiasnetsocsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<tecnologiasnetsocsScalarWhereWithAggregatesInput>
    OR?: Enumerable<tecnologiasnetsocsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<tecnologiasnetsocsScalarWhereWithAggregatesInput>
    IDTecnologiaGateway?: IntWithAggregatesFilter | number
    NombreTecnologiaGateway?: StringNullableWithAggregatesFilter | string | null
  }

  export type controladoresCreateInput = {
    IDEdificio?: number | null
    NombreControlador?: string | null
    Descripcion?: string | null
    IDIcono?: number | null
    TipoControlador?: number | null
    Prioridad?: string | null
    Certificado?: string | null
    PuertoSSL?: number | null
    PuertoNoSSL?: number | null
    PuertoMantenimiento?: number | null
    PuertoConexionSC?: number | null
    PuertoConexionCC?: number | null
    SOAP?: string | null
    Socket?: string | null
    API?: string | null
    Sincroniza?: string | null
    DireccionAIPV4?: string | null
    DireccionBIPv4?: string | null
    DireccionAIPV6?: string | null
    DireccionBIPv6?: string | null
    DireccionPublica1?: string | null
    DireccionPublica2?: string | null
    Localizacion?: string | null
    Latitud?: Decimal | DecimalJsLike | number | string | null
    Longitud?: Decimal | DecimalJsLike | number | string | null
    Estatus?: number | null
    FechaCreado?: Date | string | null
    FechaDesactivado?: Date | string | null
  }

  export type controladoresUncheckedCreateInput = {
    IDControlador?: number
    IDEdificio?: number | null
    NombreControlador?: string | null
    Descripcion?: string | null
    IDIcono?: number | null
    TipoControlador?: number | null
    Prioridad?: string | null
    Certificado?: string | null
    PuertoSSL?: number | null
    PuertoNoSSL?: number | null
    PuertoMantenimiento?: number | null
    PuertoConexionSC?: number | null
    PuertoConexionCC?: number | null
    SOAP?: string | null
    Socket?: string | null
    API?: string | null
    Sincroniza?: string | null
    DireccionAIPV4?: string | null
    DireccionBIPv4?: string | null
    DireccionAIPV6?: string | null
    DireccionBIPv6?: string | null
    DireccionPublica1?: string | null
    DireccionPublica2?: string | null
    Localizacion?: string | null
    Latitud?: Decimal | DecimalJsLike | number | string | null
    Longitud?: Decimal | DecimalJsLike | number | string | null
    Estatus?: number | null
    FechaCreado?: Date | string | null
    FechaDesactivado?: Date | string | null
  }

  export type controladoresUpdateInput = {
    IDEdificio?: NullableIntFieldUpdateOperationsInput | number | null
    NombreControlador?: NullableStringFieldUpdateOperationsInput | string | null
    Descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    IDIcono?: NullableIntFieldUpdateOperationsInput | number | null
    TipoControlador?: NullableIntFieldUpdateOperationsInput | number | null
    Prioridad?: NullableStringFieldUpdateOperationsInput | string | null
    Certificado?: NullableStringFieldUpdateOperationsInput | string | null
    PuertoSSL?: NullableIntFieldUpdateOperationsInput | number | null
    PuertoNoSSL?: NullableIntFieldUpdateOperationsInput | number | null
    PuertoMantenimiento?: NullableIntFieldUpdateOperationsInput | number | null
    PuertoConexionSC?: NullableIntFieldUpdateOperationsInput | number | null
    PuertoConexionCC?: NullableIntFieldUpdateOperationsInput | number | null
    SOAP?: NullableStringFieldUpdateOperationsInput | string | null
    Socket?: NullableStringFieldUpdateOperationsInput | string | null
    API?: NullableStringFieldUpdateOperationsInput | string | null
    Sincroniza?: NullableStringFieldUpdateOperationsInput | string | null
    DireccionAIPV4?: NullableStringFieldUpdateOperationsInput | string | null
    DireccionBIPv4?: NullableStringFieldUpdateOperationsInput | string | null
    DireccionAIPV6?: NullableStringFieldUpdateOperationsInput | string | null
    DireccionBIPv6?: NullableStringFieldUpdateOperationsInput | string | null
    DireccionPublica1?: NullableStringFieldUpdateOperationsInput | string | null
    DireccionPublica2?: NullableStringFieldUpdateOperationsInput | string | null
    Localizacion?: NullableStringFieldUpdateOperationsInput | string | null
    Latitud?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    Longitud?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    Estatus?: NullableIntFieldUpdateOperationsInput | number | null
    FechaCreado?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    FechaDesactivado?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type controladoresUncheckedUpdateInput = {
    IDControlador?: IntFieldUpdateOperationsInput | number
    IDEdificio?: NullableIntFieldUpdateOperationsInput | number | null
    NombreControlador?: NullableStringFieldUpdateOperationsInput | string | null
    Descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    IDIcono?: NullableIntFieldUpdateOperationsInput | number | null
    TipoControlador?: NullableIntFieldUpdateOperationsInput | number | null
    Prioridad?: NullableStringFieldUpdateOperationsInput | string | null
    Certificado?: NullableStringFieldUpdateOperationsInput | string | null
    PuertoSSL?: NullableIntFieldUpdateOperationsInput | number | null
    PuertoNoSSL?: NullableIntFieldUpdateOperationsInput | number | null
    PuertoMantenimiento?: NullableIntFieldUpdateOperationsInput | number | null
    PuertoConexionSC?: NullableIntFieldUpdateOperationsInput | number | null
    PuertoConexionCC?: NullableIntFieldUpdateOperationsInput | number | null
    SOAP?: NullableStringFieldUpdateOperationsInput | string | null
    Socket?: NullableStringFieldUpdateOperationsInput | string | null
    API?: NullableStringFieldUpdateOperationsInput | string | null
    Sincroniza?: NullableStringFieldUpdateOperationsInput | string | null
    DireccionAIPV4?: NullableStringFieldUpdateOperationsInput | string | null
    DireccionBIPv4?: NullableStringFieldUpdateOperationsInput | string | null
    DireccionAIPV6?: NullableStringFieldUpdateOperationsInput | string | null
    DireccionBIPv6?: NullableStringFieldUpdateOperationsInput | string | null
    DireccionPublica1?: NullableStringFieldUpdateOperationsInput | string | null
    DireccionPublica2?: NullableStringFieldUpdateOperationsInput | string | null
    Localizacion?: NullableStringFieldUpdateOperationsInput | string | null
    Latitud?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    Longitud?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    Estatus?: NullableIntFieldUpdateOperationsInput | number | null
    FechaCreado?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    FechaDesactivado?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type controladoresCreateManyInput = {
    IDControlador?: number
    IDEdificio?: number | null
    NombreControlador?: string | null
    Descripcion?: string | null
    IDIcono?: number | null
    TipoControlador?: number | null
    Prioridad?: string | null
    Certificado?: string | null
    PuertoSSL?: number | null
    PuertoNoSSL?: number | null
    PuertoMantenimiento?: number | null
    PuertoConexionSC?: number | null
    PuertoConexionCC?: number | null
    SOAP?: string | null
    Socket?: string | null
    API?: string | null
    Sincroniza?: string | null
    DireccionAIPV4?: string | null
    DireccionBIPv4?: string | null
    DireccionAIPV6?: string | null
    DireccionBIPv6?: string | null
    DireccionPublica1?: string | null
    DireccionPublica2?: string | null
    Localizacion?: string | null
    Latitud?: Decimal | DecimalJsLike | number | string | null
    Longitud?: Decimal | DecimalJsLike | number | string | null
    Estatus?: number | null
    FechaCreado?: Date | string | null
    FechaDesactivado?: Date | string | null
  }

  export type controladoresUpdateManyMutationInput = {
    IDEdificio?: NullableIntFieldUpdateOperationsInput | number | null
    NombreControlador?: NullableStringFieldUpdateOperationsInput | string | null
    Descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    IDIcono?: NullableIntFieldUpdateOperationsInput | number | null
    TipoControlador?: NullableIntFieldUpdateOperationsInput | number | null
    Prioridad?: NullableStringFieldUpdateOperationsInput | string | null
    Certificado?: NullableStringFieldUpdateOperationsInput | string | null
    PuertoSSL?: NullableIntFieldUpdateOperationsInput | number | null
    PuertoNoSSL?: NullableIntFieldUpdateOperationsInput | number | null
    PuertoMantenimiento?: NullableIntFieldUpdateOperationsInput | number | null
    PuertoConexionSC?: NullableIntFieldUpdateOperationsInput | number | null
    PuertoConexionCC?: NullableIntFieldUpdateOperationsInput | number | null
    SOAP?: NullableStringFieldUpdateOperationsInput | string | null
    Socket?: NullableStringFieldUpdateOperationsInput | string | null
    API?: NullableStringFieldUpdateOperationsInput | string | null
    Sincroniza?: NullableStringFieldUpdateOperationsInput | string | null
    DireccionAIPV4?: NullableStringFieldUpdateOperationsInput | string | null
    DireccionBIPv4?: NullableStringFieldUpdateOperationsInput | string | null
    DireccionAIPV6?: NullableStringFieldUpdateOperationsInput | string | null
    DireccionBIPv6?: NullableStringFieldUpdateOperationsInput | string | null
    DireccionPublica1?: NullableStringFieldUpdateOperationsInput | string | null
    DireccionPublica2?: NullableStringFieldUpdateOperationsInput | string | null
    Localizacion?: NullableStringFieldUpdateOperationsInput | string | null
    Latitud?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    Longitud?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    Estatus?: NullableIntFieldUpdateOperationsInput | number | null
    FechaCreado?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    FechaDesactivado?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type controladoresUncheckedUpdateManyInput = {
    IDControlador?: IntFieldUpdateOperationsInput | number
    IDEdificio?: NullableIntFieldUpdateOperationsInput | number | null
    NombreControlador?: NullableStringFieldUpdateOperationsInput | string | null
    Descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    IDIcono?: NullableIntFieldUpdateOperationsInput | number | null
    TipoControlador?: NullableIntFieldUpdateOperationsInput | number | null
    Prioridad?: NullableStringFieldUpdateOperationsInput | string | null
    Certificado?: NullableStringFieldUpdateOperationsInput | string | null
    PuertoSSL?: NullableIntFieldUpdateOperationsInput | number | null
    PuertoNoSSL?: NullableIntFieldUpdateOperationsInput | number | null
    PuertoMantenimiento?: NullableIntFieldUpdateOperationsInput | number | null
    PuertoConexionSC?: NullableIntFieldUpdateOperationsInput | number | null
    PuertoConexionCC?: NullableIntFieldUpdateOperationsInput | number | null
    SOAP?: NullableStringFieldUpdateOperationsInput | string | null
    Socket?: NullableStringFieldUpdateOperationsInput | string | null
    API?: NullableStringFieldUpdateOperationsInput | string | null
    Sincroniza?: NullableStringFieldUpdateOperationsInput | string | null
    DireccionAIPV4?: NullableStringFieldUpdateOperationsInput | string | null
    DireccionBIPv4?: NullableStringFieldUpdateOperationsInput | string | null
    DireccionAIPV6?: NullableStringFieldUpdateOperationsInput | string | null
    DireccionBIPv6?: NullableStringFieldUpdateOperationsInput | string | null
    DireccionPublica1?: NullableStringFieldUpdateOperationsInput | string | null
    DireccionPublica2?: NullableStringFieldUpdateOperationsInput | string | null
    Localizacion?: NullableStringFieldUpdateOperationsInput | string | null
    Latitud?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    Longitud?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    Estatus?: NullableIntFieldUpdateOperationsInput | number | null
    FechaCreado?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    FechaDesactivado?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type dispositivosCreateInput = {
    IDSubsistema?: number | null
    IDTipoFamilia?: number | null
    IDFamilia?: number | null
    IDFabricante?: number | null
    IDTipoDispositivo?: number | null
    IDGateway?: number | null
    IDControlador?: number | null
    IDModelo?: number | null
    IDEdificio?: number | null
    IDZona?: number | null
    IDPuerta?: number | null
    NombreDispositivo?: string | null
    Descripcion?: string | null
    IDIconografia?: number | null
    IDMenuPropio?: number | null
    Estatus?: string | null
    Sentidos?: string | null
    Ignorado?: string | null
    Enrolamiento?: string | null
    Latitud?: Decimal | DecimalJsLike | number | string | null
    Longitud?: Decimal | DecimalJsLike | number | string | null
    DireccionGPS?: string | null
    GeometriaGPS?: string | null
    IDTipoEvento?: number | null
    IDModeloElemento?: number | null
    FechaCreacion?: Date | string | null
    FechaDesactivacion?: Date | string | null
    FechaEliminacion?: Date | string | null
    Parametros?: string | null
    Certificado?: string | null
    PuertoSSL?: number | null
    PuertoNoSSL?: number | null
    PuertoMantenimiento?: number | null
    PuertoConexionSC?: number | null
    PuertoConexionCC?: number | null
    SOAP?: string | null
    Socket?: string | null
    API?: string | null
    Sincroniza?: string | null
    DireccionAIPV4?: string | null
    DireccionBIPv4?: string | null
    DireccionAIPV6?: string | null
    DireccionBIPv6?: string | null
    DireccionPublica1?: string | null
    DireccionPublica2?: string | null
    Serial?: string | null
    user?: string | null
    password?: string | null
    IDManual?: number | null
    Directo?: number | null
  }

  export type dispositivosUncheckedCreateInput = {
    IDDispositivo?: number
    IDSubsistema?: number | null
    IDTipoFamilia?: number | null
    IDFamilia?: number | null
    IDFabricante?: number | null
    IDTipoDispositivo?: number | null
    IDGateway?: number | null
    IDControlador?: number | null
    IDModelo?: number | null
    IDEdificio?: number | null
    IDZona?: number | null
    IDPuerta?: number | null
    NombreDispositivo?: string | null
    Descripcion?: string | null
    IDIconografia?: number | null
    IDMenuPropio?: number | null
    Estatus?: string | null
    Sentidos?: string | null
    Ignorado?: string | null
    Enrolamiento?: string | null
    Latitud?: Decimal | DecimalJsLike | number | string | null
    Longitud?: Decimal | DecimalJsLike | number | string | null
    DireccionGPS?: string | null
    GeometriaGPS?: string | null
    IDTipoEvento?: number | null
    IDModeloElemento?: number | null
    FechaCreacion?: Date | string | null
    FechaDesactivacion?: Date | string | null
    FechaEliminacion?: Date | string | null
    Parametros?: string | null
    Certificado?: string | null
    PuertoSSL?: number | null
    PuertoNoSSL?: number | null
    PuertoMantenimiento?: number | null
    PuertoConexionSC?: number | null
    PuertoConexionCC?: number | null
    SOAP?: string | null
    Socket?: string | null
    API?: string | null
    Sincroniza?: string | null
    DireccionAIPV4?: string | null
    DireccionBIPv4?: string | null
    DireccionAIPV6?: string | null
    DireccionBIPv6?: string | null
    DireccionPublica1?: string | null
    DireccionPublica2?: string | null
    Serial?: string | null
    user?: string | null
    password?: string | null
    IDManual?: number | null
    Directo?: number | null
  }

  export type dispositivosUpdateInput = {
    IDSubsistema?: NullableIntFieldUpdateOperationsInput | number | null
    IDTipoFamilia?: NullableIntFieldUpdateOperationsInput | number | null
    IDFamilia?: NullableIntFieldUpdateOperationsInput | number | null
    IDFabricante?: NullableIntFieldUpdateOperationsInput | number | null
    IDTipoDispositivo?: NullableIntFieldUpdateOperationsInput | number | null
    IDGateway?: NullableIntFieldUpdateOperationsInput | number | null
    IDControlador?: NullableIntFieldUpdateOperationsInput | number | null
    IDModelo?: NullableIntFieldUpdateOperationsInput | number | null
    IDEdificio?: NullableIntFieldUpdateOperationsInput | number | null
    IDZona?: NullableIntFieldUpdateOperationsInput | number | null
    IDPuerta?: NullableIntFieldUpdateOperationsInput | number | null
    NombreDispositivo?: NullableStringFieldUpdateOperationsInput | string | null
    Descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    IDIconografia?: NullableIntFieldUpdateOperationsInput | number | null
    IDMenuPropio?: NullableIntFieldUpdateOperationsInput | number | null
    Estatus?: NullableStringFieldUpdateOperationsInput | string | null
    Sentidos?: NullableStringFieldUpdateOperationsInput | string | null
    Ignorado?: NullableStringFieldUpdateOperationsInput | string | null
    Enrolamiento?: NullableStringFieldUpdateOperationsInput | string | null
    Latitud?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    Longitud?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    DireccionGPS?: NullableStringFieldUpdateOperationsInput | string | null
    GeometriaGPS?: NullableStringFieldUpdateOperationsInput | string | null
    IDTipoEvento?: NullableIntFieldUpdateOperationsInput | number | null
    IDModeloElemento?: NullableIntFieldUpdateOperationsInput | number | null
    FechaCreacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    FechaDesactivacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    FechaEliminacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Parametros?: NullableStringFieldUpdateOperationsInput | string | null
    Certificado?: NullableStringFieldUpdateOperationsInput | string | null
    PuertoSSL?: NullableIntFieldUpdateOperationsInput | number | null
    PuertoNoSSL?: NullableIntFieldUpdateOperationsInput | number | null
    PuertoMantenimiento?: NullableIntFieldUpdateOperationsInput | number | null
    PuertoConexionSC?: NullableIntFieldUpdateOperationsInput | number | null
    PuertoConexionCC?: NullableIntFieldUpdateOperationsInput | number | null
    SOAP?: NullableStringFieldUpdateOperationsInput | string | null
    Socket?: NullableStringFieldUpdateOperationsInput | string | null
    API?: NullableStringFieldUpdateOperationsInput | string | null
    Sincroniza?: NullableStringFieldUpdateOperationsInput | string | null
    DireccionAIPV4?: NullableStringFieldUpdateOperationsInput | string | null
    DireccionBIPv4?: NullableStringFieldUpdateOperationsInput | string | null
    DireccionAIPV6?: NullableStringFieldUpdateOperationsInput | string | null
    DireccionBIPv6?: NullableStringFieldUpdateOperationsInput | string | null
    DireccionPublica1?: NullableStringFieldUpdateOperationsInput | string | null
    DireccionPublica2?: NullableStringFieldUpdateOperationsInput | string | null
    Serial?: NullableStringFieldUpdateOperationsInput | string | null
    user?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    IDManual?: NullableIntFieldUpdateOperationsInput | number | null
    Directo?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type dispositivosUncheckedUpdateInput = {
    IDDispositivo?: IntFieldUpdateOperationsInput | number
    IDSubsistema?: NullableIntFieldUpdateOperationsInput | number | null
    IDTipoFamilia?: NullableIntFieldUpdateOperationsInput | number | null
    IDFamilia?: NullableIntFieldUpdateOperationsInput | number | null
    IDFabricante?: NullableIntFieldUpdateOperationsInput | number | null
    IDTipoDispositivo?: NullableIntFieldUpdateOperationsInput | number | null
    IDGateway?: NullableIntFieldUpdateOperationsInput | number | null
    IDControlador?: NullableIntFieldUpdateOperationsInput | number | null
    IDModelo?: NullableIntFieldUpdateOperationsInput | number | null
    IDEdificio?: NullableIntFieldUpdateOperationsInput | number | null
    IDZona?: NullableIntFieldUpdateOperationsInput | number | null
    IDPuerta?: NullableIntFieldUpdateOperationsInput | number | null
    NombreDispositivo?: NullableStringFieldUpdateOperationsInput | string | null
    Descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    IDIconografia?: NullableIntFieldUpdateOperationsInput | number | null
    IDMenuPropio?: NullableIntFieldUpdateOperationsInput | number | null
    Estatus?: NullableStringFieldUpdateOperationsInput | string | null
    Sentidos?: NullableStringFieldUpdateOperationsInput | string | null
    Ignorado?: NullableStringFieldUpdateOperationsInput | string | null
    Enrolamiento?: NullableStringFieldUpdateOperationsInput | string | null
    Latitud?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    Longitud?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    DireccionGPS?: NullableStringFieldUpdateOperationsInput | string | null
    GeometriaGPS?: NullableStringFieldUpdateOperationsInput | string | null
    IDTipoEvento?: NullableIntFieldUpdateOperationsInput | number | null
    IDModeloElemento?: NullableIntFieldUpdateOperationsInput | number | null
    FechaCreacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    FechaDesactivacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    FechaEliminacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Parametros?: NullableStringFieldUpdateOperationsInput | string | null
    Certificado?: NullableStringFieldUpdateOperationsInput | string | null
    PuertoSSL?: NullableIntFieldUpdateOperationsInput | number | null
    PuertoNoSSL?: NullableIntFieldUpdateOperationsInput | number | null
    PuertoMantenimiento?: NullableIntFieldUpdateOperationsInput | number | null
    PuertoConexionSC?: NullableIntFieldUpdateOperationsInput | number | null
    PuertoConexionCC?: NullableIntFieldUpdateOperationsInput | number | null
    SOAP?: NullableStringFieldUpdateOperationsInput | string | null
    Socket?: NullableStringFieldUpdateOperationsInput | string | null
    API?: NullableStringFieldUpdateOperationsInput | string | null
    Sincroniza?: NullableStringFieldUpdateOperationsInput | string | null
    DireccionAIPV4?: NullableStringFieldUpdateOperationsInput | string | null
    DireccionBIPv4?: NullableStringFieldUpdateOperationsInput | string | null
    DireccionAIPV6?: NullableStringFieldUpdateOperationsInput | string | null
    DireccionBIPv6?: NullableStringFieldUpdateOperationsInput | string | null
    DireccionPublica1?: NullableStringFieldUpdateOperationsInput | string | null
    DireccionPublica2?: NullableStringFieldUpdateOperationsInput | string | null
    Serial?: NullableStringFieldUpdateOperationsInput | string | null
    user?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    IDManual?: NullableIntFieldUpdateOperationsInput | number | null
    Directo?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type dispositivosCreateManyInput = {
    IDDispositivo?: number
    IDSubsistema?: number | null
    IDTipoFamilia?: number | null
    IDFamilia?: number | null
    IDFabricante?: number | null
    IDTipoDispositivo?: number | null
    IDGateway?: number | null
    IDControlador?: number | null
    IDModelo?: number | null
    IDEdificio?: number | null
    IDZona?: number | null
    IDPuerta?: number | null
    NombreDispositivo?: string | null
    Descripcion?: string | null
    IDIconografia?: number | null
    IDMenuPropio?: number | null
    Estatus?: string | null
    Sentidos?: string | null
    Ignorado?: string | null
    Enrolamiento?: string | null
    Latitud?: Decimal | DecimalJsLike | number | string | null
    Longitud?: Decimal | DecimalJsLike | number | string | null
    DireccionGPS?: string | null
    GeometriaGPS?: string | null
    IDTipoEvento?: number | null
    IDModeloElemento?: number | null
    FechaCreacion?: Date | string | null
    FechaDesactivacion?: Date | string | null
    FechaEliminacion?: Date | string | null
    Parametros?: string | null
    Certificado?: string | null
    PuertoSSL?: number | null
    PuertoNoSSL?: number | null
    PuertoMantenimiento?: number | null
    PuertoConexionSC?: number | null
    PuertoConexionCC?: number | null
    SOAP?: string | null
    Socket?: string | null
    API?: string | null
    Sincroniza?: string | null
    DireccionAIPV4?: string | null
    DireccionBIPv4?: string | null
    DireccionAIPV6?: string | null
    DireccionBIPv6?: string | null
    DireccionPublica1?: string | null
    DireccionPublica2?: string | null
    Serial?: string | null
    user?: string | null
    password?: string | null
    IDManual?: number | null
    Directo?: number | null
  }

  export type dispositivosUpdateManyMutationInput = {
    IDSubsistema?: NullableIntFieldUpdateOperationsInput | number | null
    IDTipoFamilia?: NullableIntFieldUpdateOperationsInput | number | null
    IDFamilia?: NullableIntFieldUpdateOperationsInput | number | null
    IDFabricante?: NullableIntFieldUpdateOperationsInput | number | null
    IDTipoDispositivo?: NullableIntFieldUpdateOperationsInput | number | null
    IDGateway?: NullableIntFieldUpdateOperationsInput | number | null
    IDControlador?: NullableIntFieldUpdateOperationsInput | number | null
    IDModelo?: NullableIntFieldUpdateOperationsInput | number | null
    IDEdificio?: NullableIntFieldUpdateOperationsInput | number | null
    IDZona?: NullableIntFieldUpdateOperationsInput | number | null
    IDPuerta?: NullableIntFieldUpdateOperationsInput | number | null
    NombreDispositivo?: NullableStringFieldUpdateOperationsInput | string | null
    Descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    IDIconografia?: NullableIntFieldUpdateOperationsInput | number | null
    IDMenuPropio?: NullableIntFieldUpdateOperationsInput | number | null
    Estatus?: NullableStringFieldUpdateOperationsInput | string | null
    Sentidos?: NullableStringFieldUpdateOperationsInput | string | null
    Ignorado?: NullableStringFieldUpdateOperationsInput | string | null
    Enrolamiento?: NullableStringFieldUpdateOperationsInput | string | null
    Latitud?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    Longitud?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    DireccionGPS?: NullableStringFieldUpdateOperationsInput | string | null
    GeometriaGPS?: NullableStringFieldUpdateOperationsInput | string | null
    IDTipoEvento?: NullableIntFieldUpdateOperationsInput | number | null
    IDModeloElemento?: NullableIntFieldUpdateOperationsInput | number | null
    FechaCreacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    FechaDesactivacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    FechaEliminacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Parametros?: NullableStringFieldUpdateOperationsInput | string | null
    Certificado?: NullableStringFieldUpdateOperationsInput | string | null
    PuertoSSL?: NullableIntFieldUpdateOperationsInput | number | null
    PuertoNoSSL?: NullableIntFieldUpdateOperationsInput | number | null
    PuertoMantenimiento?: NullableIntFieldUpdateOperationsInput | number | null
    PuertoConexionSC?: NullableIntFieldUpdateOperationsInput | number | null
    PuertoConexionCC?: NullableIntFieldUpdateOperationsInput | number | null
    SOAP?: NullableStringFieldUpdateOperationsInput | string | null
    Socket?: NullableStringFieldUpdateOperationsInput | string | null
    API?: NullableStringFieldUpdateOperationsInput | string | null
    Sincroniza?: NullableStringFieldUpdateOperationsInput | string | null
    DireccionAIPV4?: NullableStringFieldUpdateOperationsInput | string | null
    DireccionBIPv4?: NullableStringFieldUpdateOperationsInput | string | null
    DireccionAIPV6?: NullableStringFieldUpdateOperationsInput | string | null
    DireccionBIPv6?: NullableStringFieldUpdateOperationsInput | string | null
    DireccionPublica1?: NullableStringFieldUpdateOperationsInput | string | null
    DireccionPublica2?: NullableStringFieldUpdateOperationsInput | string | null
    Serial?: NullableStringFieldUpdateOperationsInput | string | null
    user?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    IDManual?: NullableIntFieldUpdateOperationsInput | number | null
    Directo?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type dispositivosUncheckedUpdateManyInput = {
    IDDispositivo?: IntFieldUpdateOperationsInput | number
    IDSubsistema?: NullableIntFieldUpdateOperationsInput | number | null
    IDTipoFamilia?: NullableIntFieldUpdateOperationsInput | number | null
    IDFamilia?: NullableIntFieldUpdateOperationsInput | number | null
    IDFabricante?: NullableIntFieldUpdateOperationsInput | number | null
    IDTipoDispositivo?: NullableIntFieldUpdateOperationsInput | number | null
    IDGateway?: NullableIntFieldUpdateOperationsInput | number | null
    IDControlador?: NullableIntFieldUpdateOperationsInput | number | null
    IDModelo?: NullableIntFieldUpdateOperationsInput | number | null
    IDEdificio?: NullableIntFieldUpdateOperationsInput | number | null
    IDZona?: NullableIntFieldUpdateOperationsInput | number | null
    IDPuerta?: NullableIntFieldUpdateOperationsInput | number | null
    NombreDispositivo?: NullableStringFieldUpdateOperationsInput | string | null
    Descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    IDIconografia?: NullableIntFieldUpdateOperationsInput | number | null
    IDMenuPropio?: NullableIntFieldUpdateOperationsInput | number | null
    Estatus?: NullableStringFieldUpdateOperationsInput | string | null
    Sentidos?: NullableStringFieldUpdateOperationsInput | string | null
    Ignorado?: NullableStringFieldUpdateOperationsInput | string | null
    Enrolamiento?: NullableStringFieldUpdateOperationsInput | string | null
    Latitud?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    Longitud?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    DireccionGPS?: NullableStringFieldUpdateOperationsInput | string | null
    GeometriaGPS?: NullableStringFieldUpdateOperationsInput | string | null
    IDTipoEvento?: NullableIntFieldUpdateOperationsInput | number | null
    IDModeloElemento?: NullableIntFieldUpdateOperationsInput | number | null
    FechaCreacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    FechaDesactivacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    FechaEliminacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Parametros?: NullableStringFieldUpdateOperationsInput | string | null
    Certificado?: NullableStringFieldUpdateOperationsInput | string | null
    PuertoSSL?: NullableIntFieldUpdateOperationsInput | number | null
    PuertoNoSSL?: NullableIntFieldUpdateOperationsInput | number | null
    PuertoMantenimiento?: NullableIntFieldUpdateOperationsInput | number | null
    PuertoConexionSC?: NullableIntFieldUpdateOperationsInput | number | null
    PuertoConexionCC?: NullableIntFieldUpdateOperationsInput | number | null
    SOAP?: NullableStringFieldUpdateOperationsInput | string | null
    Socket?: NullableStringFieldUpdateOperationsInput | string | null
    API?: NullableStringFieldUpdateOperationsInput | string | null
    Sincroniza?: NullableStringFieldUpdateOperationsInput | string | null
    DireccionAIPV4?: NullableStringFieldUpdateOperationsInput | string | null
    DireccionBIPv4?: NullableStringFieldUpdateOperationsInput | string | null
    DireccionAIPV6?: NullableStringFieldUpdateOperationsInput | string | null
    DireccionBIPv6?: NullableStringFieldUpdateOperationsInput | string | null
    DireccionPublica1?: NullableStringFieldUpdateOperationsInput | string | null
    DireccionPublica2?: NullableStringFieldUpdateOperationsInput | string | null
    Serial?: NullableStringFieldUpdateOperationsInput | string | null
    user?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    IDManual?: NullableIntFieldUpdateOperationsInput | number | null
    Directo?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type gatewayCreateInput = {
    IDTipoGateway?: number | null
    IDControlador?: number | null
    IDEdificio?: number | null
    IDIdentificadorExterno?: string | null
    IDTipoEvento?: number | null
    IDGrupoMetodo?: number | null
    NAbonado?: string | null
    NombreGateway?: string | null
    Descripcion?: string | null
    IDIcono?: number | null
    ValorEstado?: Buffer | null
    Parametros?: string | null
    EstadoOnOff?: string | null
    Latitud?: Decimal | DecimalJsLike | number | string | null
    Longitud?: Decimal | DecimalJsLike | number | string | null
    SerialGPS?: string | null
    GeometriaGPS?: string | null
    FechaCreado?: Date | string | null
    FechaDesactivado?: Date | string | null
    Certificado?: string | null
    PuertoSSL?: number | null
    PuertoNoSSL?: number | null
    PuertoMantenimiento?: number | null
    PuertoConexionSC?: number | null
    PuertoConexionCC?: number | null
    SOAP?: string | null
    Socket?: string | null
    API?: string | null
    Sincroniza?: string | null
    DireccionAIPV4?: string | null
    DireccionBIPv4?: string | null
    DireccionAIPV6?: string | null
    DireccionBIPv6?: string | null
    DireccionPublica1?: string | null
    DireccionPublica2?: string | null
    user?: string | null
    password?: string | null
    Serial?: string | null
    IDManual?: number | null
    IDZona?: number | null
  }

  export type gatewayUncheckedCreateInput = {
    IDGateway?: number
    IDTipoGateway?: number | null
    IDControlador?: number | null
    IDEdificio?: number | null
    IDIdentificadorExterno?: string | null
    IDTipoEvento?: number | null
    IDGrupoMetodo?: number | null
    NAbonado?: string | null
    NombreGateway?: string | null
    Descripcion?: string | null
    IDIcono?: number | null
    ValorEstado?: Buffer | null
    Parametros?: string | null
    EstadoOnOff?: string | null
    Latitud?: Decimal | DecimalJsLike | number | string | null
    Longitud?: Decimal | DecimalJsLike | number | string | null
    SerialGPS?: string | null
    GeometriaGPS?: string | null
    FechaCreado?: Date | string | null
    FechaDesactivado?: Date | string | null
    Certificado?: string | null
    PuertoSSL?: number | null
    PuertoNoSSL?: number | null
    PuertoMantenimiento?: number | null
    PuertoConexionSC?: number | null
    PuertoConexionCC?: number | null
    SOAP?: string | null
    Socket?: string | null
    API?: string | null
    Sincroniza?: string | null
    DireccionAIPV4?: string | null
    DireccionBIPv4?: string | null
    DireccionAIPV6?: string | null
    DireccionBIPv6?: string | null
    DireccionPublica1?: string | null
    DireccionPublica2?: string | null
    user?: string | null
    password?: string | null
    Serial?: string | null
    IDManual?: number | null
    IDZona?: number | null
  }

  export type gatewayUpdateInput = {
    IDTipoGateway?: NullableIntFieldUpdateOperationsInput | number | null
    IDControlador?: NullableIntFieldUpdateOperationsInput | number | null
    IDEdificio?: NullableIntFieldUpdateOperationsInput | number | null
    IDIdentificadorExterno?: NullableStringFieldUpdateOperationsInput | string | null
    IDTipoEvento?: NullableIntFieldUpdateOperationsInput | number | null
    IDGrupoMetodo?: NullableIntFieldUpdateOperationsInput | number | null
    NAbonado?: NullableStringFieldUpdateOperationsInput | string | null
    NombreGateway?: NullableStringFieldUpdateOperationsInput | string | null
    Descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    IDIcono?: NullableIntFieldUpdateOperationsInput | number | null
    ValorEstado?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    Parametros?: NullableStringFieldUpdateOperationsInput | string | null
    EstadoOnOff?: NullableStringFieldUpdateOperationsInput | string | null
    Latitud?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    Longitud?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    SerialGPS?: NullableStringFieldUpdateOperationsInput | string | null
    GeometriaGPS?: NullableStringFieldUpdateOperationsInput | string | null
    FechaCreado?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    FechaDesactivado?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Certificado?: NullableStringFieldUpdateOperationsInput | string | null
    PuertoSSL?: NullableIntFieldUpdateOperationsInput | number | null
    PuertoNoSSL?: NullableIntFieldUpdateOperationsInput | number | null
    PuertoMantenimiento?: NullableIntFieldUpdateOperationsInput | number | null
    PuertoConexionSC?: NullableIntFieldUpdateOperationsInput | number | null
    PuertoConexionCC?: NullableIntFieldUpdateOperationsInput | number | null
    SOAP?: NullableStringFieldUpdateOperationsInput | string | null
    Socket?: NullableStringFieldUpdateOperationsInput | string | null
    API?: NullableStringFieldUpdateOperationsInput | string | null
    Sincroniza?: NullableStringFieldUpdateOperationsInput | string | null
    DireccionAIPV4?: NullableStringFieldUpdateOperationsInput | string | null
    DireccionBIPv4?: NullableStringFieldUpdateOperationsInput | string | null
    DireccionAIPV6?: NullableStringFieldUpdateOperationsInput | string | null
    DireccionBIPv6?: NullableStringFieldUpdateOperationsInput | string | null
    DireccionPublica1?: NullableStringFieldUpdateOperationsInput | string | null
    DireccionPublica2?: NullableStringFieldUpdateOperationsInput | string | null
    user?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    Serial?: NullableStringFieldUpdateOperationsInput | string | null
    IDManual?: NullableIntFieldUpdateOperationsInput | number | null
    IDZona?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type gatewayUncheckedUpdateInput = {
    IDGateway?: IntFieldUpdateOperationsInput | number
    IDTipoGateway?: NullableIntFieldUpdateOperationsInput | number | null
    IDControlador?: NullableIntFieldUpdateOperationsInput | number | null
    IDEdificio?: NullableIntFieldUpdateOperationsInput | number | null
    IDIdentificadorExterno?: NullableStringFieldUpdateOperationsInput | string | null
    IDTipoEvento?: NullableIntFieldUpdateOperationsInput | number | null
    IDGrupoMetodo?: NullableIntFieldUpdateOperationsInput | number | null
    NAbonado?: NullableStringFieldUpdateOperationsInput | string | null
    NombreGateway?: NullableStringFieldUpdateOperationsInput | string | null
    Descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    IDIcono?: NullableIntFieldUpdateOperationsInput | number | null
    ValorEstado?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    Parametros?: NullableStringFieldUpdateOperationsInput | string | null
    EstadoOnOff?: NullableStringFieldUpdateOperationsInput | string | null
    Latitud?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    Longitud?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    SerialGPS?: NullableStringFieldUpdateOperationsInput | string | null
    GeometriaGPS?: NullableStringFieldUpdateOperationsInput | string | null
    FechaCreado?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    FechaDesactivado?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Certificado?: NullableStringFieldUpdateOperationsInput | string | null
    PuertoSSL?: NullableIntFieldUpdateOperationsInput | number | null
    PuertoNoSSL?: NullableIntFieldUpdateOperationsInput | number | null
    PuertoMantenimiento?: NullableIntFieldUpdateOperationsInput | number | null
    PuertoConexionSC?: NullableIntFieldUpdateOperationsInput | number | null
    PuertoConexionCC?: NullableIntFieldUpdateOperationsInput | number | null
    SOAP?: NullableStringFieldUpdateOperationsInput | string | null
    Socket?: NullableStringFieldUpdateOperationsInput | string | null
    API?: NullableStringFieldUpdateOperationsInput | string | null
    Sincroniza?: NullableStringFieldUpdateOperationsInput | string | null
    DireccionAIPV4?: NullableStringFieldUpdateOperationsInput | string | null
    DireccionBIPv4?: NullableStringFieldUpdateOperationsInput | string | null
    DireccionAIPV6?: NullableStringFieldUpdateOperationsInput | string | null
    DireccionBIPv6?: NullableStringFieldUpdateOperationsInput | string | null
    DireccionPublica1?: NullableStringFieldUpdateOperationsInput | string | null
    DireccionPublica2?: NullableStringFieldUpdateOperationsInput | string | null
    user?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    Serial?: NullableStringFieldUpdateOperationsInput | string | null
    IDManual?: NullableIntFieldUpdateOperationsInput | number | null
    IDZona?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type gatewayCreateManyInput = {
    IDGateway?: number
    IDTipoGateway?: number | null
    IDControlador?: number | null
    IDEdificio?: number | null
    IDIdentificadorExterno?: string | null
    IDTipoEvento?: number | null
    IDGrupoMetodo?: number | null
    NAbonado?: string | null
    NombreGateway?: string | null
    Descripcion?: string | null
    IDIcono?: number | null
    ValorEstado?: Buffer | null
    Parametros?: string | null
    EstadoOnOff?: string | null
    Latitud?: Decimal | DecimalJsLike | number | string | null
    Longitud?: Decimal | DecimalJsLike | number | string | null
    SerialGPS?: string | null
    GeometriaGPS?: string | null
    FechaCreado?: Date | string | null
    FechaDesactivado?: Date | string | null
    Certificado?: string | null
    PuertoSSL?: number | null
    PuertoNoSSL?: number | null
    PuertoMantenimiento?: number | null
    PuertoConexionSC?: number | null
    PuertoConexionCC?: number | null
    SOAP?: string | null
    Socket?: string | null
    API?: string | null
    Sincroniza?: string | null
    DireccionAIPV4?: string | null
    DireccionBIPv4?: string | null
    DireccionAIPV6?: string | null
    DireccionBIPv6?: string | null
    DireccionPublica1?: string | null
    DireccionPublica2?: string | null
    user?: string | null
    password?: string | null
    Serial?: string | null
    IDManual?: number | null
    IDZona?: number | null
  }

  export type gatewayUpdateManyMutationInput = {
    IDTipoGateway?: NullableIntFieldUpdateOperationsInput | number | null
    IDControlador?: NullableIntFieldUpdateOperationsInput | number | null
    IDEdificio?: NullableIntFieldUpdateOperationsInput | number | null
    IDIdentificadorExterno?: NullableStringFieldUpdateOperationsInput | string | null
    IDTipoEvento?: NullableIntFieldUpdateOperationsInput | number | null
    IDGrupoMetodo?: NullableIntFieldUpdateOperationsInput | number | null
    NAbonado?: NullableStringFieldUpdateOperationsInput | string | null
    NombreGateway?: NullableStringFieldUpdateOperationsInput | string | null
    Descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    IDIcono?: NullableIntFieldUpdateOperationsInput | number | null
    ValorEstado?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    Parametros?: NullableStringFieldUpdateOperationsInput | string | null
    EstadoOnOff?: NullableStringFieldUpdateOperationsInput | string | null
    Latitud?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    Longitud?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    SerialGPS?: NullableStringFieldUpdateOperationsInput | string | null
    GeometriaGPS?: NullableStringFieldUpdateOperationsInput | string | null
    FechaCreado?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    FechaDesactivado?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Certificado?: NullableStringFieldUpdateOperationsInput | string | null
    PuertoSSL?: NullableIntFieldUpdateOperationsInput | number | null
    PuertoNoSSL?: NullableIntFieldUpdateOperationsInput | number | null
    PuertoMantenimiento?: NullableIntFieldUpdateOperationsInput | number | null
    PuertoConexionSC?: NullableIntFieldUpdateOperationsInput | number | null
    PuertoConexionCC?: NullableIntFieldUpdateOperationsInput | number | null
    SOAP?: NullableStringFieldUpdateOperationsInput | string | null
    Socket?: NullableStringFieldUpdateOperationsInput | string | null
    API?: NullableStringFieldUpdateOperationsInput | string | null
    Sincroniza?: NullableStringFieldUpdateOperationsInput | string | null
    DireccionAIPV4?: NullableStringFieldUpdateOperationsInput | string | null
    DireccionBIPv4?: NullableStringFieldUpdateOperationsInput | string | null
    DireccionAIPV6?: NullableStringFieldUpdateOperationsInput | string | null
    DireccionBIPv6?: NullableStringFieldUpdateOperationsInput | string | null
    DireccionPublica1?: NullableStringFieldUpdateOperationsInput | string | null
    DireccionPublica2?: NullableStringFieldUpdateOperationsInput | string | null
    user?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    Serial?: NullableStringFieldUpdateOperationsInput | string | null
    IDManual?: NullableIntFieldUpdateOperationsInput | number | null
    IDZona?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type gatewayUncheckedUpdateManyInput = {
    IDGateway?: IntFieldUpdateOperationsInput | number
    IDTipoGateway?: NullableIntFieldUpdateOperationsInput | number | null
    IDControlador?: NullableIntFieldUpdateOperationsInput | number | null
    IDEdificio?: NullableIntFieldUpdateOperationsInput | number | null
    IDIdentificadorExterno?: NullableStringFieldUpdateOperationsInput | string | null
    IDTipoEvento?: NullableIntFieldUpdateOperationsInput | number | null
    IDGrupoMetodo?: NullableIntFieldUpdateOperationsInput | number | null
    NAbonado?: NullableStringFieldUpdateOperationsInput | string | null
    NombreGateway?: NullableStringFieldUpdateOperationsInput | string | null
    Descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    IDIcono?: NullableIntFieldUpdateOperationsInput | number | null
    ValorEstado?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    Parametros?: NullableStringFieldUpdateOperationsInput | string | null
    EstadoOnOff?: NullableStringFieldUpdateOperationsInput | string | null
    Latitud?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    Longitud?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    SerialGPS?: NullableStringFieldUpdateOperationsInput | string | null
    GeometriaGPS?: NullableStringFieldUpdateOperationsInput | string | null
    FechaCreado?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    FechaDesactivado?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Certificado?: NullableStringFieldUpdateOperationsInput | string | null
    PuertoSSL?: NullableIntFieldUpdateOperationsInput | number | null
    PuertoNoSSL?: NullableIntFieldUpdateOperationsInput | number | null
    PuertoMantenimiento?: NullableIntFieldUpdateOperationsInput | number | null
    PuertoConexionSC?: NullableIntFieldUpdateOperationsInput | number | null
    PuertoConexionCC?: NullableIntFieldUpdateOperationsInput | number | null
    SOAP?: NullableStringFieldUpdateOperationsInput | string | null
    Socket?: NullableStringFieldUpdateOperationsInput | string | null
    API?: NullableStringFieldUpdateOperationsInput | string | null
    Sincroniza?: NullableStringFieldUpdateOperationsInput | string | null
    DireccionAIPV4?: NullableStringFieldUpdateOperationsInput | string | null
    DireccionBIPv4?: NullableStringFieldUpdateOperationsInput | string | null
    DireccionAIPV6?: NullableStringFieldUpdateOperationsInput | string | null
    DireccionBIPv6?: NullableStringFieldUpdateOperationsInput | string | null
    DireccionPublica1?: NullableStringFieldUpdateOperationsInput | string | null
    DireccionPublica2?: NullableStringFieldUpdateOperationsInput | string | null
    user?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    Serial?: NullableStringFieldUpdateOperationsInput | string | null
    IDManual?: NullableIntFieldUpdateOperationsInput | number | null
    IDZona?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type gruposdispositivosCreateInput = {
    NombreGrupoDispositivo?: string | null
    Identificador?: string | null
    Descripcion?: string | null
  }

  export type gruposdispositivosUncheckedCreateInput = {
    IDGrupoDispositivo?: number
    NombreGrupoDispositivo?: string | null
    Identificador?: string | null
    Descripcion?: string | null
  }

  export type gruposdispositivosUpdateInput = {
    NombreGrupoDispositivo?: NullableStringFieldUpdateOperationsInput | string | null
    Identificador?: NullableStringFieldUpdateOperationsInput | string | null
    Descripcion?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type gruposdispositivosUncheckedUpdateInput = {
    IDGrupoDispositivo?: IntFieldUpdateOperationsInput | number
    NombreGrupoDispositivo?: NullableStringFieldUpdateOperationsInput | string | null
    Identificador?: NullableStringFieldUpdateOperationsInput | string | null
    Descripcion?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type gruposdispositivosCreateManyInput = {
    IDGrupoDispositivo?: number
    NombreGrupoDispositivo?: string | null
    Identificador?: string | null
    Descripcion?: string | null
  }

  export type gruposdispositivosUpdateManyMutationInput = {
    NombreGrupoDispositivo?: NullableStringFieldUpdateOperationsInput | string | null
    Identificador?: NullableStringFieldUpdateOperationsInput | string | null
    Descripcion?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type gruposdispositivosUncheckedUpdateManyInput = {
    IDGrupoDispositivo?: IntFieldUpdateOperationsInput | number
    NombreGrupoDispositivo?: NullableStringFieldUpdateOperationsInput | string | null
    Identificador?: NullableStringFieldUpdateOperationsInput | string | null
    Descripcion?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type inventariocatastroCreateInput = {
    IDTipoEntidadInventario?: number | null
    IDCategoriaEntidadInventario?: number | null
    IDGateway?: number | null
    IDDispositivo?: number | null
    IDMetaEdificio?: number | null
    IDEdificio?: number | null
    NombreEntidadInventario?: string | null
    Descripcion?: string | null
    Latitud?: Decimal | DecimalJsLike | number | string | null
    Longitud?: Decimal | DecimalJsLike | number | string | null
    SerialGPS?: string | null
    GeometriaGPS?: string | null
    FechaAlta?: Date | string | null
    FechaBaja?: Date | string | null
  }

  export type inventariocatastroUncheckedCreateInput = {
    IDEntidadInventario?: number
    IDTipoEntidadInventario?: number | null
    IDCategoriaEntidadInventario?: number | null
    IDGateway?: number | null
    IDDispositivo?: number | null
    IDMetaEdificio?: number | null
    IDEdificio?: number | null
    NombreEntidadInventario?: string | null
    Descripcion?: string | null
    Latitud?: Decimal | DecimalJsLike | number | string | null
    Longitud?: Decimal | DecimalJsLike | number | string | null
    SerialGPS?: string | null
    GeometriaGPS?: string | null
    FechaAlta?: Date | string | null
    FechaBaja?: Date | string | null
  }

  export type inventariocatastroUpdateInput = {
    IDTipoEntidadInventario?: NullableIntFieldUpdateOperationsInput | number | null
    IDCategoriaEntidadInventario?: NullableIntFieldUpdateOperationsInput | number | null
    IDGateway?: NullableIntFieldUpdateOperationsInput | number | null
    IDDispositivo?: NullableIntFieldUpdateOperationsInput | number | null
    IDMetaEdificio?: NullableIntFieldUpdateOperationsInput | number | null
    IDEdificio?: NullableIntFieldUpdateOperationsInput | number | null
    NombreEntidadInventario?: NullableStringFieldUpdateOperationsInput | string | null
    Descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    Latitud?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    Longitud?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    SerialGPS?: NullableStringFieldUpdateOperationsInput | string | null
    GeometriaGPS?: NullableStringFieldUpdateOperationsInput | string | null
    FechaAlta?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    FechaBaja?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type inventariocatastroUncheckedUpdateInput = {
    IDEntidadInventario?: IntFieldUpdateOperationsInput | number
    IDTipoEntidadInventario?: NullableIntFieldUpdateOperationsInput | number | null
    IDCategoriaEntidadInventario?: NullableIntFieldUpdateOperationsInput | number | null
    IDGateway?: NullableIntFieldUpdateOperationsInput | number | null
    IDDispositivo?: NullableIntFieldUpdateOperationsInput | number | null
    IDMetaEdificio?: NullableIntFieldUpdateOperationsInput | number | null
    IDEdificio?: NullableIntFieldUpdateOperationsInput | number | null
    NombreEntidadInventario?: NullableStringFieldUpdateOperationsInput | string | null
    Descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    Latitud?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    Longitud?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    SerialGPS?: NullableStringFieldUpdateOperationsInput | string | null
    GeometriaGPS?: NullableStringFieldUpdateOperationsInput | string | null
    FechaAlta?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    FechaBaja?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type inventariocatastroCreateManyInput = {
    IDEntidadInventario?: number
    IDTipoEntidadInventario?: number | null
    IDCategoriaEntidadInventario?: number | null
    IDGateway?: number | null
    IDDispositivo?: number | null
    IDMetaEdificio?: number | null
    IDEdificio?: number | null
    NombreEntidadInventario?: string | null
    Descripcion?: string | null
    Latitud?: Decimal | DecimalJsLike | number | string | null
    Longitud?: Decimal | DecimalJsLike | number | string | null
    SerialGPS?: string | null
    GeometriaGPS?: string | null
    FechaAlta?: Date | string | null
    FechaBaja?: Date | string | null
  }

  export type inventariocatastroUpdateManyMutationInput = {
    IDTipoEntidadInventario?: NullableIntFieldUpdateOperationsInput | number | null
    IDCategoriaEntidadInventario?: NullableIntFieldUpdateOperationsInput | number | null
    IDGateway?: NullableIntFieldUpdateOperationsInput | number | null
    IDDispositivo?: NullableIntFieldUpdateOperationsInput | number | null
    IDMetaEdificio?: NullableIntFieldUpdateOperationsInput | number | null
    IDEdificio?: NullableIntFieldUpdateOperationsInput | number | null
    NombreEntidadInventario?: NullableStringFieldUpdateOperationsInput | string | null
    Descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    Latitud?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    Longitud?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    SerialGPS?: NullableStringFieldUpdateOperationsInput | string | null
    GeometriaGPS?: NullableStringFieldUpdateOperationsInput | string | null
    FechaAlta?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    FechaBaja?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type inventariocatastroUncheckedUpdateManyInput = {
    IDEntidadInventario?: IntFieldUpdateOperationsInput | number
    IDTipoEntidadInventario?: NullableIntFieldUpdateOperationsInput | number | null
    IDCategoriaEntidadInventario?: NullableIntFieldUpdateOperationsInput | number | null
    IDGateway?: NullableIntFieldUpdateOperationsInput | number | null
    IDDispositivo?: NullableIntFieldUpdateOperationsInput | number | null
    IDMetaEdificio?: NullableIntFieldUpdateOperationsInput | number | null
    IDEdificio?: NullableIntFieldUpdateOperationsInput | number | null
    NombreEntidadInventario?: NullableStringFieldUpdateOperationsInput | string | null
    Descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    Latitud?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    Longitud?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    SerialGPS?: NullableStringFieldUpdateOperationsInput | string | null
    GeometriaGPS?: NullableStringFieldUpdateOperationsInput | string | null
    FechaAlta?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    FechaBaja?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type libreriasapisCreateInput = {
    Nombre?: string | null
    Tipo?: string | null
    Web?: string | null
    Subsistema?: number | null
    Alcance?: string | null
  }

  export type libreriasapisUncheckedCreateInput = {
    IDLIBAPISDK?: number
    Nombre?: string | null
    Tipo?: string | null
    Web?: string | null
    Subsistema?: number | null
    Alcance?: string | null
  }

  export type libreriasapisUpdateInput = {
    Nombre?: NullableStringFieldUpdateOperationsInput | string | null
    Tipo?: NullableStringFieldUpdateOperationsInput | string | null
    Web?: NullableStringFieldUpdateOperationsInput | string | null
    Subsistema?: NullableIntFieldUpdateOperationsInput | number | null
    Alcance?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type libreriasapisUncheckedUpdateInput = {
    IDLIBAPISDK?: IntFieldUpdateOperationsInput | number
    Nombre?: NullableStringFieldUpdateOperationsInput | string | null
    Tipo?: NullableStringFieldUpdateOperationsInput | string | null
    Web?: NullableStringFieldUpdateOperationsInput | string | null
    Subsistema?: NullableIntFieldUpdateOperationsInput | number | null
    Alcance?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type libreriasapisCreateManyInput = {
    IDLIBAPISDK?: number
    Nombre?: string | null
    Tipo?: string | null
    Web?: string | null
    Subsistema?: number | null
    Alcance?: string | null
  }

  export type libreriasapisUpdateManyMutationInput = {
    Nombre?: NullableStringFieldUpdateOperationsInput | string | null
    Tipo?: NullableStringFieldUpdateOperationsInput | string | null
    Web?: NullableStringFieldUpdateOperationsInput | string | null
    Subsistema?: NullableIntFieldUpdateOperationsInput | number | null
    Alcance?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type libreriasapisUncheckedUpdateManyInput = {
    IDLIBAPISDK?: IntFieldUpdateOperationsInput | number
    Nombre?: NullableStringFieldUpdateOperationsInput | string | null
    Tipo?: NullableStringFieldUpdateOperationsInput | string | null
    Web?: NullableStringFieldUpdateOperationsInput | string | null
    Subsistema?: NullableIntFieldUpdateOperationsInput | number | null
    Alcance?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type metodogrupoCreateInput = {
    NombreGrupoMetodo?: string | null
    Corporacion?: string | null
    Departamento?: string | null
    Edificio?: string | null
    Itinerario?: string | null
    Empleado?: string | null
    Modificable?: string | null
    Descripcion?: string | null
    Tipo?: string | null
    IDGrupoMetodoPadre?: number | null
    Identificador?: string | null
    IdentificadorExterno?: string | null
  }

  export type metodogrupoUncheckedCreateInput = {
    IDGrupoMetodo?: number
    NombreGrupoMetodo?: string | null
    Corporacion?: string | null
    Departamento?: string | null
    Edificio?: string | null
    Itinerario?: string | null
    Empleado?: string | null
    Modificable?: string | null
    Descripcion?: string | null
    Tipo?: string | null
    IDGrupoMetodoPadre?: number | null
    Identificador?: string | null
    IdentificadorExterno?: string | null
  }

  export type metodogrupoUpdateInput = {
    NombreGrupoMetodo?: NullableStringFieldUpdateOperationsInput | string | null
    Corporacion?: NullableStringFieldUpdateOperationsInput | string | null
    Departamento?: NullableStringFieldUpdateOperationsInput | string | null
    Edificio?: NullableStringFieldUpdateOperationsInput | string | null
    Itinerario?: NullableStringFieldUpdateOperationsInput | string | null
    Empleado?: NullableStringFieldUpdateOperationsInput | string | null
    Modificable?: NullableStringFieldUpdateOperationsInput | string | null
    Descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    Tipo?: NullableStringFieldUpdateOperationsInput | string | null
    IDGrupoMetodoPadre?: NullableIntFieldUpdateOperationsInput | number | null
    Identificador?: NullableStringFieldUpdateOperationsInput | string | null
    IdentificadorExterno?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type metodogrupoUncheckedUpdateInput = {
    IDGrupoMetodo?: IntFieldUpdateOperationsInput | number
    NombreGrupoMetodo?: NullableStringFieldUpdateOperationsInput | string | null
    Corporacion?: NullableStringFieldUpdateOperationsInput | string | null
    Departamento?: NullableStringFieldUpdateOperationsInput | string | null
    Edificio?: NullableStringFieldUpdateOperationsInput | string | null
    Itinerario?: NullableStringFieldUpdateOperationsInput | string | null
    Empleado?: NullableStringFieldUpdateOperationsInput | string | null
    Modificable?: NullableStringFieldUpdateOperationsInput | string | null
    Descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    Tipo?: NullableStringFieldUpdateOperationsInput | string | null
    IDGrupoMetodoPadre?: NullableIntFieldUpdateOperationsInput | number | null
    Identificador?: NullableStringFieldUpdateOperationsInput | string | null
    IdentificadorExterno?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type metodogrupoCreateManyInput = {
    IDGrupoMetodo?: number
    NombreGrupoMetodo?: string | null
    Corporacion?: string | null
    Departamento?: string | null
    Edificio?: string | null
    Itinerario?: string | null
    Empleado?: string | null
    Modificable?: string | null
    Descripcion?: string | null
    Tipo?: string | null
    IDGrupoMetodoPadre?: number | null
    Identificador?: string | null
    IdentificadorExterno?: string | null
  }

  export type metodogrupoUpdateManyMutationInput = {
    NombreGrupoMetodo?: NullableStringFieldUpdateOperationsInput | string | null
    Corporacion?: NullableStringFieldUpdateOperationsInput | string | null
    Departamento?: NullableStringFieldUpdateOperationsInput | string | null
    Edificio?: NullableStringFieldUpdateOperationsInput | string | null
    Itinerario?: NullableStringFieldUpdateOperationsInput | string | null
    Empleado?: NullableStringFieldUpdateOperationsInput | string | null
    Modificable?: NullableStringFieldUpdateOperationsInput | string | null
    Descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    Tipo?: NullableStringFieldUpdateOperationsInput | string | null
    IDGrupoMetodoPadre?: NullableIntFieldUpdateOperationsInput | number | null
    Identificador?: NullableStringFieldUpdateOperationsInput | string | null
    IdentificadorExterno?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type metodogrupoUncheckedUpdateManyInput = {
    IDGrupoMetodo?: IntFieldUpdateOperationsInput | number
    NombreGrupoMetodo?: NullableStringFieldUpdateOperationsInput | string | null
    Corporacion?: NullableStringFieldUpdateOperationsInput | string | null
    Departamento?: NullableStringFieldUpdateOperationsInput | string | null
    Edificio?: NullableStringFieldUpdateOperationsInput | string | null
    Itinerario?: NullableStringFieldUpdateOperationsInput | string | null
    Empleado?: NullableStringFieldUpdateOperationsInput | string | null
    Modificable?: NullableStringFieldUpdateOperationsInput | string | null
    Descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    Tipo?: NullableStringFieldUpdateOperationsInput | string | null
    IDGrupoMetodoPadre?: NullableIntFieldUpdateOperationsInput | number | null
    Identificador?: NullableStringFieldUpdateOperationsInput | string | null
    IdentificadorExterno?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type metodosCreateInput = {
    Indice: number
    IDGrupoMetodo: number
    IDLibreria?: number | null
    IDMetodoPadre?: number | null
    Clase: string
    Tipo: string
    Propagable: string
    BlobsPropagable: string
    NParametros: number
    NParametrosBinarios: number
    Basico: string
    Estado: string
    Descripcion?: string | null
    NombreMetodo?: string | null
    NombreFuncion?: string | null
    MetodoTrigger?: string | null
    EnvioAplicacion: string
    EjecucionLibre: string
  }

  export type metodosUncheckedCreateInput = {
    IDMetodo?: number
    Indice: number
    IDGrupoMetodo: number
    IDLibreria?: number | null
    IDMetodoPadre?: number | null
    Clase: string
    Tipo: string
    Propagable: string
    BlobsPropagable: string
    NParametros: number
    NParametrosBinarios: number
    Basico: string
    Estado: string
    Descripcion?: string | null
    NombreMetodo?: string | null
    NombreFuncion?: string | null
    MetodoTrigger?: string | null
    EnvioAplicacion: string
    EjecucionLibre: string
  }

  export type metodosUpdateInput = {
    Indice?: IntFieldUpdateOperationsInput | number
    IDGrupoMetodo?: IntFieldUpdateOperationsInput | number
    IDLibreria?: NullableIntFieldUpdateOperationsInput | number | null
    IDMetodoPadre?: NullableIntFieldUpdateOperationsInput | number | null
    Clase?: StringFieldUpdateOperationsInput | string
    Tipo?: StringFieldUpdateOperationsInput | string
    Propagable?: StringFieldUpdateOperationsInput | string
    BlobsPropagable?: StringFieldUpdateOperationsInput | string
    NParametros?: IntFieldUpdateOperationsInput | number
    NParametrosBinarios?: IntFieldUpdateOperationsInput | number
    Basico?: StringFieldUpdateOperationsInput | string
    Estado?: StringFieldUpdateOperationsInput | string
    Descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    NombreMetodo?: NullableStringFieldUpdateOperationsInput | string | null
    NombreFuncion?: NullableStringFieldUpdateOperationsInput | string | null
    MetodoTrigger?: NullableStringFieldUpdateOperationsInput | string | null
    EnvioAplicacion?: StringFieldUpdateOperationsInput | string
    EjecucionLibre?: StringFieldUpdateOperationsInput | string
  }

  export type metodosUncheckedUpdateInput = {
    IDMetodo?: IntFieldUpdateOperationsInput | number
    Indice?: IntFieldUpdateOperationsInput | number
    IDGrupoMetodo?: IntFieldUpdateOperationsInput | number
    IDLibreria?: NullableIntFieldUpdateOperationsInput | number | null
    IDMetodoPadre?: NullableIntFieldUpdateOperationsInput | number | null
    Clase?: StringFieldUpdateOperationsInput | string
    Tipo?: StringFieldUpdateOperationsInput | string
    Propagable?: StringFieldUpdateOperationsInput | string
    BlobsPropagable?: StringFieldUpdateOperationsInput | string
    NParametros?: IntFieldUpdateOperationsInput | number
    NParametrosBinarios?: IntFieldUpdateOperationsInput | number
    Basico?: StringFieldUpdateOperationsInput | string
    Estado?: StringFieldUpdateOperationsInput | string
    Descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    NombreMetodo?: NullableStringFieldUpdateOperationsInput | string | null
    NombreFuncion?: NullableStringFieldUpdateOperationsInput | string | null
    MetodoTrigger?: NullableStringFieldUpdateOperationsInput | string | null
    EnvioAplicacion?: StringFieldUpdateOperationsInput | string
    EjecucionLibre?: StringFieldUpdateOperationsInput | string
  }

  export type metodosCreateManyInput = {
    IDMetodo?: number
    Indice: number
    IDGrupoMetodo: number
    IDLibreria?: number | null
    IDMetodoPadre?: number | null
    Clase: string
    Tipo: string
    Propagable: string
    BlobsPropagable: string
    NParametros: number
    NParametrosBinarios: number
    Basico: string
    Estado: string
    Descripcion?: string | null
    NombreMetodo?: string | null
    NombreFuncion?: string | null
    MetodoTrigger?: string | null
    EnvioAplicacion: string
    EjecucionLibre: string
  }

  export type metodosUpdateManyMutationInput = {
    Indice?: IntFieldUpdateOperationsInput | number
    IDGrupoMetodo?: IntFieldUpdateOperationsInput | number
    IDLibreria?: NullableIntFieldUpdateOperationsInput | number | null
    IDMetodoPadre?: NullableIntFieldUpdateOperationsInput | number | null
    Clase?: StringFieldUpdateOperationsInput | string
    Tipo?: StringFieldUpdateOperationsInput | string
    Propagable?: StringFieldUpdateOperationsInput | string
    BlobsPropagable?: StringFieldUpdateOperationsInput | string
    NParametros?: IntFieldUpdateOperationsInput | number
    NParametrosBinarios?: IntFieldUpdateOperationsInput | number
    Basico?: StringFieldUpdateOperationsInput | string
    Estado?: StringFieldUpdateOperationsInput | string
    Descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    NombreMetodo?: NullableStringFieldUpdateOperationsInput | string | null
    NombreFuncion?: NullableStringFieldUpdateOperationsInput | string | null
    MetodoTrigger?: NullableStringFieldUpdateOperationsInput | string | null
    EnvioAplicacion?: StringFieldUpdateOperationsInput | string
    EjecucionLibre?: StringFieldUpdateOperationsInput | string
  }

  export type metodosUncheckedUpdateManyInput = {
    IDMetodo?: IntFieldUpdateOperationsInput | number
    Indice?: IntFieldUpdateOperationsInput | number
    IDGrupoMetodo?: IntFieldUpdateOperationsInput | number
    IDLibreria?: NullableIntFieldUpdateOperationsInput | number | null
    IDMetodoPadre?: NullableIntFieldUpdateOperationsInput | number | null
    Clase?: StringFieldUpdateOperationsInput | string
    Tipo?: StringFieldUpdateOperationsInput | string
    Propagable?: StringFieldUpdateOperationsInput | string
    BlobsPropagable?: StringFieldUpdateOperationsInput | string
    NParametros?: IntFieldUpdateOperationsInput | number
    NParametrosBinarios?: IntFieldUpdateOperationsInput | number
    Basico?: StringFieldUpdateOperationsInput | string
    Estado?: StringFieldUpdateOperationsInput | string
    Descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    NombreMetodo?: NullableStringFieldUpdateOperationsInput | string | null
    NombreFuncion?: NullableStringFieldUpdateOperationsInput | string | null
    MetodoTrigger?: NullableStringFieldUpdateOperationsInput | string | null
    EnvioAplicacion?: StringFieldUpdateOperationsInput | string
    EjecucionLibre?: StringFieldUpdateOperationsInput | string
  }

  export type objetosplanimetriaCreateInput = {
    NombreObjeto?: string | null
    URLHost?: string | null
    IpHost?: string | null
    Puerto?: number | null
    Usuario?: string | null
    Clave?: string | null
  }

  export type objetosplanimetriaUncheckedCreateInput = {
    Id?: number
    NombreObjeto?: string | null
    URLHost?: string | null
    IpHost?: string | null
    Puerto?: number | null
    Usuario?: string | null
    Clave?: string | null
  }

  export type objetosplanimetriaUpdateInput = {
    NombreObjeto?: NullableStringFieldUpdateOperationsInput | string | null
    URLHost?: NullableStringFieldUpdateOperationsInput | string | null
    IpHost?: NullableStringFieldUpdateOperationsInput | string | null
    Puerto?: NullableIntFieldUpdateOperationsInput | number | null
    Usuario?: NullableStringFieldUpdateOperationsInput | string | null
    Clave?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type objetosplanimetriaUncheckedUpdateInput = {
    Id?: IntFieldUpdateOperationsInput | number
    NombreObjeto?: NullableStringFieldUpdateOperationsInput | string | null
    URLHost?: NullableStringFieldUpdateOperationsInput | string | null
    IpHost?: NullableStringFieldUpdateOperationsInput | string | null
    Puerto?: NullableIntFieldUpdateOperationsInput | number | null
    Usuario?: NullableStringFieldUpdateOperationsInput | string | null
    Clave?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type objetosplanimetriaCreateManyInput = {
    Id?: number
    NombreObjeto?: string | null
    URLHost?: string | null
    IpHost?: string | null
    Puerto?: number | null
    Usuario?: string | null
    Clave?: string | null
  }

  export type objetosplanimetriaUpdateManyMutationInput = {
    NombreObjeto?: NullableStringFieldUpdateOperationsInput | string | null
    URLHost?: NullableStringFieldUpdateOperationsInput | string | null
    IpHost?: NullableStringFieldUpdateOperationsInput | string | null
    Puerto?: NullableIntFieldUpdateOperationsInput | number | null
    Usuario?: NullableStringFieldUpdateOperationsInput | string | null
    Clave?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type objetosplanimetriaUncheckedUpdateManyInput = {
    Id?: IntFieldUpdateOperationsInput | number
    NombreObjeto?: NullableStringFieldUpdateOperationsInput | string | null
    URLHost?: NullableStringFieldUpdateOperationsInput | string | null
    IpHost?: NullableStringFieldUpdateOperationsInput | string | null
    Puerto?: NullableIntFieldUpdateOperationsInput | number | null
    Usuario?: NullableStringFieldUpdateOperationsInput | string | null
    Clave?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type reldispositivodispositivoCreateInput = {
    IDDispositivoPadre?: number | null
    IDDispositivoHijo?: number | null
  }

  export type reldispositivodispositivoUncheckedCreateInput = {
    IDRelDisDispositivo?: number
    IDDispositivoPadre?: number | null
    IDDispositivoHijo?: number | null
  }

  export type reldispositivodispositivoUpdateInput = {
    IDDispositivoPadre?: NullableIntFieldUpdateOperationsInput | number | null
    IDDispositivoHijo?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type reldispositivodispositivoUncheckedUpdateInput = {
    IDRelDisDispositivo?: IntFieldUpdateOperationsInput | number
    IDDispositivoPadre?: NullableIntFieldUpdateOperationsInput | number | null
    IDDispositivoHijo?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type reldispositivodispositivoCreateManyInput = {
    IDRelDisDispositivo?: number
    IDDispositivoPadre?: number | null
    IDDispositivoHijo?: number | null
  }

  export type reldispositivodispositivoUpdateManyMutationInput = {
    IDDispositivoPadre?: NullableIntFieldUpdateOperationsInput | number | null
    IDDispositivoHijo?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type reldispositivodispositivoUncheckedUpdateManyInput = {
    IDRelDisDispositivo?: IntFieldUpdateOperationsInput | number
    IDDispositivoPadre?: NullableIntFieldUpdateOperationsInput | number | null
    IDDispositivoHijo?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type reldispositivogatewayCreateInput = {
    IDDispositivo?: number | null
    IDGateway?: number | null
  }

  export type reldispositivogatewayUncheckedCreateInput = {
    IDRelDisGateway?: number
    IDDispositivo?: number | null
    IDGateway?: number | null
  }

  export type reldispositivogatewayUpdateInput = {
    IDDispositivo?: NullableIntFieldUpdateOperationsInput | number | null
    IDGateway?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type reldispositivogatewayUncheckedUpdateInput = {
    IDRelDisGateway?: IntFieldUpdateOperationsInput | number
    IDDispositivo?: NullableIntFieldUpdateOperationsInput | number | null
    IDGateway?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type reldispositivogatewayCreateManyInput = {
    IDRelDisGateway?: number
    IDDispositivo?: number | null
    IDGateway?: number | null
  }

  export type reldispositivogatewayUpdateManyMutationInput = {
    IDDispositivo?: NullableIntFieldUpdateOperationsInput | number | null
    IDGateway?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type reldispositivogatewayUncheckedUpdateManyInput = {
    IDRelDisGateway?: IntFieldUpdateOperationsInput | number
    IDDispositivo?: NullableIntFieldUpdateOperationsInput | number | null
    IDGateway?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type reldispositivogrupodispositivoCreateInput = {
    IDGrupo?: string | null
    IDDispositivo?: string | null
  }

  export type reldispositivogrupodispositivoUncheckedCreateInput = {
    IDRelDisGrupoDis?: number
    IDGrupo?: string | null
    IDDispositivo?: string | null
  }

  export type reldispositivogrupodispositivoUpdateInput = {
    IDGrupo?: NullableStringFieldUpdateOperationsInput | string | null
    IDDispositivo?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type reldispositivogrupodispositivoUncheckedUpdateInput = {
    IDRelDisGrupoDis?: IntFieldUpdateOperationsInput | number
    IDGrupo?: NullableStringFieldUpdateOperationsInput | string | null
    IDDispositivo?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type reldispositivogrupodispositivoCreateManyInput = {
    IDRelDisGrupoDis?: number
    IDGrupo?: string | null
    IDDispositivo?: string | null
  }

  export type reldispositivogrupodispositivoUpdateManyMutationInput = {
    IDGrupo?: NullableStringFieldUpdateOperationsInput | string | null
    IDDispositivo?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type reldispositivogrupodispositivoUncheckedUpdateManyInput = {
    IDRelDisGrupoDis?: IntFieldUpdateOperationsInput | number
    IDGrupo?: NullableStringFieldUpdateOperationsInput | string | null
    IDDispositivo?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type reldispositivoperfildispositivoCreateInput = {
    IDDispositivo: number
    IDPerfilDispositivo: number
  }

  export type reldispositivoperfildispositivoUncheckedCreateInput = {
    IDRelDisPerfil?: number
    IDDispositivo: number
    IDPerfilDispositivo: number
  }

  export type reldispositivoperfildispositivoUpdateInput = {
    IDDispositivo?: IntFieldUpdateOperationsInput | number
    IDPerfilDispositivo?: IntFieldUpdateOperationsInput | number
  }

  export type reldispositivoperfildispositivoUncheckedUpdateInput = {
    IDRelDisPerfil?: IntFieldUpdateOperationsInput | number
    IDDispositivo?: IntFieldUpdateOperationsInput | number
    IDPerfilDispositivo?: IntFieldUpdateOperationsInput | number
  }

  export type reldispositivoperfildispositivoCreateManyInput = {
    IDRelDisPerfil?: number
    IDDispositivo: number
    IDPerfilDispositivo: number
  }

  export type reldispositivoperfildispositivoUpdateManyMutationInput = {
    IDDispositivo?: IntFieldUpdateOperationsInput | number
    IDPerfilDispositivo?: IntFieldUpdateOperationsInput | number
  }

  export type reldispositivoperfildispositivoUncheckedUpdateManyInput = {
    IDRelDisPerfil?: IntFieldUpdateOperationsInput | number
    IDDispositivo?: IntFieldUpdateOperationsInput | number
    IDPerfilDispositivo?: IntFieldUpdateOperationsInput | number
  }

  export type reldispositivoplantillaanalogicaCreateInput = {
    IDPlantillaAnalogica: number
    IDDispositivo: number
    Formula?: string | null
    Version?: string | null
  }

  export type reldispositivoplantillaanalogicaUncheckedCreateInput = {
    IDRelDisPlantillaAnaloga?: number
    IDPlantillaAnalogica: number
    IDDispositivo: number
    Formula?: string | null
    Version?: string | null
  }

  export type reldispositivoplantillaanalogicaUpdateInput = {
    IDPlantillaAnalogica?: IntFieldUpdateOperationsInput | number
    IDDispositivo?: IntFieldUpdateOperationsInput | number
    Formula?: NullableStringFieldUpdateOperationsInput | string | null
    Version?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type reldispositivoplantillaanalogicaUncheckedUpdateInput = {
    IDRelDisPlantillaAnaloga?: IntFieldUpdateOperationsInput | number
    IDPlantillaAnalogica?: IntFieldUpdateOperationsInput | number
    IDDispositivo?: IntFieldUpdateOperationsInput | number
    Formula?: NullableStringFieldUpdateOperationsInput | string | null
    Version?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type reldispositivoplantillaanalogicaCreateManyInput = {
    IDRelDisPlantillaAnaloga?: number
    IDPlantillaAnalogica: number
    IDDispositivo: number
    Formula?: string | null
    Version?: string | null
  }

  export type reldispositivoplantillaanalogicaUpdateManyMutationInput = {
    IDPlantillaAnalogica?: IntFieldUpdateOperationsInput | number
    IDDispositivo?: IntFieldUpdateOperationsInput | number
    Formula?: NullableStringFieldUpdateOperationsInput | string | null
    Version?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type reldispositivoplantillaanalogicaUncheckedUpdateManyInput = {
    IDRelDisPlantillaAnaloga?: IntFieldUpdateOperationsInput | number
    IDPlantillaAnalogica?: IntFieldUpdateOperationsInput | number
    IDDispositivo?: IntFieldUpdateOperationsInput | number
    Formula?: NullableStringFieldUpdateOperationsInput | string | null
    Version?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type reldispositivopuertaCreateInput = {
    IDDispositivo: number
    IDPuerta: number
    IDTipoDispositivo: number
  }

  export type reldispositivopuertaUncheckedCreateInput = {
    IDRelDisPuerta?: number
    IDDispositivo: number
    IDPuerta: number
    IDTipoDispositivo: number
  }

  export type reldispositivopuertaUpdateInput = {
    IDDispositivo?: IntFieldUpdateOperationsInput | number
    IDPuerta?: IntFieldUpdateOperationsInput | number
    IDTipoDispositivo?: IntFieldUpdateOperationsInput | number
  }

  export type reldispositivopuertaUncheckedUpdateInput = {
    IDRelDisPuerta?: IntFieldUpdateOperationsInput | number
    IDDispositivo?: IntFieldUpdateOperationsInput | number
    IDPuerta?: IntFieldUpdateOperationsInput | number
    IDTipoDispositivo?: IntFieldUpdateOperationsInput | number
  }

  export type reldispositivopuertaCreateManyInput = {
    IDRelDisPuerta?: number
    IDDispositivo: number
    IDPuerta: number
    IDTipoDispositivo: number
  }

  export type reldispositivopuertaUpdateManyMutationInput = {
    IDDispositivo?: IntFieldUpdateOperationsInput | number
    IDPuerta?: IntFieldUpdateOperationsInput | number
    IDTipoDispositivo?: IntFieldUpdateOperationsInput | number
  }

  export type reldispositivopuertaUncheckedUpdateManyInput = {
    IDRelDisPuerta?: IntFieldUpdateOperationsInput | number
    IDDispositivo?: IntFieldUpdateOperationsInput | number
    IDPuerta?: IntFieldUpdateOperationsInput | number
    IDTipoDispositivo?: IntFieldUpdateOperationsInput | number
  }

  export type reldispositivosubsistemaCreateInput = {
    IDRelDisSubsistema: number
    IDSubsistema?: number | null
    IDDispositivo?: number | null
  }

  export type reldispositivosubsistemaUncheckedCreateInput = {
    IDRelDisSubsistema: number
    IDSubsistema?: number | null
    IDDispositivo?: number | null
  }

  export type reldispositivosubsistemaUpdateInput = {
    IDRelDisSubsistema?: IntFieldUpdateOperationsInput | number
    IDSubsistema?: NullableIntFieldUpdateOperationsInput | number | null
    IDDispositivo?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type reldispositivosubsistemaUncheckedUpdateInput = {
    IDRelDisSubsistema?: IntFieldUpdateOperationsInput | number
    IDSubsistema?: NullableIntFieldUpdateOperationsInput | number | null
    IDDispositivo?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type reldispositivosubsistemaCreateManyInput = {
    IDRelDisSubsistema: number
    IDSubsistema?: number | null
    IDDispositivo?: number | null
  }

  export type reldispositivosubsistemaUpdateManyMutationInput = {
    IDRelDisSubsistema?: IntFieldUpdateOperationsInput | number
    IDSubsistema?: NullableIntFieldUpdateOperationsInput | number | null
    IDDispositivo?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type reldispositivosubsistemaUncheckedUpdateManyInput = {
    IDRelDisSubsistema?: IntFieldUpdateOperationsInput | number
    IDSubsistema?: NullableIntFieldUpdateOperationsInput | number | null
    IDDispositivo?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type reldispositivotipoeventoCreateInput = {
    IDDispositivo?: number
    ClaseEvento?: number
  }

  export type reldispositivotipoeventoUncheckedCreateInput = {
    IDRelDisTipoEvento?: number
    IDDispositivo?: number
    ClaseEvento?: number
  }

  export type reldispositivotipoeventoUpdateInput = {
    IDDispositivo?: IntFieldUpdateOperationsInput | number
    ClaseEvento?: IntFieldUpdateOperationsInput | number
  }

  export type reldispositivotipoeventoUncheckedUpdateInput = {
    IDRelDisTipoEvento?: IntFieldUpdateOperationsInput | number
    IDDispositivo?: IntFieldUpdateOperationsInput | number
    ClaseEvento?: IntFieldUpdateOperationsInput | number
  }

  export type reldispositivotipoeventoCreateManyInput = {
    IDRelDisTipoEvento?: number
    IDDispositivo?: number
    ClaseEvento?: number
  }

  export type reldispositivotipoeventoUpdateManyMutationInput = {
    IDDispositivo?: IntFieldUpdateOperationsInput | number
    ClaseEvento?: IntFieldUpdateOperationsInput | number
  }

  export type reldispositivotipoeventoUncheckedUpdateManyInput = {
    IDRelDisTipoEvento?: IntFieldUpdateOperationsInput | number
    IDDispositivo?: IntFieldUpdateOperationsInput | number
    ClaseEvento?: IntFieldUpdateOperationsInput | number
  }

  export type reldispositivozonaCreateInput = {
    IDDispositivo?: number | null
    IDZona?: number | null
  }

  export type reldispositivozonaUncheckedCreateInput = {
    IDRelDisZona?: number
    IDDispositivo?: number | null
    IDZona?: number | null
  }

  export type reldispositivozonaUpdateInput = {
    IDDispositivo?: NullableIntFieldUpdateOperationsInput | number | null
    IDZona?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type reldispositivozonaUncheckedUpdateInput = {
    IDRelDisZona?: IntFieldUpdateOperationsInput | number
    IDDispositivo?: NullableIntFieldUpdateOperationsInput | number | null
    IDZona?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type reldispositivozonaCreateManyInput = {
    IDRelDisZona?: number
    IDDispositivo?: number | null
    IDZona?: number | null
  }

  export type reldispositivozonaUpdateManyMutationInput = {
    IDDispositivo?: NullableIntFieldUpdateOperationsInput | number | null
    IDZona?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type reldispositivozonaUncheckedUpdateManyInput = {
    IDRelDisZona?: IntFieldUpdateOperationsInput | number
    IDDispositivo?: NullableIntFieldUpdateOperationsInput | number | null
    IDZona?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type reltipocontroladormetodoCreateInput = {
    IDMetodo?: number | null
    RelTipoControladorMetodo?: number | null
  }

  export type reltipocontroladormetodoUncheckedCreateInput = {
    IDTipoControlador?: number
    IDMetodo?: number | null
    RelTipoControladorMetodo?: number | null
  }

  export type reltipocontroladormetodoUpdateInput = {
    IDMetodo?: NullableIntFieldUpdateOperationsInput | number | null
    RelTipoControladorMetodo?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type reltipocontroladormetodoUncheckedUpdateInput = {
    IDTipoControlador?: IntFieldUpdateOperationsInput | number
    IDMetodo?: NullableIntFieldUpdateOperationsInput | number | null
    RelTipoControladorMetodo?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type reltipocontroladormetodoCreateManyInput = {
    IDTipoControlador?: number
    IDMetodo?: number | null
    RelTipoControladorMetodo?: number | null
  }

  export type reltipocontroladormetodoUpdateManyMutationInput = {
    IDMetodo?: NullableIntFieldUpdateOperationsInput | number | null
    RelTipoControladorMetodo?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type reltipocontroladormetodoUncheckedUpdateManyInput = {
    IDTipoControlador?: IntFieldUpdateOperationsInput | number
    IDMetodo?: NullableIntFieldUpdateOperationsInput | number | null
    RelTipoControladorMetodo?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type reltipodispositivoperfildispositivoCreateInput = {
    IDTipoDispositivo: number
    IDPerfilDispositivo: number
  }

  export type reltipodispositivoperfildispositivoUncheckedCreateInput = {
    IDRelTipoDispPerfil?: number
    IDTipoDispositivo: number
    IDPerfilDispositivo: number
  }

  export type reltipodispositivoperfildispositivoUpdateInput = {
    IDTipoDispositivo?: IntFieldUpdateOperationsInput | number
    IDPerfilDispositivo?: IntFieldUpdateOperationsInput | number
  }

  export type reltipodispositivoperfildispositivoUncheckedUpdateInput = {
    IDRelTipoDispPerfil?: IntFieldUpdateOperationsInput | number
    IDTipoDispositivo?: IntFieldUpdateOperationsInput | number
    IDPerfilDispositivo?: IntFieldUpdateOperationsInput | number
  }

  export type reltipodispositivoperfildispositivoCreateManyInput = {
    IDRelTipoDispPerfil?: number
    IDTipoDispositivo: number
    IDPerfilDispositivo: number
  }

  export type reltipodispositivoperfildispositivoUpdateManyMutationInput = {
    IDTipoDispositivo?: IntFieldUpdateOperationsInput | number
    IDPerfilDispositivo?: IntFieldUpdateOperationsInput | number
  }

  export type reltipodispositivoperfildispositivoUncheckedUpdateManyInput = {
    IDRelTipoDispPerfil?: IntFieldUpdateOperationsInput | number
    IDTipoDispositivo?: IntFieldUpdateOperationsInput | number
    IDPerfilDispositivo?: IntFieldUpdateOperationsInput | number
  }

  export type reltipodispositivoperfileventoCreateInput = {
    IDTipoDispositivo: number
    IDPerfilEvento: number
  }

  export type reltipodispositivoperfileventoUncheckedCreateInput = {
    IDRelTipoDisPerfilEvento?: number
    IDTipoDispositivo: number
    IDPerfilEvento: number
  }

  export type reltipodispositivoperfileventoUpdateInput = {
    IDTipoDispositivo?: IntFieldUpdateOperationsInput | number
    IDPerfilEvento?: IntFieldUpdateOperationsInput | number
  }

  export type reltipodispositivoperfileventoUncheckedUpdateInput = {
    IDRelTipoDisPerfilEvento?: IntFieldUpdateOperationsInput | number
    IDTipoDispositivo?: IntFieldUpdateOperationsInput | number
    IDPerfilEvento?: IntFieldUpdateOperationsInput | number
  }

  export type reltipodispositivoperfileventoCreateManyInput = {
    IDRelTipoDisPerfilEvento?: number
    IDTipoDispositivo: number
    IDPerfilEvento: number
  }

  export type reltipodispositivoperfileventoUpdateManyMutationInput = {
    IDTipoDispositivo?: IntFieldUpdateOperationsInput | number
    IDPerfilEvento?: IntFieldUpdateOperationsInput | number
  }

  export type reltipodispositivoperfileventoUncheckedUpdateManyInput = {
    IDRelTipoDisPerfilEvento?: IntFieldUpdateOperationsInput | number
    IDTipoDispositivo?: IntFieldUpdateOperationsInput | number
    IDPerfilEvento?: IntFieldUpdateOperationsInput | number
  }

  export type reltipodispositivotipotecnologiaCreateInput = {
    IDTipoDispositivo: number
    IDTipoTecnologia: number
  }

  export type reltipodispositivotipotecnologiaUncheckedCreateInput = {
    IDRelTipoDispTipoTec?: number
    IDTipoDispositivo: number
    IDTipoTecnologia: number
  }

  export type reltipodispositivotipotecnologiaUpdateInput = {
    IDTipoDispositivo?: IntFieldUpdateOperationsInput | number
    IDTipoTecnologia?: IntFieldUpdateOperationsInput | number
  }

  export type reltipodispositivotipotecnologiaUncheckedUpdateInput = {
    IDRelTipoDispTipoTec?: IntFieldUpdateOperationsInput | number
    IDTipoDispositivo?: IntFieldUpdateOperationsInput | number
    IDTipoTecnologia?: IntFieldUpdateOperationsInput | number
  }

  export type reltipodispositivotipotecnologiaCreateManyInput = {
    IDRelTipoDispTipoTec?: number
    IDTipoDispositivo: number
    IDTipoTecnologia: number
  }

  export type reltipodispositivotipotecnologiaUpdateManyMutationInput = {
    IDTipoDispositivo?: IntFieldUpdateOperationsInput | number
    IDTipoTecnologia?: IntFieldUpdateOperationsInput | number
  }

  export type reltipodispositivotipotecnologiaUncheckedUpdateManyInput = {
    IDRelTipoDispTipoTec?: IntFieldUpdateOperationsInput | number
    IDTipoDispositivo?: IntFieldUpdateOperationsInput | number
    IDTipoTecnologia?: IntFieldUpdateOperationsInput | number
  }

  export type reltipogatewayperfildispositivoCreateInput = {
    IDTipoGateway?: number | null
    IDPerfilDispositivo?: number | null
  }

  export type reltipogatewayperfildispositivoUncheckedCreateInput = {
    IDRelTipoGatewayPerfil?: number
    IDTipoGateway?: number | null
    IDPerfilDispositivo?: number | null
  }

  export type reltipogatewayperfildispositivoUpdateInput = {
    IDTipoGateway?: NullableIntFieldUpdateOperationsInput | number | null
    IDPerfilDispositivo?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type reltipogatewayperfildispositivoUncheckedUpdateInput = {
    IDRelTipoGatewayPerfil?: IntFieldUpdateOperationsInput | number
    IDTipoGateway?: NullableIntFieldUpdateOperationsInput | number | null
    IDPerfilDispositivo?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type reltipogatewayperfildispositivoCreateManyInput = {
    IDRelTipoGatewayPerfil?: number
    IDTipoGateway?: number | null
    IDPerfilDispositivo?: number | null
  }

  export type reltipogatewayperfildispositivoUpdateManyMutationInput = {
    IDTipoGateway?: NullableIntFieldUpdateOperationsInput | number | null
    IDPerfilDispositivo?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type reltipogatewayperfildispositivoUncheckedUpdateManyInput = {
    IDRelTipoGatewayPerfil?: IntFieldUpdateOperationsInput | number
    IDTipoGateway?: NullableIntFieldUpdateOperationsInput | number | null
    IDPerfilDispositivo?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type subsistemasCreateInput = {
    NombreSubSistema?: string | null
    DescripcionSubSistema?: string | null
    URLSubSistema?: string | null
    Puerto?: number | null
  }

  export type subsistemasUncheckedCreateInput = {
    IDSubSistema?: number
    NombreSubSistema?: string | null
    DescripcionSubSistema?: string | null
    URLSubSistema?: string | null
    Puerto?: number | null
  }

  export type subsistemasUpdateInput = {
    NombreSubSistema?: NullableStringFieldUpdateOperationsInput | string | null
    DescripcionSubSistema?: NullableStringFieldUpdateOperationsInput | string | null
    URLSubSistema?: NullableStringFieldUpdateOperationsInput | string | null
    Puerto?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type subsistemasUncheckedUpdateInput = {
    IDSubSistema?: IntFieldUpdateOperationsInput | number
    NombreSubSistema?: NullableStringFieldUpdateOperationsInput | string | null
    DescripcionSubSistema?: NullableStringFieldUpdateOperationsInput | string | null
    URLSubSistema?: NullableStringFieldUpdateOperationsInput | string | null
    Puerto?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type subsistemasCreateManyInput = {
    IDSubSistema?: number
    NombreSubSistema?: string | null
    DescripcionSubSistema?: string | null
    URLSubSistema?: string | null
    Puerto?: number | null
  }

  export type subsistemasUpdateManyMutationInput = {
    NombreSubSistema?: NullableStringFieldUpdateOperationsInput | string | null
    DescripcionSubSistema?: NullableStringFieldUpdateOperationsInput | string | null
    URLSubSistema?: NullableStringFieldUpdateOperationsInput | string | null
    Puerto?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type subsistemasUncheckedUpdateManyInput = {
    IDSubSistema?: IntFieldUpdateOperationsInput | number
    NombreSubSistema?: NullableStringFieldUpdateOperationsInput | string | null
    DescripcionSubSistema?: NullableStringFieldUpdateOperationsInput | string | null
    URLSubSistema?: NullableStringFieldUpdateOperationsInput | string | null
    Puerto?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type tablasinformacionCreateInput = {
    IDTabla: number
    NombreTabla?: string | null
    Tipo?: number | null
    Identidad?: string | null
    CodigoNetsocs?: number | null
  }

  export type tablasinformacionUncheckedCreateInput = {
    IDTabla: number
    NombreTabla?: string | null
    Tipo?: number | null
    Identidad?: string | null
    CodigoNetsocs?: number | null
  }

  export type tablasinformacionUpdateInput = {
    IDTabla?: IntFieldUpdateOperationsInput | number
    NombreTabla?: NullableStringFieldUpdateOperationsInput | string | null
    Tipo?: NullableIntFieldUpdateOperationsInput | number | null
    Identidad?: NullableStringFieldUpdateOperationsInput | string | null
    CodigoNetsocs?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type tablasinformacionUncheckedUpdateInput = {
    IDTabla?: IntFieldUpdateOperationsInput | number
    NombreTabla?: NullableStringFieldUpdateOperationsInput | string | null
    Tipo?: NullableIntFieldUpdateOperationsInput | number | null
    Identidad?: NullableStringFieldUpdateOperationsInput | string | null
    CodigoNetsocs?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type tablasinformacionCreateManyInput = {
    IDTabla: number
    NombreTabla?: string | null
    Tipo?: number | null
    Identidad?: string | null
    CodigoNetsocs?: number | null
  }

  export type tablasinformacionUpdateManyMutationInput = {
    IDTabla?: IntFieldUpdateOperationsInput | number
    NombreTabla?: NullableStringFieldUpdateOperationsInput | string | null
    Tipo?: NullableIntFieldUpdateOperationsInput | number | null
    Identidad?: NullableStringFieldUpdateOperationsInput | string | null
    CodigoNetsocs?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type tablasinformacionUncheckedUpdateManyInput = {
    IDTabla?: IntFieldUpdateOperationsInput | number
    NombreTabla?: NullableStringFieldUpdateOperationsInput | string | null
    Tipo?: NullableIntFieldUpdateOperationsInput | number | null
    Identidad?: NullableStringFieldUpdateOperationsInput | string | null
    CodigoNetsocs?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type tecnologiasnetsocsCreateInput = {
    NombreTecnologiaGateway?: string | null
  }

  export type tecnologiasnetsocsUncheckedCreateInput = {
    IDTecnologiaGateway?: number
    NombreTecnologiaGateway?: string | null
  }

  export type tecnologiasnetsocsUpdateInput = {
    NombreTecnologiaGateway?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type tecnologiasnetsocsUncheckedUpdateInput = {
    IDTecnologiaGateway?: IntFieldUpdateOperationsInput | number
    NombreTecnologiaGateway?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type tecnologiasnetsocsCreateManyInput = {
    IDTecnologiaGateway?: number
    NombreTecnologiaGateway?: string | null
  }

  export type tecnologiasnetsocsUpdateManyMutationInput = {
    NombreTecnologiaGateway?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type tecnologiasnetsocsUncheckedUpdateManyInput = {
    IDTecnologiaGateway?: IntFieldUpdateOperationsInput | number
    NombreTecnologiaGateway?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type IntFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type IntNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableFilter | number | null
  }

  export type StringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableFilter | string | null
  }

  export type DecimalNullableFilter = {
    equals?: Decimal | DecimalJsLike | number | string | null
    in?: Enumerable<Decimal> | Enumerable<DecimalJsLike> | Enumerable<number> | Enumerable<string> | null
    notIn?: Enumerable<Decimal> | Enumerable<DecimalJsLike> | Enumerable<number> | Enumerable<string> | null
    lt?: Decimal | DecimalJsLike | number | string
    lte?: Decimal | DecimalJsLike | number | string
    gt?: Decimal | DecimalJsLike | number | string
    gte?: Decimal | DecimalJsLike | number | string
    not?: NestedDecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
  }

  export type DateTimeNullableFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | null
    notIn?: Enumerable<Date> | Enumerable<string> | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableFilter | Date | string | null
  }

  export type controladoresCountOrderByAggregateInput = {
    IDControlador?: SortOrder
    IDEdificio?: SortOrder
    NombreControlador?: SortOrder
    Descripcion?: SortOrder
    IDIcono?: SortOrder
    TipoControlador?: SortOrder
    Prioridad?: SortOrder
    Certificado?: SortOrder
    PuertoSSL?: SortOrder
    PuertoNoSSL?: SortOrder
    PuertoMantenimiento?: SortOrder
    PuertoConexionSC?: SortOrder
    PuertoConexionCC?: SortOrder
    SOAP?: SortOrder
    Socket?: SortOrder
    API?: SortOrder
    Sincroniza?: SortOrder
    DireccionAIPV4?: SortOrder
    DireccionBIPv4?: SortOrder
    DireccionAIPV6?: SortOrder
    DireccionBIPv6?: SortOrder
    DireccionPublica1?: SortOrder
    DireccionPublica2?: SortOrder
    Localizacion?: SortOrder
    Latitud?: SortOrder
    Longitud?: SortOrder
    Estatus?: SortOrder
    FechaCreado?: SortOrder
    FechaDesactivado?: SortOrder
  }

  export type controladoresAvgOrderByAggregateInput = {
    IDControlador?: SortOrder
    IDEdificio?: SortOrder
    IDIcono?: SortOrder
    TipoControlador?: SortOrder
    PuertoSSL?: SortOrder
    PuertoNoSSL?: SortOrder
    PuertoMantenimiento?: SortOrder
    PuertoConexionSC?: SortOrder
    PuertoConexionCC?: SortOrder
    Latitud?: SortOrder
    Longitud?: SortOrder
    Estatus?: SortOrder
  }

  export type controladoresMaxOrderByAggregateInput = {
    IDControlador?: SortOrder
    IDEdificio?: SortOrder
    NombreControlador?: SortOrder
    Descripcion?: SortOrder
    IDIcono?: SortOrder
    TipoControlador?: SortOrder
    Prioridad?: SortOrder
    Certificado?: SortOrder
    PuertoSSL?: SortOrder
    PuertoNoSSL?: SortOrder
    PuertoMantenimiento?: SortOrder
    PuertoConexionSC?: SortOrder
    PuertoConexionCC?: SortOrder
    SOAP?: SortOrder
    Socket?: SortOrder
    API?: SortOrder
    Sincroniza?: SortOrder
    DireccionAIPV4?: SortOrder
    DireccionBIPv4?: SortOrder
    DireccionAIPV6?: SortOrder
    DireccionBIPv6?: SortOrder
    DireccionPublica1?: SortOrder
    DireccionPublica2?: SortOrder
    Localizacion?: SortOrder
    Latitud?: SortOrder
    Longitud?: SortOrder
    Estatus?: SortOrder
    FechaCreado?: SortOrder
    FechaDesactivado?: SortOrder
  }

  export type controladoresMinOrderByAggregateInput = {
    IDControlador?: SortOrder
    IDEdificio?: SortOrder
    NombreControlador?: SortOrder
    Descripcion?: SortOrder
    IDIcono?: SortOrder
    TipoControlador?: SortOrder
    Prioridad?: SortOrder
    Certificado?: SortOrder
    PuertoSSL?: SortOrder
    PuertoNoSSL?: SortOrder
    PuertoMantenimiento?: SortOrder
    PuertoConexionSC?: SortOrder
    PuertoConexionCC?: SortOrder
    SOAP?: SortOrder
    Socket?: SortOrder
    API?: SortOrder
    Sincroniza?: SortOrder
    DireccionAIPV4?: SortOrder
    DireccionBIPv4?: SortOrder
    DireccionAIPV6?: SortOrder
    DireccionBIPv6?: SortOrder
    DireccionPublica1?: SortOrder
    DireccionPublica2?: SortOrder
    Localizacion?: SortOrder
    Latitud?: SortOrder
    Longitud?: SortOrder
    Estatus?: SortOrder
    FechaCreado?: SortOrder
    FechaDesactivado?: SortOrder
  }

  export type controladoresSumOrderByAggregateInput = {
    IDControlador?: SortOrder
    IDEdificio?: SortOrder
    IDIcono?: SortOrder
    TipoControlador?: SortOrder
    PuertoSSL?: SortOrder
    PuertoNoSSL?: SortOrder
    PuertoMantenimiento?: SortOrder
    PuertoConexionSC?: SortOrder
    PuertoConexionCC?: SortOrder
    Latitud?: SortOrder
    Longitud?: SortOrder
    Estatus?: SortOrder
  }

  export type IntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    _min?: NestedIntFilter
    _max?: NestedIntFilter
  }

  export type IntNullableWithAggregatesFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedIntNullableFilter
    _min?: NestedIntNullableFilter
    _max?: NestedIntNullableFilter
  }

  export type StringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableWithAggregatesFilter | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedStringNullableFilter
    _max?: NestedStringNullableFilter
  }

  export type DecimalNullableWithAggregatesFilter = {
    equals?: Decimal | DecimalJsLike | number | string | null
    in?: Enumerable<Decimal> | Enumerable<DecimalJsLike> | Enumerable<number> | Enumerable<string> | null
    notIn?: Enumerable<Decimal> | Enumerable<DecimalJsLike> | Enumerable<number> | Enumerable<string> | null
    lt?: Decimal | DecimalJsLike | number | string
    lte?: Decimal | DecimalJsLike | number | string
    gt?: Decimal | DecimalJsLike | number | string
    gte?: Decimal | DecimalJsLike | number | string
    not?: NestedDecimalNullableWithAggregatesFilter | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter
    _avg?: NestedDecimalNullableFilter
    _sum?: NestedDecimalNullableFilter
    _min?: NestedDecimalNullableFilter
    _max?: NestedDecimalNullableFilter
  }

  export type DateTimeNullableWithAggregatesFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | null
    notIn?: Enumerable<Date> | Enumerable<string> | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableWithAggregatesFilter | Date | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedDateTimeNullableFilter
    _max?: NestedDateTimeNullableFilter
  }

  export type dispositivosCountOrderByAggregateInput = {
    IDDispositivo?: SortOrder
    IDSubsistema?: SortOrder
    IDTipoFamilia?: SortOrder
    IDFamilia?: SortOrder
    IDFabricante?: SortOrder
    IDTipoDispositivo?: SortOrder
    IDGateway?: SortOrder
    IDControlador?: SortOrder
    IDModelo?: SortOrder
    IDEdificio?: SortOrder
    IDZona?: SortOrder
    IDPuerta?: SortOrder
    NombreDispositivo?: SortOrder
    Descripcion?: SortOrder
    IDIconografia?: SortOrder
    IDMenuPropio?: SortOrder
    Estatus?: SortOrder
    Sentidos?: SortOrder
    Ignorado?: SortOrder
    Enrolamiento?: SortOrder
    Latitud?: SortOrder
    Longitud?: SortOrder
    DireccionGPS?: SortOrder
    GeometriaGPS?: SortOrder
    IDTipoEvento?: SortOrder
    IDModeloElemento?: SortOrder
    FechaCreacion?: SortOrder
    FechaDesactivacion?: SortOrder
    FechaEliminacion?: SortOrder
    Parametros?: SortOrder
    Certificado?: SortOrder
    PuertoSSL?: SortOrder
    PuertoNoSSL?: SortOrder
    PuertoMantenimiento?: SortOrder
    PuertoConexionSC?: SortOrder
    PuertoConexionCC?: SortOrder
    SOAP?: SortOrder
    Socket?: SortOrder
    API?: SortOrder
    Sincroniza?: SortOrder
    DireccionAIPV4?: SortOrder
    DireccionBIPv4?: SortOrder
    DireccionAIPV6?: SortOrder
    DireccionBIPv6?: SortOrder
    DireccionPublica1?: SortOrder
    DireccionPublica2?: SortOrder
    Serial?: SortOrder
    user?: SortOrder
    password?: SortOrder
    IDManual?: SortOrder
    Directo?: SortOrder
  }

  export type dispositivosAvgOrderByAggregateInput = {
    IDDispositivo?: SortOrder
    IDSubsistema?: SortOrder
    IDTipoFamilia?: SortOrder
    IDFamilia?: SortOrder
    IDFabricante?: SortOrder
    IDTipoDispositivo?: SortOrder
    IDGateway?: SortOrder
    IDControlador?: SortOrder
    IDModelo?: SortOrder
    IDEdificio?: SortOrder
    IDZona?: SortOrder
    IDPuerta?: SortOrder
    IDIconografia?: SortOrder
    IDMenuPropio?: SortOrder
    Latitud?: SortOrder
    Longitud?: SortOrder
    IDTipoEvento?: SortOrder
    IDModeloElemento?: SortOrder
    PuertoSSL?: SortOrder
    PuertoNoSSL?: SortOrder
    PuertoMantenimiento?: SortOrder
    PuertoConexionSC?: SortOrder
    PuertoConexionCC?: SortOrder
    IDManual?: SortOrder
    Directo?: SortOrder
  }

  export type dispositivosMaxOrderByAggregateInput = {
    IDDispositivo?: SortOrder
    IDSubsistema?: SortOrder
    IDTipoFamilia?: SortOrder
    IDFamilia?: SortOrder
    IDFabricante?: SortOrder
    IDTipoDispositivo?: SortOrder
    IDGateway?: SortOrder
    IDControlador?: SortOrder
    IDModelo?: SortOrder
    IDEdificio?: SortOrder
    IDZona?: SortOrder
    IDPuerta?: SortOrder
    NombreDispositivo?: SortOrder
    Descripcion?: SortOrder
    IDIconografia?: SortOrder
    IDMenuPropio?: SortOrder
    Estatus?: SortOrder
    Sentidos?: SortOrder
    Ignorado?: SortOrder
    Enrolamiento?: SortOrder
    Latitud?: SortOrder
    Longitud?: SortOrder
    DireccionGPS?: SortOrder
    GeometriaGPS?: SortOrder
    IDTipoEvento?: SortOrder
    IDModeloElemento?: SortOrder
    FechaCreacion?: SortOrder
    FechaDesactivacion?: SortOrder
    FechaEliminacion?: SortOrder
    Parametros?: SortOrder
    Certificado?: SortOrder
    PuertoSSL?: SortOrder
    PuertoNoSSL?: SortOrder
    PuertoMantenimiento?: SortOrder
    PuertoConexionSC?: SortOrder
    PuertoConexionCC?: SortOrder
    SOAP?: SortOrder
    Socket?: SortOrder
    API?: SortOrder
    Sincroniza?: SortOrder
    DireccionAIPV4?: SortOrder
    DireccionBIPv4?: SortOrder
    DireccionAIPV6?: SortOrder
    DireccionBIPv6?: SortOrder
    DireccionPublica1?: SortOrder
    DireccionPublica2?: SortOrder
    Serial?: SortOrder
    user?: SortOrder
    password?: SortOrder
    IDManual?: SortOrder
    Directo?: SortOrder
  }

  export type dispositivosMinOrderByAggregateInput = {
    IDDispositivo?: SortOrder
    IDSubsistema?: SortOrder
    IDTipoFamilia?: SortOrder
    IDFamilia?: SortOrder
    IDFabricante?: SortOrder
    IDTipoDispositivo?: SortOrder
    IDGateway?: SortOrder
    IDControlador?: SortOrder
    IDModelo?: SortOrder
    IDEdificio?: SortOrder
    IDZona?: SortOrder
    IDPuerta?: SortOrder
    NombreDispositivo?: SortOrder
    Descripcion?: SortOrder
    IDIconografia?: SortOrder
    IDMenuPropio?: SortOrder
    Estatus?: SortOrder
    Sentidos?: SortOrder
    Ignorado?: SortOrder
    Enrolamiento?: SortOrder
    Latitud?: SortOrder
    Longitud?: SortOrder
    DireccionGPS?: SortOrder
    GeometriaGPS?: SortOrder
    IDTipoEvento?: SortOrder
    IDModeloElemento?: SortOrder
    FechaCreacion?: SortOrder
    FechaDesactivacion?: SortOrder
    FechaEliminacion?: SortOrder
    Parametros?: SortOrder
    Certificado?: SortOrder
    PuertoSSL?: SortOrder
    PuertoNoSSL?: SortOrder
    PuertoMantenimiento?: SortOrder
    PuertoConexionSC?: SortOrder
    PuertoConexionCC?: SortOrder
    SOAP?: SortOrder
    Socket?: SortOrder
    API?: SortOrder
    Sincroniza?: SortOrder
    DireccionAIPV4?: SortOrder
    DireccionBIPv4?: SortOrder
    DireccionAIPV6?: SortOrder
    DireccionBIPv6?: SortOrder
    DireccionPublica1?: SortOrder
    DireccionPublica2?: SortOrder
    Serial?: SortOrder
    user?: SortOrder
    password?: SortOrder
    IDManual?: SortOrder
    Directo?: SortOrder
  }

  export type dispositivosSumOrderByAggregateInput = {
    IDDispositivo?: SortOrder
    IDSubsistema?: SortOrder
    IDTipoFamilia?: SortOrder
    IDFamilia?: SortOrder
    IDFabricante?: SortOrder
    IDTipoDispositivo?: SortOrder
    IDGateway?: SortOrder
    IDControlador?: SortOrder
    IDModelo?: SortOrder
    IDEdificio?: SortOrder
    IDZona?: SortOrder
    IDPuerta?: SortOrder
    IDIconografia?: SortOrder
    IDMenuPropio?: SortOrder
    Latitud?: SortOrder
    Longitud?: SortOrder
    IDTipoEvento?: SortOrder
    IDModeloElemento?: SortOrder
    PuertoSSL?: SortOrder
    PuertoNoSSL?: SortOrder
    PuertoMantenimiento?: SortOrder
    PuertoConexionSC?: SortOrder
    PuertoConexionCC?: SortOrder
    IDManual?: SortOrder
    Directo?: SortOrder
  }

  export type BytesNullableFilter = {
    equals?: Buffer | null
    in?: Enumerable<Buffer> | null
    notIn?: Enumerable<Buffer> | null
    not?: NestedBytesNullableFilter | Buffer | null
  }

  export type gatewayCountOrderByAggregateInput = {
    IDGateway?: SortOrder
    IDTipoGateway?: SortOrder
    IDControlador?: SortOrder
    IDEdificio?: SortOrder
    IDIdentificadorExterno?: SortOrder
    IDTipoEvento?: SortOrder
    IDGrupoMetodo?: SortOrder
    NAbonado?: SortOrder
    NombreGateway?: SortOrder
    Descripcion?: SortOrder
    IDIcono?: SortOrder
    ValorEstado?: SortOrder
    Parametros?: SortOrder
    EstadoOnOff?: SortOrder
    Latitud?: SortOrder
    Longitud?: SortOrder
    SerialGPS?: SortOrder
    GeometriaGPS?: SortOrder
    FechaCreado?: SortOrder
    FechaDesactivado?: SortOrder
    Certificado?: SortOrder
    PuertoSSL?: SortOrder
    PuertoNoSSL?: SortOrder
    PuertoMantenimiento?: SortOrder
    PuertoConexionSC?: SortOrder
    PuertoConexionCC?: SortOrder
    SOAP?: SortOrder
    Socket?: SortOrder
    API?: SortOrder
    Sincroniza?: SortOrder
    DireccionAIPV4?: SortOrder
    DireccionBIPv4?: SortOrder
    DireccionAIPV6?: SortOrder
    DireccionBIPv6?: SortOrder
    DireccionPublica1?: SortOrder
    DireccionPublica2?: SortOrder
    user?: SortOrder
    password?: SortOrder
    Serial?: SortOrder
    IDManual?: SortOrder
    IDZona?: SortOrder
  }

  export type gatewayAvgOrderByAggregateInput = {
    IDGateway?: SortOrder
    IDTipoGateway?: SortOrder
    IDControlador?: SortOrder
    IDEdificio?: SortOrder
    IDTipoEvento?: SortOrder
    IDGrupoMetodo?: SortOrder
    IDIcono?: SortOrder
    Latitud?: SortOrder
    Longitud?: SortOrder
    PuertoSSL?: SortOrder
    PuertoNoSSL?: SortOrder
    PuertoMantenimiento?: SortOrder
    PuertoConexionSC?: SortOrder
    PuertoConexionCC?: SortOrder
    IDManual?: SortOrder
    IDZona?: SortOrder
  }

  export type gatewayMaxOrderByAggregateInput = {
    IDGateway?: SortOrder
    IDTipoGateway?: SortOrder
    IDControlador?: SortOrder
    IDEdificio?: SortOrder
    IDIdentificadorExterno?: SortOrder
    IDTipoEvento?: SortOrder
    IDGrupoMetodo?: SortOrder
    NAbonado?: SortOrder
    NombreGateway?: SortOrder
    Descripcion?: SortOrder
    IDIcono?: SortOrder
    ValorEstado?: SortOrder
    Parametros?: SortOrder
    EstadoOnOff?: SortOrder
    Latitud?: SortOrder
    Longitud?: SortOrder
    SerialGPS?: SortOrder
    GeometriaGPS?: SortOrder
    FechaCreado?: SortOrder
    FechaDesactivado?: SortOrder
    Certificado?: SortOrder
    PuertoSSL?: SortOrder
    PuertoNoSSL?: SortOrder
    PuertoMantenimiento?: SortOrder
    PuertoConexionSC?: SortOrder
    PuertoConexionCC?: SortOrder
    SOAP?: SortOrder
    Socket?: SortOrder
    API?: SortOrder
    Sincroniza?: SortOrder
    DireccionAIPV4?: SortOrder
    DireccionBIPv4?: SortOrder
    DireccionAIPV6?: SortOrder
    DireccionBIPv6?: SortOrder
    DireccionPublica1?: SortOrder
    DireccionPublica2?: SortOrder
    user?: SortOrder
    password?: SortOrder
    Serial?: SortOrder
    IDManual?: SortOrder
    IDZona?: SortOrder
  }

  export type gatewayMinOrderByAggregateInput = {
    IDGateway?: SortOrder
    IDTipoGateway?: SortOrder
    IDControlador?: SortOrder
    IDEdificio?: SortOrder
    IDIdentificadorExterno?: SortOrder
    IDTipoEvento?: SortOrder
    IDGrupoMetodo?: SortOrder
    NAbonado?: SortOrder
    NombreGateway?: SortOrder
    Descripcion?: SortOrder
    IDIcono?: SortOrder
    ValorEstado?: SortOrder
    Parametros?: SortOrder
    EstadoOnOff?: SortOrder
    Latitud?: SortOrder
    Longitud?: SortOrder
    SerialGPS?: SortOrder
    GeometriaGPS?: SortOrder
    FechaCreado?: SortOrder
    FechaDesactivado?: SortOrder
    Certificado?: SortOrder
    PuertoSSL?: SortOrder
    PuertoNoSSL?: SortOrder
    PuertoMantenimiento?: SortOrder
    PuertoConexionSC?: SortOrder
    PuertoConexionCC?: SortOrder
    SOAP?: SortOrder
    Socket?: SortOrder
    API?: SortOrder
    Sincroniza?: SortOrder
    DireccionAIPV4?: SortOrder
    DireccionBIPv4?: SortOrder
    DireccionAIPV6?: SortOrder
    DireccionBIPv6?: SortOrder
    DireccionPublica1?: SortOrder
    DireccionPublica2?: SortOrder
    user?: SortOrder
    password?: SortOrder
    Serial?: SortOrder
    IDManual?: SortOrder
    IDZona?: SortOrder
  }

  export type gatewaySumOrderByAggregateInput = {
    IDGateway?: SortOrder
    IDTipoGateway?: SortOrder
    IDControlador?: SortOrder
    IDEdificio?: SortOrder
    IDTipoEvento?: SortOrder
    IDGrupoMetodo?: SortOrder
    IDIcono?: SortOrder
    Latitud?: SortOrder
    Longitud?: SortOrder
    PuertoSSL?: SortOrder
    PuertoNoSSL?: SortOrder
    PuertoMantenimiento?: SortOrder
    PuertoConexionSC?: SortOrder
    PuertoConexionCC?: SortOrder
    IDManual?: SortOrder
    IDZona?: SortOrder
  }

  export type BytesNullableWithAggregatesFilter = {
    equals?: Buffer | null
    in?: Enumerable<Buffer> | null
    notIn?: Enumerable<Buffer> | null
    not?: NestedBytesNullableWithAggregatesFilter | Buffer | null
    _count?: NestedIntNullableFilter
    _min?: NestedBytesNullableFilter
    _max?: NestedBytesNullableFilter
  }

  export type gruposdispositivosCountOrderByAggregateInput = {
    IDGrupoDispositivo?: SortOrder
    NombreGrupoDispositivo?: SortOrder
    Identificador?: SortOrder
    Descripcion?: SortOrder
  }

  export type gruposdispositivosAvgOrderByAggregateInput = {
    IDGrupoDispositivo?: SortOrder
  }

  export type gruposdispositivosMaxOrderByAggregateInput = {
    IDGrupoDispositivo?: SortOrder
    NombreGrupoDispositivo?: SortOrder
    Identificador?: SortOrder
    Descripcion?: SortOrder
  }

  export type gruposdispositivosMinOrderByAggregateInput = {
    IDGrupoDispositivo?: SortOrder
    NombreGrupoDispositivo?: SortOrder
    Identificador?: SortOrder
    Descripcion?: SortOrder
  }

  export type gruposdispositivosSumOrderByAggregateInput = {
    IDGrupoDispositivo?: SortOrder
  }

  export type inventariocatastroCountOrderByAggregateInput = {
    IDEntidadInventario?: SortOrder
    IDTipoEntidadInventario?: SortOrder
    IDCategoriaEntidadInventario?: SortOrder
    IDGateway?: SortOrder
    IDDispositivo?: SortOrder
    IDMetaEdificio?: SortOrder
    IDEdificio?: SortOrder
    NombreEntidadInventario?: SortOrder
    Descripcion?: SortOrder
    Latitud?: SortOrder
    Longitud?: SortOrder
    SerialGPS?: SortOrder
    GeometriaGPS?: SortOrder
    FechaAlta?: SortOrder
    FechaBaja?: SortOrder
  }

  export type inventariocatastroAvgOrderByAggregateInput = {
    IDEntidadInventario?: SortOrder
    IDTipoEntidadInventario?: SortOrder
    IDCategoriaEntidadInventario?: SortOrder
    IDGateway?: SortOrder
    IDDispositivo?: SortOrder
    IDMetaEdificio?: SortOrder
    IDEdificio?: SortOrder
    Latitud?: SortOrder
    Longitud?: SortOrder
  }

  export type inventariocatastroMaxOrderByAggregateInput = {
    IDEntidadInventario?: SortOrder
    IDTipoEntidadInventario?: SortOrder
    IDCategoriaEntidadInventario?: SortOrder
    IDGateway?: SortOrder
    IDDispositivo?: SortOrder
    IDMetaEdificio?: SortOrder
    IDEdificio?: SortOrder
    NombreEntidadInventario?: SortOrder
    Descripcion?: SortOrder
    Latitud?: SortOrder
    Longitud?: SortOrder
    SerialGPS?: SortOrder
    GeometriaGPS?: SortOrder
    FechaAlta?: SortOrder
    FechaBaja?: SortOrder
  }

  export type inventariocatastroMinOrderByAggregateInput = {
    IDEntidadInventario?: SortOrder
    IDTipoEntidadInventario?: SortOrder
    IDCategoriaEntidadInventario?: SortOrder
    IDGateway?: SortOrder
    IDDispositivo?: SortOrder
    IDMetaEdificio?: SortOrder
    IDEdificio?: SortOrder
    NombreEntidadInventario?: SortOrder
    Descripcion?: SortOrder
    Latitud?: SortOrder
    Longitud?: SortOrder
    SerialGPS?: SortOrder
    GeometriaGPS?: SortOrder
    FechaAlta?: SortOrder
    FechaBaja?: SortOrder
  }

  export type inventariocatastroSumOrderByAggregateInput = {
    IDEntidadInventario?: SortOrder
    IDTipoEntidadInventario?: SortOrder
    IDCategoriaEntidadInventario?: SortOrder
    IDGateway?: SortOrder
    IDDispositivo?: SortOrder
    IDMetaEdificio?: SortOrder
    IDEdificio?: SortOrder
    Latitud?: SortOrder
    Longitud?: SortOrder
  }

  export type libreriasapisCountOrderByAggregateInput = {
    IDLIBAPISDK?: SortOrder
    Nombre?: SortOrder
    Tipo?: SortOrder
    Web?: SortOrder
    Subsistema?: SortOrder
    Alcance?: SortOrder
  }

  export type libreriasapisAvgOrderByAggregateInput = {
    IDLIBAPISDK?: SortOrder
    Subsistema?: SortOrder
  }

  export type libreriasapisMaxOrderByAggregateInput = {
    IDLIBAPISDK?: SortOrder
    Nombre?: SortOrder
    Tipo?: SortOrder
    Web?: SortOrder
    Subsistema?: SortOrder
    Alcance?: SortOrder
  }

  export type libreriasapisMinOrderByAggregateInput = {
    IDLIBAPISDK?: SortOrder
    Nombre?: SortOrder
    Tipo?: SortOrder
    Web?: SortOrder
    Subsistema?: SortOrder
    Alcance?: SortOrder
  }

  export type libreriasapisSumOrderByAggregateInput = {
    IDLIBAPISDK?: SortOrder
    Subsistema?: SortOrder
  }

  export type metodogrupoCountOrderByAggregateInput = {
    IDGrupoMetodo?: SortOrder
    NombreGrupoMetodo?: SortOrder
    Corporacion?: SortOrder
    Departamento?: SortOrder
    Edificio?: SortOrder
    Itinerario?: SortOrder
    Empleado?: SortOrder
    Modificable?: SortOrder
    Descripcion?: SortOrder
    Tipo?: SortOrder
    IDGrupoMetodoPadre?: SortOrder
    Identificador?: SortOrder
    IdentificadorExterno?: SortOrder
  }

  export type metodogrupoAvgOrderByAggregateInput = {
    IDGrupoMetodo?: SortOrder
    IDGrupoMetodoPadre?: SortOrder
  }

  export type metodogrupoMaxOrderByAggregateInput = {
    IDGrupoMetodo?: SortOrder
    NombreGrupoMetodo?: SortOrder
    Corporacion?: SortOrder
    Departamento?: SortOrder
    Edificio?: SortOrder
    Itinerario?: SortOrder
    Empleado?: SortOrder
    Modificable?: SortOrder
    Descripcion?: SortOrder
    Tipo?: SortOrder
    IDGrupoMetodoPadre?: SortOrder
    Identificador?: SortOrder
    IdentificadorExterno?: SortOrder
  }

  export type metodogrupoMinOrderByAggregateInput = {
    IDGrupoMetodo?: SortOrder
    NombreGrupoMetodo?: SortOrder
    Corporacion?: SortOrder
    Departamento?: SortOrder
    Edificio?: SortOrder
    Itinerario?: SortOrder
    Empleado?: SortOrder
    Modificable?: SortOrder
    Descripcion?: SortOrder
    Tipo?: SortOrder
    IDGrupoMetodoPadre?: SortOrder
    Identificador?: SortOrder
    IdentificadorExterno?: SortOrder
  }

  export type metodogrupoSumOrderByAggregateInput = {
    IDGrupoMetodo?: SortOrder
    IDGrupoMetodoPadre?: SortOrder
  }

  export type StringFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringFilter | string
  }

  export type metodosCountOrderByAggregateInput = {
    IDMetodo?: SortOrder
    Indice?: SortOrder
    IDGrupoMetodo?: SortOrder
    IDLibreria?: SortOrder
    IDMetodoPadre?: SortOrder
    Clase?: SortOrder
    Tipo?: SortOrder
    Propagable?: SortOrder
    BlobsPropagable?: SortOrder
    NParametros?: SortOrder
    NParametrosBinarios?: SortOrder
    Basico?: SortOrder
    Estado?: SortOrder
    Descripcion?: SortOrder
    NombreMetodo?: SortOrder
    NombreFuncion?: SortOrder
    MetodoTrigger?: SortOrder
    EnvioAplicacion?: SortOrder
    EjecucionLibre?: SortOrder
  }

  export type metodosAvgOrderByAggregateInput = {
    IDMetodo?: SortOrder
    Indice?: SortOrder
    IDGrupoMetodo?: SortOrder
    IDLibreria?: SortOrder
    IDMetodoPadre?: SortOrder
    NParametros?: SortOrder
    NParametrosBinarios?: SortOrder
  }

  export type metodosMaxOrderByAggregateInput = {
    IDMetodo?: SortOrder
    Indice?: SortOrder
    IDGrupoMetodo?: SortOrder
    IDLibreria?: SortOrder
    IDMetodoPadre?: SortOrder
    Clase?: SortOrder
    Tipo?: SortOrder
    Propagable?: SortOrder
    BlobsPropagable?: SortOrder
    NParametros?: SortOrder
    NParametrosBinarios?: SortOrder
    Basico?: SortOrder
    Estado?: SortOrder
    Descripcion?: SortOrder
    NombreMetodo?: SortOrder
    NombreFuncion?: SortOrder
    MetodoTrigger?: SortOrder
    EnvioAplicacion?: SortOrder
    EjecucionLibre?: SortOrder
  }

  export type metodosMinOrderByAggregateInput = {
    IDMetodo?: SortOrder
    Indice?: SortOrder
    IDGrupoMetodo?: SortOrder
    IDLibreria?: SortOrder
    IDMetodoPadre?: SortOrder
    Clase?: SortOrder
    Tipo?: SortOrder
    Propagable?: SortOrder
    BlobsPropagable?: SortOrder
    NParametros?: SortOrder
    NParametrosBinarios?: SortOrder
    Basico?: SortOrder
    Estado?: SortOrder
    Descripcion?: SortOrder
    NombreMetodo?: SortOrder
    NombreFuncion?: SortOrder
    MetodoTrigger?: SortOrder
    EnvioAplicacion?: SortOrder
    EjecucionLibre?: SortOrder
  }

  export type metodosSumOrderByAggregateInput = {
    IDMetodo?: SortOrder
    Indice?: SortOrder
    IDGrupoMetodo?: SortOrder
    IDLibreria?: SortOrder
    IDMetodoPadre?: SortOrder
    NParametros?: SortOrder
    NParametrosBinarios?: SortOrder
  }

  export type StringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type objetosplanimetriaCountOrderByAggregateInput = {
    Id?: SortOrder
    NombreObjeto?: SortOrder
    URLHost?: SortOrder
    IpHost?: SortOrder
    Puerto?: SortOrder
    Usuario?: SortOrder
    Clave?: SortOrder
  }

  export type objetosplanimetriaAvgOrderByAggregateInput = {
    Id?: SortOrder
    Puerto?: SortOrder
  }

  export type objetosplanimetriaMaxOrderByAggregateInput = {
    Id?: SortOrder
    NombreObjeto?: SortOrder
    URLHost?: SortOrder
    IpHost?: SortOrder
    Puerto?: SortOrder
    Usuario?: SortOrder
    Clave?: SortOrder
  }

  export type objetosplanimetriaMinOrderByAggregateInput = {
    Id?: SortOrder
    NombreObjeto?: SortOrder
    URLHost?: SortOrder
    IpHost?: SortOrder
    Puerto?: SortOrder
    Usuario?: SortOrder
    Clave?: SortOrder
  }

  export type objetosplanimetriaSumOrderByAggregateInput = {
    Id?: SortOrder
    Puerto?: SortOrder
  }

  export type reldispositivodispositivoCountOrderByAggregateInput = {
    IDRelDisDispositivo?: SortOrder
    IDDispositivoPadre?: SortOrder
    IDDispositivoHijo?: SortOrder
  }

  export type reldispositivodispositivoAvgOrderByAggregateInput = {
    IDRelDisDispositivo?: SortOrder
    IDDispositivoPadre?: SortOrder
    IDDispositivoHijo?: SortOrder
  }

  export type reldispositivodispositivoMaxOrderByAggregateInput = {
    IDRelDisDispositivo?: SortOrder
    IDDispositivoPadre?: SortOrder
    IDDispositivoHijo?: SortOrder
  }

  export type reldispositivodispositivoMinOrderByAggregateInput = {
    IDRelDisDispositivo?: SortOrder
    IDDispositivoPadre?: SortOrder
    IDDispositivoHijo?: SortOrder
  }

  export type reldispositivodispositivoSumOrderByAggregateInput = {
    IDRelDisDispositivo?: SortOrder
    IDDispositivoPadre?: SortOrder
    IDDispositivoHijo?: SortOrder
  }

  export type reldispositivogatewayCountOrderByAggregateInput = {
    IDRelDisGateway?: SortOrder
    IDDispositivo?: SortOrder
    IDGateway?: SortOrder
  }

  export type reldispositivogatewayAvgOrderByAggregateInput = {
    IDRelDisGateway?: SortOrder
    IDDispositivo?: SortOrder
    IDGateway?: SortOrder
  }

  export type reldispositivogatewayMaxOrderByAggregateInput = {
    IDRelDisGateway?: SortOrder
    IDDispositivo?: SortOrder
    IDGateway?: SortOrder
  }

  export type reldispositivogatewayMinOrderByAggregateInput = {
    IDRelDisGateway?: SortOrder
    IDDispositivo?: SortOrder
    IDGateway?: SortOrder
  }

  export type reldispositivogatewaySumOrderByAggregateInput = {
    IDRelDisGateway?: SortOrder
    IDDispositivo?: SortOrder
    IDGateway?: SortOrder
  }

  export type reldispositivogrupodispositivoCountOrderByAggregateInput = {
    IDRelDisGrupoDis?: SortOrder
    IDGrupo?: SortOrder
    IDDispositivo?: SortOrder
  }

  export type reldispositivogrupodispositivoAvgOrderByAggregateInput = {
    IDRelDisGrupoDis?: SortOrder
  }

  export type reldispositivogrupodispositivoMaxOrderByAggregateInput = {
    IDRelDisGrupoDis?: SortOrder
    IDGrupo?: SortOrder
    IDDispositivo?: SortOrder
  }

  export type reldispositivogrupodispositivoMinOrderByAggregateInput = {
    IDRelDisGrupoDis?: SortOrder
    IDGrupo?: SortOrder
    IDDispositivo?: SortOrder
  }

  export type reldispositivogrupodispositivoSumOrderByAggregateInput = {
    IDRelDisGrupoDis?: SortOrder
  }

  export type reldispositivoperfildispositivoCountOrderByAggregateInput = {
    IDRelDisPerfil?: SortOrder
    IDDispositivo?: SortOrder
    IDPerfilDispositivo?: SortOrder
  }

  export type reldispositivoperfildispositivoAvgOrderByAggregateInput = {
    IDRelDisPerfil?: SortOrder
    IDDispositivo?: SortOrder
    IDPerfilDispositivo?: SortOrder
  }

  export type reldispositivoperfildispositivoMaxOrderByAggregateInput = {
    IDRelDisPerfil?: SortOrder
    IDDispositivo?: SortOrder
    IDPerfilDispositivo?: SortOrder
  }

  export type reldispositivoperfildispositivoMinOrderByAggregateInput = {
    IDRelDisPerfil?: SortOrder
    IDDispositivo?: SortOrder
    IDPerfilDispositivo?: SortOrder
  }

  export type reldispositivoperfildispositivoSumOrderByAggregateInput = {
    IDRelDisPerfil?: SortOrder
    IDDispositivo?: SortOrder
    IDPerfilDispositivo?: SortOrder
  }

  export type reldispositivoplantillaanalogicaCountOrderByAggregateInput = {
    IDRelDisPlantillaAnaloga?: SortOrder
    IDPlantillaAnalogica?: SortOrder
    IDDispositivo?: SortOrder
    Formula?: SortOrder
    Version?: SortOrder
  }

  export type reldispositivoplantillaanalogicaAvgOrderByAggregateInput = {
    IDRelDisPlantillaAnaloga?: SortOrder
    IDPlantillaAnalogica?: SortOrder
    IDDispositivo?: SortOrder
  }

  export type reldispositivoplantillaanalogicaMaxOrderByAggregateInput = {
    IDRelDisPlantillaAnaloga?: SortOrder
    IDPlantillaAnalogica?: SortOrder
    IDDispositivo?: SortOrder
    Formula?: SortOrder
    Version?: SortOrder
  }

  export type reldispositivoplantillaanalogicaMinOrderByAggregateInput = {
    IDRelDisPlantillaAnaloga?: SortOrder
    IDPlantillaAnalogica?: SortOrder
    IDDispositivo?: SortOrder
    Formula?: SortOrder
    Version?: SortOrder
  }

  export type reldispositivoplantillaanalogicaSumOrderByAggregateInput = {
    IDRelDisPlantillaAnaloga?: SortOrder
    IDPlantillaAnalogica?: SortOrder
    IDDispositivo?: SortOrder
  }

  export type reldispositivopuertaCountOrderByAggregateInput = {
    IDRelDisPuerta?: SortOrder
    IDDispositivo?: SortOrder
    IDPuerta?: SortOrder
    IDTipoDispositivo?: SortOrder
  }

  export type reldispositivopuertaAvgOrderByAggregateInput = {
    IDRelDisPuerta?: SortOrder
    IDDispositivo?: SortOrder
    IDPuerta?: SortOrder
    IDTipoDispositivo?: SortOrder
  }

  export type reldispositivopuertaMaxOrderByAggregateInput = {
    IDRelDisPuerta?: SortOrder
    IDDispositivo?: SortOrder
    IDPuerta?: SortOrder
    IDTipoDispositivo?: SortOrder
  }

  export type reldispositivopuertaMinOrderByAggregateInput = {
    IDRelDisPuerta?: SortOrder
    IDDispositivo?: SortOrder
    IDPuerta?: SortOrder
    IDTipoDispositivo?: SortOrder
  }

  export type reldispositivopuertaSumOrderByAggregateInput = {
    IDRelDisPuerta?: SortOrder
    IDDispositivo?: SortOrder
    IDPuerta?: SortOrder
    IDTipoDispositivo?: SortOrder
  }

  export type reldispositivosubsistemaCountOrderByAggregateInput = {
    IDRelDisSubsistema?: SortOrder
    IDSubsistema?: SortOrder
    IDDispositivo?: SortOrder
  }

  export type reldispositivosubsistemaAvgOrderByAggregateInput = {
    IDRelDisSubsistema?: SortOrder
    IDSubsistema?: SortOrder
    IDDispositivo?: SortOrder
  }

  export type reldispositivosubsistemaMaxOrderByAggregateInput = {
    IDRelDisSubsistema?: SortOrder
    IDSubsistema?: SortOrder
    IDDispositivo?: SortOrder
  }

  export type reldispositivosubsistemaMinOrderByAggregateInput = {
    IDRelDisSubsistema?: SortOrder
    IDSubsistema?: SortOrder
    IDDispositivo?: SortOrder
  }

  export type reldispositivosubsistemaSumOrderByAggregateInput = {
    IDRelDisSubsistema?: SortOrder
    IDSubsistema?: SortOrder
    IDDispositivo?: SortOrder
  }

  export type reldispositivotipoeventoCountOrderByAggregateInput = {
    IDRelDisTipoEvento?: SortOrder
    IDDispositivo?: SortOrder
    ClaseEvento?: SortOrder
  }

  export type reldispositivotipoeventoAvgOrderByAggregateInput = {
    IDRelDisTipoEvento?: SortOrder
    IDDispositivo?: SortOrder
    ClaseEvento?: SortOrder
  }

  export type reldispositivotipoeventoMaxOrderByAggregateInput = {
    IDRelDisTipoEvento?: SortOrder
    IDDispositivo?: SortOrder
    ClaseEvento?: SortOrder
  }

  export type reldispositivotipoeventoMinOrderByAggregateInput = {
    IDRelDisTipoEvento?: SortOrder
    IDDispositivo?: SortOrder
    ClaseEvento?: SortOrder
  }

  export type reldispositivotipoeventoSumOrderByAggregateInput = {
    IDRelDisTipoEvento?: SortOrder
    IDDispositivo?: SortOrder
    ClaseEvento?: SortOrder
  }

  export type reldispositivozonaCountOrderByAggregateInput = {
    IDRelDisZona?: SortOrder
    IDDispositivo?: SortOrder
    IDZona?: SortOrder
  }

  export type reldispositivozonaAvgOrderByAggregateInput = {
    IDRelDisZona?: SortOrder
    IDDispositivo?: SortOrder
    IDZona?: SortOrder
  }

  export type reldispositivozonaMaxOrderByAggregateInput = {
    IDRelDisZona?: SortOrder
    IDDispositivo?: SortOrder
    IDZona?: SortOrder
  }

  export type reldispositivozonaMinOrderByAggregateInput = {
    IDRelDisZona?: SortOrder
    IDDispositivo?: SortOrder
    IDZona?: SortOrder
  }

  export type reldispositivozonaSumOrderByAggregateInput = {
    IDRelDisZona?: SortOrder
    IDDispositivo?: SortOrder
    IDZona?: SortOrder
  }

  export type reltipocontroladormetodoCountOrderByAggregateInput = {
    IDTipoControlador?: SortOrder
    IDMetodo?: SortOrder
    RelTipoControladorMetodo?: SortOrder
  }

  export type reltipocontroladormetodoAvgOrderByAggregateInput = {
    IDTipoControlador?: SortOrder
    IDMetodo?: SortOrder
    RelTipoControladorMetodo?: SortOrder
  }

  export type reltipocontroladormetodoMaxOrderByAggregateInput = {
    IDTipoControlador?: SortOrder
    IDMetodo?: SortOrder
    RelTipoControladorMetodo?: SortOrder
  }

  export type reltipocontroladormetodoMinOrderByAggregateInput = {
    IDTipoControlador?: SortOrder
    IDMetodo?: SortOrder
    RelTipoControladorMetodo?: SortOrder
  }

  export type reltipocontroladormetodoSumOrderByAggregateInput = {
    IDTipoControlador?: SortOrder
    IDMetodo?: SortOrder
    RelTipoControladorMetodo?: SortOrder
  }

  export type reltipodispositivoperfildispositivoCountOrderByAggregateInput = {
    IDRelTipoDispPerfil?: SortOrder
    IDTipoDispositivo?: SortOrder
    IDPerfilDispositivo?: SortOrder
  }

  export type reltipodispositivoperfildispositivoAvgOrderByAggregateInput = {
    IDRelTipoDispPerfil?: SortOrder
    IDTipoDispositivo?: SortOrder
    IDPerfilDispositivo?: SortOrder
  }

  export type reltipodispositivoperfildispositivoMaxOrderByAggregateInput = {
    IDRelTipoDispPerfil?: SortOrder
    IDTipoDispositivo?: SortOrder
    IDPerfilDispositivo?: SortOrder
  }

  export type reltipodispositivoperfildispositivoMinOrderByAggregateInput = {
    IDRelTipoDispPerfil?: SortOrder
    IDTipoDispositivo?: SortOrder
    IDPerfilDispositivo?: SortOrder
  }

  export type reltipodispositivoperfildispositivoSumOrderByAggregateInput = {
    IDRelTipoDispPerfil?: SortOrder
    IDTipoDispositivo?: SortOrder
    IDPerfilDispositivo?: SortOrder
  }

  export type reltipodispositivoperfileventoCountOrderByAggregateInput = {
    IDRelTipoDisPerfilEvento?: SortOrder
    IDTipoDispositivo?: SortOrder
    IDPerfilEvento?: SortOrder
  }

  export type reltipodispositivoperfileventoAvgOrderByAggregateInput = {
    IDRelTipoDisPerfilEvento?: SortOrder
    IDTipoDispositivo?: SortOrder
    IDPerfilEvento?: SortOrder
  }

  export type reltipodispositivoperfileventoMaxOrderByAggregateInput = {
    IDRelTipoDisPerfilEvento?: SortOrder
    IDTipoDispositivo?: SortOrder
    IDPerfilEvento?: SortOrder
  }

  export type reltipodispositivoperfileventoMinOrderByAggregateInput = {
    IDRelTipoDisPerfilEvento?: SortOrder
    IDTipoDispositivo?: SortOrder
    IDPerfilEvento?: SortOrder
  }

  export type reltipodispositivoperfileventoSumOrderByAggregateInput = {
    IDRelTipoDisPerfilEvento?: SortOrder
    IDTipoDispositivo?: SortOrder
    IDPerfilEvento?: SortOrder
  }

  export type reltipodispositivotipotecnologiaCountOrderByAggregateInput = {
    IDRelTipoDispTipoTec?: SortOrder
    IDTipoDispositivo?: SortOrder
    IDTipoTecnologia?: SortOrder
  }

  export type reltipodispositivotipotecnologiaAvgOrderByAggregateInput = {
    IDRelTipoDispTipoTec?: SortOrder
    IDTipoDispositivo?: SortOrder
    IDTipoTecnologia?: SortOrder
  }

  export type reltipodispositivotipotecnologiaMaxOrderByAggregateInput = {
    IDRelTipoDispTipoTec?: SortOrder
    IDTipoDispositivo?: SortOrder
    IDTipoTecnologia?: SortOrder
  }

  export type reltipodispositivotipotecnologiaMinOrderByAggregateInput = {
    IDRelTipoDispTipoTec?: SortOrder
    IDTipoDispositivo?: SortOrder
    IDTipoTecnologia?: SortOrder
  }

  export type reltipodispositivotipotecnologiaSumOrderByAggregateInput = {
    IDRelTipoDispTipoTec?: SortOrder
    IDTipoDispositivo?: SortOrder
    IDTipoTecnologia?: SortOrder
  }

  export type reltipogatewayperfildispositivoCountOrderByAggregateInput = {
    IDRelTipoGatewayPerfil?: SortOrder
    IDTipoGateway?: SortOrder
    IDPerfilDispositivo?: SortOrder
  }

  export type reltipogatewayperfildispositivoAvgOrderByAggregateInput = {
    IDRelTipoGatewayPerfil?: SortOrder
    IDTipoGateway?: SortOrder
    IDPerfilDispositivo?: SortOrder
  }

  export type reltipogatewayperfildispositivoMaxOrderByAggregateInput = {
    IDRelTipoGatewayPerfil?: SortOrder
    IDTipoGateway?: SortOrder
    IDPerfilDispositivo?: SortOrder
  }

  export type reltipogatewayperfildispositivoMinOrderByAggregateInput = {
    IDRelTipoGatewayPerfil?: SortOrder
    IDTipoGateway?: SortOrder
    IDPerfilDispositivo?: SortOrder
  }

  export type reltipogatewayperfildispositivoSumOrderByAggregateInput = {
    IDRelTipoGatewayPerfil?: SortOrder
    IDTipoGateway?: SortOrder
    IDPerfilDispositivo?: SortOrder
  }

  export type subsistemasCountOrderByAggregateInput = {
    IDSubSistema?: SortOrder
    NombreSubSistema?: SortOrder
    DescripcionSubSistema?: SortOrder
    URLSubSistema?: SortOrder
    Puerto?: SortOrder
  }

  export type subsistemasAvgOrderByAggregateInput = {
    IDSubSistema?: SortOrder
    Puerto?: SortOrder
  }

  export type subsistemasMaxOrderByAggregateInput = {
    IDSubSistema?: SortOrder
    NombreSubSistema?: SortOrder
    DescripcionSubSistema?: SortOrder
    URLSubSistema?: SortOrder
    Puerto?: SortOrder
  }

  export type subsistemasMinOrderByAggregateInput = {
    IDSubSistema?: SortOrder
    NombreSubSistema?: SortOrder
    DescripcionSubSistema?: SortOrder
    URLSubSistema?: SortOrder
    Puerto?: SortOrder
  }

  export type subsistemasSumOrderByAggregateInput = {
    IDSubSistema?: SortOrder
    Puerto?: SortOrder
  }

  export type tablasinformacionCountOrderByAggregateInput = {
    IDTabla?: SortOrder
    NombreTabla?: SortOrder
    Tipo?: SortOrder
    Identidad?: SortOrder
    CodigoNetsocs?: SortOrder
  }

  export type tablasinformacionAvgOrderByAggregateInput = {
    IDTabla?: SortOrder
    Tipo?: SortOrder
    CodigoNetsocs?: SortOrder
  }

  export type tablasinformacionMaxOrderByAggregateInput = {
    IDTabla?: SortOrder
    NombreTabla?: SortOrder
    Tipo?: SortOrder
    Identidad?: SortOrder
    CodigoNetsocs?: SortOrder
  }

  export type tablasinformacionMinOrderByAggregateInput = {
    IDTabla?: SortOrder
    NombreTabla?: SortOrder
    Tipo?: SortOrder
    Identidad?: SortOrder
    CodigoNetsocs?: SortOrder
  }

  export type tablasinformacionSumOrderByAggregateInput = {
    IDTabla?: SortOrder
    Tipo?: SortOrder
    CodigoNetsocs?: SortOrder
  }

  export type tecnologiasnetsocsCountOrderByAggregateInput = {
    IDTecnologiaGateway?: SortOrder
    NombreTecnologiaGateway?: SortOrder
  }

  export type tecnologiasnetsocsAvgOrderByAggregateInput = {
    IDTecnologiaGateway?: SortOrder
  }

  export type tecnologiasnetsocsMaxOrderByAggregateInput = {
    IDTecnologiaGateway?: SortOrder
    NombreTecnologiaGateway?: SortOrder
  }

  export type tecnologiasnetsocsMinOrderByAggregateInput = {
    IDTecnologiaGateway?: SortOrder
    NombreTecnologiaGateway?: SortOrder
  }

  export type tecnologiasnetsocsSumOrderByAggregateInput = {
    IDTecnologiaGateway?: SortOrder
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableDecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string | null
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableBytesFieldUpdateOperationsInput = {
    set?: Buffer | null
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NestedIntFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type NestedIntNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableFilter | number | null
  }

  export type NestedStringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableFilter | string | null
  }

  export type NestedDecimalNullableFilter = {
    equals?: Decimal | DecimalJsLike | number | string | null
    in?: Enumerable<Decimal> | Enumerable<DecimalJsLike> | Enumerable<number> | Enumerable<string> | null
    notIn?: Enumerable<Decimal> | Enumerable<DecimalJsLike> | Enumerable<number> | Enumerable<string> | null
    lt?: Decimal | DecimalJsLike | number | string
    lte?: Decimal | DecimalJsLike | number | string
    gt?: Decimal | DecimalJsLike | number | string
    gte?: Decimal | DecimalJsLike | number | string
    not?: NestedDecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
  }

  export type NestedDateTimeNullableFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | null
    notIn?: Enumerable<Date> | Enumerable<string> | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableFilter | Date | string | null
  }

  export type NestedIntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    _min?: NestedIntFilter
    _max?: NestedIntFilter
  }

  export type NestedFloatFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatFilter | number
  }

  export type NestedIntNullableWithAggregatesFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedIntNullableFilter
    _min?: NestedIntNullableFilter
    _max?: NestedIntNullableFilter
  }

  export type NestedFloatNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatNullableFilter | number | null
  }

  export type NestedStringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableWithAggregatesFilter | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedStringNullableFilter
    _max?: NestedStringNullableFilter
  }

  export type NestedDecimalNullableWithAggregatesFilter = {
    equals?: Decimal | DecimalJsLike | number | string | null
    in?: Enumerable<Decimal> | Enumerable<DecimalJsLike> | Enumerable<number> | Enumerable<string> | null
    notIn?: Enumerable<Decimal> | Enumerable<DecimalJsLike> | Enumerable<number> | Enumerable<string> | null
    lt?: Decimal | DecimalJsLike | number | string
    lte?: Decimal | DecimalJsLike | number | string
    gt?: Decimal | DecimalJsLike | number | string
    gte?: Decimal | DecimalJsLike | number | string
    not?: NestedDecimalNullableWithAggregatesFilter | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter
    _avg?: NestedDecimalNullableFilter
    _sum?: NestedDecimalNullableFilter
    _min?: NestedDecimalNullableFilter
    _max?: NestedDecimalNullableFilter
  }

  export type NestedDateTimeNullableWithAggregatesFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | null
    notIn?: Enumerable<Date> | Enumerable<string> | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableWithAggregatesFilter | Date | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedDateTimeNullableFilter
    _max?: NestedDateTimeNullableFilter
  }

  export type NestedBytesNullableFilter = {
    equals?: Buffer | null
    in?: Enumerable<Buffer> | null
    notIn?: Enumerable<Buffer> | null
    not?: NestedBytesNullableFilter | Buffer | null
  }

  export type NestedBytesNullableWithAggregatesFilter = {
    equals?: Buffer | null
    in?: Enumerable<Buffer> | null
    notIn?: Enumerable<Buffer> | null
    not?: NestedBytesNullableWithAggregatesFilter | Buffer | null
    _count?: NestedIntNullableFilter
    _min?: NestedBytesNullableFilter
    _max?: NestedBytesNullableFilter
  }

  export type NestedStringFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringFilter | string
  }

  export type NestedStringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}